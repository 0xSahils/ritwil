
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Team
 * 
 */
export type Team = $Result.DefaultSelection<Prisma.$TeamPayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model EmployeeProfile
 * 
 */
export type EmployeeProfile = $Result.DefaultSelection<Prisma.$EmployeeProfilePayload>
/**
 * Model DailyEntry
 * 
 */
export type DailyEntry = $Result.DefaultSelection<Prisma.$DailyEntryPayload>
/**
 * Model Placement
 * 
 */
export type Placement = $Result.DefaultSelection<Prisma.$PlacementPayload>
/**
 * Model MonthlyBilling
 * 
 */
export type MonthlyBilling = $Result.DefaultSelection<Prisma.$MonthlyBillingPayload>
/**
 * Model Incentive
 * 
 */
export type Incentive = $Result.DefaultSelection<Prisma.$IncentivePayload>
/**
 * Model RefreshToken
 * 
 */
export type RefreshToken = $Result.DefaultSelection<Prisma.$RefreshTokenPayload>
/**
 * Model Campaign
 * 
 */
export type Campaign = $Result.DefaultSelection<Prisma.$CampaignPayload>
/**
 * Model CampaignImage
 * 
 */
export type CampaignImage = $Result.DefaultSelection<Prisma.$CampaignImagePayload>
/**
 * Model CampaignTeamLead
 * 
 */
export type CampaignTeamLead = $Result.DefaultSelection<Prisma.$CampaignTeamLeadPayload>
/**
 * Model CampaignAssignment
 * 
 */
export type CampaignAssignment = $Result.DefaultSelection<Prisma.$CampaignAssignmentPayload>
/**
 * Model CampaignTask
 * 
 */
export type CampaignTask = $Result.DefaultSelection<Prisma.$CampaignTaskPayload>
/**
 * Model CampaignActivity
 * 
 */
export type CampaignActivity = $Result.DefaultSelection<Prisma.$CampaignActivityPayload>
/**
 * Model AuditLog
 * 
 */
export type AuditLog = $Result.DefaultSelection<Prisma.$AuditLogPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const Role: {
  SUPER_ADMIN: 'SUPER_ADMIN',
  TEAM_LEAD: 'TEAM_LEAD',
  EMPLOYEE: 'EMPLOYEE'
};

export type Role = (typeof Role)[keyof typeof Role]


export const PlacementType: {
  PERMANENT: 'PERMANENT',
  CONTRACT: 'CONTRACT'
};

export type PlacementType = (typeof PlacementType)[keyof typeof PlacementType]


export const BillingStatus: {
  PENDING: 'PENDING',
  BILLED: 'BILLED',
  CANCELLED: 'CANCELLED',
  HOLD: 'HOLD'
};

export type BillingStatus = (typeof BillingStatus)[keyof typeof BillingStatus]


export const CampaignStatus: {
  DRAFT: 'DRAFT',
  ACTIVE: 'ACTIVE',
  COMPLETED: 'COMPLETED',
  ARCHIVED: 'ARCHIVED'
};

export type CampaignStatus = (typeof CampaignStatus)[keyof typeof CampaignStatus]

}

export type Role = $Enums.Role

export const Role: typeof $Enums.Role

export type PlacementType = $Enums.PlacementType

export const PlacementType: typeof $Enums.PlacementType

export type BillingStatus = $Enums.BillingStatus

export const BillingStatus: typeof $Enums.BillingStatus

export type CampaignStatus = $Enums.CampaignStatus

export const CampaignStatus: typeof $Enums.CampaignStatus

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Teams
 * const teams = await prisma.team.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Teams
   * const teams = await prisma.team.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.team`: Exposes CRUD operations for the **Team** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Teams
    * const teams = await prisma.team.findMany()
    * ```
    */
  get team(): Prisma.TeamDelegate<ExtArgs>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.employeeProfile`: Exposes CRUD operations for the **EmployeeProfile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EmployeeProfiles
    * const employeeProfiles = await prisma.employeeProfile.findMany()
    * ```
    */
  get employeeProfile(): Prisma.EmployeeProfileDelegate<ExtArgs>;

  /**
   * `prisma.dailyEntry`: Exposes CRUD operations for the **DailyEntry** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DailyEntries
    * const dailyEntries = await prisma.dailyEntry.findMany()
    * ```
    */
  get dailyEntry(): Prisma.DailyEntryDelegate<ExtArgs>;

  /**
   * `prisma.placement`: Exposes CRUD operations for the **Placement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Placements
    * const placements = await prisma.placement.findMany()
    * ```
    */
  get placement(): Prisma.PlacementDelegate<ExtArgs>;

  /**
   * `prisma.monthlyBilling`: Exposes CRUD operations for the **MonthlyBilling** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MonthlyBillings
    * const monthlyBillings = await prisma.monthlyBilling.findMany()
    * ```
    */
  get monthlyBilling(): Prisma.MonthlyBillingDelegate<ExtArgs>;

  /**
   * `prisma.incentive`: Exposes CRUD operations for the **Incentive** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Incentives
    * const incentives = await prisma.incentive.findMany()
    * ```
    */
  get incentive(): Prisma.IncentiveDelegate<ExtArgs>;

  /**
   * `prisma.refreshToken`: Exposes CRUD operations for the **RefreshToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RefreshTokens
    * const refreshTokens = await prisma.refreshToken.findMany()
    * ```
    */
  get refreshToken(): Prisma.RefreshTokenDelegate<ExtArgs>;

  /**
   * `prisma.campaign`: Exposes CRUD operations for the **Campaign** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Campaigns
    * const campaigns = await prisma.campaign.findMany()
    * ```
    */
  get campaign(): Prisma.CampaignDelegate<ExtArgs>;

  /**
   * `prisma.campaignImage`: Exposes CRUD operations for the **CampaignImage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CampaignImages
    * const campaignImages = await prisma.campaignImage.findMany()
    * ```
    */
  get campaignImage(): Prisma.CampaignImageDelegate<ExtArgs>;

  /**
   * `prisma.campaignTeamLead`: Exposes CRUD operations for the **CampaignTeamLead** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CampaignTeamLeads
    * const campaignTeamLeads = await prisma.campaignTeamLead.findMany()
    * ```
    */
  get campaignTeamLead(): Prisma.CampaignTeamLeadDelegate<ExtArgs>;

  /**
   * `prisma.campaignAssignment`: Exposes CRUD operations for the **CampaignAssignment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CampaignAssignments
    * const campaignAssignments = await prisma.campaignAssignment.findMany()
    * ```
    */
  get campaignAssignment(): Prisma.CampaignAssignmentDelegate<ExtArgs>;

  /**
   * `prisma.campaignTask`: Exposes CRUD operations for the **CampaignTask** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CampaignTasks
    * const campaignTasks = await prisma.campaignTask.findMany()
    * ```
    */
  get campaignTask(): Prisma.CampaignTaskDelegate<ExtArgs>;

  /**
   * `prisma.campaignActivity`: Exposes CRUD operations for the **CampaignActivity** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CampaignActivities
    * const campaignActivities = await prisma.campaignActivity.findMany()
    * ```
    */
  get campaignActivity(): Prisma.CampaignActivityDelegate<ExtArgs>;

  /**
   * `prisma.auditLog`: Exposes CRUD operations for the **AuditLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AuditLogs
    * const auditLogs = await prisma.auditLog.findMany()
    * ```
    */
  get auditLog(): Prisma.AuditLogDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Team: 'Team',
    User: 'User',
    EmployeeProfile: 'EmployeeProfile',
    DailyEntry: 'DailyEntry',
    Placement: 'Placement',
    MonthlyBilling: 'MonthlyBilling',
    Incentive: 'Incentive',
    RefreshToken: 'RefreshToken',
    Campaign: 'Campaign',
    CampaignImage: 'CampaignImage',
    CampaignTeamLead: 'CampaignTeamLead',
    CampaignAssignment: 'CampaignAssignment',
    CampaignTask: 'CampaignTask',
    CampaignActivity: 'CampaignActivity',
    AuditLog: 'AuditLog'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "team" | "user" | "employeeProfile" | "dailyEntry" | "placement" | "monthlyBilling" | "incentive" | "refreshToken" | "campaign" | "campaignImage" | "campaignTeamLead" | "campaignAssignment" | "campaignTask" | "campaignActivity" | "auditLog"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Team: {
        payload: Prisma.$TeamPayload<ExtArgs>
        fields: Prisma.TeamFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TeamFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TeamFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          findFirst: {
            args: Prisma.TeamFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TeamFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          findMany: {
            args: Prisma.TeamFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>[]
          }
          create: {
            args: Prisma.TeamCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          createMany: {
            args: Prisma.TeamCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TeamCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>[]
          }
          delete: {
            args: Prisma.TeamDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          update: {
            args: Prisma.TeamUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          deleteMany: {
            args: Prisma.TeamDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TeamUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TeamUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          aggregate: {
            args: Prisma.TeamAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTeam>
          }
          groupBy: {
            args: Prisma.TeamGroupByArgs<ExtArgs>
            result: $Utils.Optional<TeamGroupByOutputType>[]
          }
          count: {
            args: Prisma.TeamCountArgs<ExtArgs>
            result: $Utils.Optional<TeamCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      EmployeeProfile: {
        payload: Prisma.$EmployeeProfilePayload<ExtArgs>
        fields: Prisma.EmployeeProfileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmployeeProfileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeProfilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmployeeProfileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeProfilePayload>
          }
          findFirst: {
            args: Prisma.EmployeeProfileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeProfilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmployeeProfileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeProfilePayload>
          }
          findMany: {
            args: Prisma.EmployeeProfileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeProfilePayload>[]
          }
          create: {
            args: Prisma.EmployeeProfileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeProfilePayload>
          }
          createMany: {
            args: Prisma.EmployeeProfileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EmployeeProfileCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeProfilePayload>[]
          }
          delete: {
            args: Prisma.EmployeeProfileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeProfilePayload>
          }
          update: {
            args: Prisma.EmployeeProfileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeProfilePayload>
          }
          deleteMany: {
            args: Prisma.EmployeeProfileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmployeeProfileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EmployeeProfileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeProfilePayload>
          }
          aggregate: {
            args: Prisma.EmployeeProfileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmployeeProfile>
          }
          groupBy: {
            args: Prisma.EmployeeProfileGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmployeeProfileGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmployeeProfileCountArgs<ExtArgs>
            result: $Utils.Optional<EmployeeProfileCountAggregateOutputType> | number
          }
        }
      }
      DailyEntry: {
        payload: Prisma.$DailyEntryPayload<ExtArgs>
        fields: Prisma.DailyEntryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DailyEntryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyEntryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DailyEntryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyEntryPayload>
          }
          findFirst: {
            args: Prisma.DailyEntryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyEntryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DailyEntryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyEntryPayload>
          }
          findMany: {
            args: Prisma.DailyEntryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyEntryPayload>[]
          }
          create: {
            args: Prisma.DailyEntryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyEntryPayload>
          }
          createMany: {
            args: Prisma.DailyEntryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DailyEntryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyEntryPayload>[]
          }
          delete: {
            args: Prisma.DailyEntryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyEntryPayload>
          }
          update: {
            args: Prisma.DailyEntryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyEntryPayload>
          }
          deleteMany: {
            args: Prisma.DailyEntryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DailyEntryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DailyEntryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyEntryPayload>
          }
          aggregate: {
            args: Prisma.DailyEntryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDailyEntry>
          }
          groupBy: {
            args: Prisma.DailyEntryGroupByArgs<ExtArgs>
            result: $Utils.Optional<DailyEntryGroupByOutputType>[]
          }
          count: {
            args: Prisma.DailyEntryCountArgs<ExtArgs>
            result: $Utils.Optional<DailyEntryCountAggregateOutputType> | number
          }
        }
      }
      Placement: {
        payload: Prisma.$PlacementPayload<ExtArgs>
        fields: Prisma.PlacementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PlacementFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlacementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PlacementFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlacementPayload>
          }
          findFirst: {
            args: Prisma.PlacementFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlacementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PlacementFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlacementPayload>
          }
          findMany: {
            args: Prisma.PlacementFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlacementPayload>[]
          }
          create: {
            args: Prisma.PlacementCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlacementPayload>
          }
          createMany: {
            args: Prisma.PlacementCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PlacementCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlacementPayload>[]
          }
          delete: {
            args: Prisma.PlacementDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlacementPayload>
          }
          update: {
            args: Prisma.PlacementUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlacementPayload>
          }
          deleteMany: {
            args: Prisma.PlacementDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PlacementUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PlacementUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlacementPayload>
          }
          aggregate: {
            args: Prisma.PlacementAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePlacement>
          }
          groupBy: {
            args: Prisma.PlacementGroupByArgs<ExtArgs>
            result: $Utils.Optional<PlacementGroupByOutputType>[]
          }
          count: {
            args: Prisma.PlacementCountArgs<ExtArgs>
            result: $Utils.Optional<PlacementCountAggregateOutputType> | number
          }
        }
      }
      MonthlyBilling: {
        payload: Prisma.$MonthlyBillingPayload<ExtArgs>
        fields: Prisma.MonthlyBillingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MonthlyBillingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MonthlyBillingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MonthlyBillingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MonthlyBillingPayload>
          }
          findFirst: {
            args: Prisma.MonthlyBillingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MonthlyBillingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MonthlyBillingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MonthlyBillingPayload>
          }
          findMany: {
            args: Prisma.MonthlyBillingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MonthlyBillingPayload>[]
          }
          create: {
            args: Prisma.MonthlyBillingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MonthlyBillingPayload>
          }
          createMany: {
            args: Prisma.MonthlyBillingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MonthlyBillingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MonthlyBillingPayload>[]
          }
          delete: {
            args: Prisma.MonthlyBillingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MonthlyBillingPayload>
          }
          update: {
            args: Prisma.MonthlyBillingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MonthlyBillingPayload>
          }
          deleteMany: {
            args: Prisma.MonthlyBillingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MonthlyBillingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MonthlyBillingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MonthlyBillingPayload>
          }
          aggregate: {
            args: Prisma.MonthlyBillingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMonthlyBilling>
          }
          groupBy: {
            args: Prisma.MonthlyBillingGroupByArgs<ExtArgs>
            result: $Utils.Optional<MonthlyBillingGroupByOutputType>[]
          }
          count: {
            args: Prisma.MonthlyBillingCountArgs<ExtArgs>
            result: $Utils.Optional<MonthlyBillingCountAggregateOutputType> | number
          }
        }
      }
      Incentive: {
        payload: Prisma.$IncentivePayload<ExtArgs>
        fields: Prisma.IncentiveFieldRefs
        operations: {
          findUnique: {
            args: Prisma.IncentiveFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncentivePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.IncentiveFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncentivePayload>
          }
          findFirst: {
            args: Prisma.IncentiveFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncentivePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.IncentiveFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncentivePayload>
          }
          findMany: {
            args: Prisma.IncentiveFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncentivePayload>[]
          }
          create: {
            args: Prisma.IncentiveCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncentivePayload>
          }
          createMany: {
            args: Prisma.IncentiveCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.IncentiveCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncentivePayload>[]
          }
          delete: {
            args: Prisma.IncentiveDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncentivePayload>
          }
          update: {
            args: Prisma.IncentiveUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncentivePayload>
          }
          deleteMany: {
            args: Prisma.IncentiveDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.IncentiveUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.IncentiveUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncentivePayload>
          }
          aggregate: {
            args: Prisma.IncentiveAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateIncentive>
          }
          groupBy: {
            args: Prisma.IncentiveGroupByArgs<ExtArgs>
            result: $Utils.Optional<IncentiveGroupByOutputType>[]
          }
          count: {
            args: Prisma.IncentiveCountArgs<ExtArgs>
            result: $Utils.Optional<IncentiveCountAggregateOutputType> | number
          }
        }
      }
      RefreshToken: {
        payload: Prisma.$RefreshTokenPayload<ExtArgs>
        fields: Prisma.RefreshTokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RefreshTokenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RefreshTokenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          findFirst: {
            args: Prisma.RefreshTokenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RefreshTokenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          findMany: {
            args: Prisma.RefreshTokenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>[]
          }
          create: {
            args: Prisma.RefreshTokenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          createMany: {
            args: Prisma.RefreshTokenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RefreshTokenCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>[]
          }
          delete: {
            args: Prisma.RefreshTokenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          update: {
            args: Prisma.RefreshTokenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          deleteMany: {
            args: Prisma.RefreshTokenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RefreshTokenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RefreshTokenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          aggregate: {
            args: Prisma.RefreshTokenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRefreshToken>
          }
          groupBy: {
            args: Prisma.RefreshTokenGroupByArgs<ExtArgs>
            result: $Utils.Optional<RefreshTokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.RefreshTokenCountArgs<ExtArgs>
            result: $Utils.Optional<RefreshTokenCountAggregateOutputType> | number
          }
        }
      }
      Campaign: {
        payload: Prisma.$CampaignPayload<ExtArgs>
        fields: Prisma.CampaignFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CampaignFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CampaignFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>
          }
          findFirst: {
            args: Prisma.CampaignFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CampaignFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>
          }
          findMany: {
            args: Prisma.CampaignFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>[]
          }
          create: {
            args: Prisma.CampaignCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>
          }
          createMany: {
            args: Prisma.CampaignCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CampaignCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>[]
          }
          delete: {
            args: Prisma.CampaignDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>
          }
          update: {
            args: Prisma.CampaignUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>
          }
          deleteMany: {
            args: Prisma.CampaignDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CampaignUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CampaignUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>
          }
          aggregate: {
            args: Prisma.CampaignAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCampaign>
          }
          groupBy: {
            args: Prisma.CampaignGroupByArgs<ExtArgs>
            result: $Utils.Optional<CampaignGroupByOutputType>[]
          }
          count: {
            args: Prisma.CampaignCountArgs<ExtArgs>
            result: $Utils.Optional<CampaignCountAggregateOutputType> | number
          }
        }
      }
      CampaignImage: {
        payload: Prisma.$CampaignImagePayload<ExtArgs>
        fields: Prisma.CampaignImageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CampaignImageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignImagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CampaignImageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignImagePayload>
          }
          findFirst: {
            args: Prisma.CampaignImageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignImagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CampaignImageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignImagePayload>
          }
          findMany: {
            args: Prisma.CampaignImageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignImagePayload>[]
          }
          create: {
            args: Prisma.CampaignImageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignImagePayload>
          }
          createMany: {
            args: Prisma.CampaignImageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CampaignImageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignImagePayload>[]
          }
          delete: {
            args: Prisma.CampaignImageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignImagePayload>
          }
          update: {
            args: Prisma.CampaignImageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignImagePayload>
          }
          deleteMany: {
            args: Prisma.CampaignImageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CampaignImageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CampaignImageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignImagePayload>
          }
          aggregate: {
            args: Prisma.CampaignImageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCampaignImage>
          }
          groupBy: {
            args: Prisma.CampaignImageGroupByArgs<ExtArgs>
            result: $Utils.Optional<CampaignImageGroupByOutputType>[]
          }
          count: {
            args: Prisma.CampaignImageCountArgs<ExtArgs>
            result: $Utils.Optional<CampaignImageCountAggregateOutputType> | number
          }
        }
      }
      CampaignTeamLead: {
        payload: Prisma.$CampaignTeamLeadPayload<ExtArgs>
        fields: Prisma.CampaignTeamLeadFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CampaignTeamLeadFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignTeamLeadPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CampaignTeamLeadFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignTeamLeadPayload>
          }
          findFirst: {
            args: Prisma.CampaignTeamLeadFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignTeamLeadPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CampaignTeamLeadFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignTeamLeadPayload>
          }
          findMany: {
            args: Prisma.CampaignTeamLeadFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignTeamLeadPayload>[]
          }
          create: {
            args: Prisma.CampaignTeamLeadCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignTeamLeadPayload>
          }
          createMany: {
            args: Prisma.CampaignTeamLeadCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CampaignTeamLeadCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignTeamLeadPayload>[]
          }
          delete: {
            args: Prisma.CampaignTeamLeadDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignTeamLeadPayload>
          }
          update: {
            args: Prisma.CampaignTeamLeadUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignTeamLeadPayload>
          }
          deleteMany: {
            args: Prisma.CampaignTeamLeadDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CampaignTeamLeadUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CampaignTeamLeadUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignTeamLeadPayload>
          }
          aggregate: {
            args: Prisma.CampaignTeamLeadAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCampaignTeamLead>
          }
          groupBy: {
            args: Prisma.CampaignTeamLeadGroupByArgs<ExtArgs>
            result: $Utils.Optional<CampaignTeamLeadGroupByOutputType>[]
          }
          count: {
            args: Prisma.CampaignTeamLeadCountArgs<ExtArgs>
            result: $Utils.Optional<CampaignTeamLeadCountAggregateOutputType> | number
          }
        }
      }
      CampaignAssignment: {
        payload: Prisma.$CampaignAssignmentPayload<ExtArgs>
        fields: Prisma.CampaignAssignmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CampaignAssignmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignAssignmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CampaignAssignmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignAssignmentPayload>
          }
          findFirst: {
            args: Prisma.CampaignAssignmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignAssignmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CampaignAssignmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignAssignmentPayload>
          }
          findMany: {
            args: Prisma.CampaignAssignmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignAssignmentPayload>[]
          }
          create: {
            args: Prisma.CampaignAssignmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignAssignmentPayload>
          }
          createMany: {
            args: Prisma.CampaignAssignmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CampaignAssignmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignAssignmentPayload>[]
          }
          delete: {
            args: Prisma.CampaignAssignmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignAssignmentPayload>
          }
          update: {
            args: Prisma.CampaignAssignmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignAssignmentPayload>
          }
          deleteMany: {
            args: Prisma.CampaignAssignmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CampaignAssignmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CampaignAssignmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignAssignmentPayload>
          }
          aggregate: {
            args: Prisma.CampaignAssignmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCampaignAssignment>
          }
          groupBy: {
            args: Prisma.CampaignAssignmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<CampaignAssignmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.CampaignAssignmentCountArgs<ExtArgs>
            result: $Utils.Optional<CampaignAssignmentCountAggregateOutputType> | number
          }
        }
      }
      CampaignTask: {
        payload: Prisma.$CampaignTaskPayload<ExtArgs>
        fields: Prisma.CampaignTaskFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CampaignTaskFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignTaskPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CampaignTaskFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignTaskPayload>
          }
          findFirst: {
            args: Prisma.CampaignTaskFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignTaskPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CampaignTaskFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignTaskPayload>
          }
          findMany: {
            args: Prisma.CampaignTaskFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignTaskPayload>[]
          }
          create: {
            args: Prisma.CampaignTaskCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignTaskPayload>
          }
          createMany: {
            args: Prisma.CampaignTaskCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CampaignTaskCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignTaskPayload>[]
          }
          delete: {
            args: Prisma.CampaignTaskDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignTaskPayload>
          }
          update: {
            args: Prisma.CampaignTaskUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignTaskPayload>
          }
          deleteMany: {
            args: Prisma.CampaignTaskDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CampaignTaskUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CampaignTaskUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignTaskPayload>
          }
          aggregate: {
            args: Prisma.CampaignTaskAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCampaignTask>
          }
          groupBy: {
            args: Prisma.CampaignTaskGroupByArgs<ExtArgs>
            result: $Utils.Optional<CampaignTaskGroupByOutputType>[]
          }
          count: {
            args: Prisma.CampaignTaskCountArgs<ExtArgs>
            result: $Utils.Optional<CampaignTaskCountAggregateOutputType> | number
          }
        }
      }
      CampaignActivity: {
        payload: Prisma.$CampaignActivityPayload<ExtArgs>
        fields: Prisma.CampaignActivityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CampaignActivityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignActivityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CampaignActivityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignActivityPayload>
          }
          findFirst: {
            args: Prisma.CampaignActivityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignActivityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CampaignActivityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignActivityPayload>
          }
          findMany: {
            args: Prisma.CampaignActivityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignActivityPayload>[]
          }
          create: {
            args: Prisma.CampaignActivityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignActivityPayload>
          }
          createMany: {
            args: Prisma.CampaignActivityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CampaignActivityCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignActivityPayload>[]
          }
          delete: {
            args: Prisma.CampaignActivityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignActivityPayload>
          }
          update: {
            args: Prisma.CampaignActivityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignActivityPayload>
          }
          deleteMany: {
            args: Prisma.CampaignActivityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CampaignActivityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CampaignActivityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignActivityPayload>
          }
          aggregate: {
            args: Prisma.CampaignActivityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCampaignActivity>
          }
          groupBy: {
            args: Prisma.CampaignActivityGroupByArgs<ExtArgs>
            result: $Utils.Optional<CampaignActivityGroupByOutputType>[]
          }
          count: {
            args: Prisma.CampaignActivityCountArgs<ExtArgs>
            result: $Utils.Optional<CampaignActivityCountAggregateOutputType> | number
          }
        }
      }
      AuditLog: {
        payload: Prisma.$AuditLogPayload<ExtArgs>
        fields: Prisma.AuditLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuditLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuditLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findFirst: {
            args: Prisma.AuditLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuditLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findMany: {
            args: Prisma.AuditLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          create: {
            args: Prisma.AuditLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          createMany: {
            args: Prisma.AuditLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AuditLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          delete: {
            args: Prisma.AuditLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          update: {
            args: Prisma.AuditLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          deleteMany: {
            args: Prisma.AuditLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuditLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AuditLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          aggregate: {
            args: Prisma.AuditLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuditLog>
          }
          groupBy: {
            args: Prisma.AuditLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuditLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuditLogCountArgs<ExtArgs>
            result: $Utils.Optional<AuditLogCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type TeamCountOutputType
   */

  export type TeamCountOutputType = {
    employees: number
  }

  export type TeamCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employees?: boolean | TeamCountOutputTypeCountEmployeesArgs
  }

  // Custom InputTypes
  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamCountOutputType
     */
    select?: TeamCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeCountEmployeesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeProfileWhereInput
  }


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    refreshTokens: number
    dailyEntries: number
    placements: number
    incentives: number
    campaignAssignments: number
    campaignTeamLeads: number
    campaignActivities: number
    createdCampaigns: number
    uploadedCampaignImages: number
    completedCampaignTasks: number
    leadEmployees: number
    auditLogs: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    refreshTokens?: boolean | UserCountOutputTypeCountRefreshTokensArgs
    dailyEntries?: boolean | UserCountOutputTypeCountDailyEntriesArgs
    placements?: boolean | UserCountOutputTypeCountPlacementsArgs
    incentives?: boolean | UserCountOutputTypeCountIncentivesArgs
    campaignAssignments?: boolean | UserCountOutputTypeCountCampaignAssignmentsArgs
    campaignTeamLeads?: boolean | UserCountOutputTypeCountCampaignTeamLeadsArgs
    campaignActivities?: boolean | UserCountOutputTypeCountCampaignActivitiesArgs
    createdCampaigns?: boolean | UserCountOutputTypeCountCreatedCampaignsArgs
    uploadedCampaignImages?: boolean | UserCountOutputTypeCountUploadedCampaignImagesArgs
    completedCampaignTasks?: boolean | UserCountOutputTypeCountCompletedCampaignTasksArgs
    leadEmployees?: boolean | UserCountOutputTypeCountLeadEmployeesArgs
    auditLogs?: boolean | UserCountOutputTypeCountAuditLogsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRefreshTokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RefreshTokenWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountDailyEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DailyEntryWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPlacementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlacementWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountIncentivesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IncentiveWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCampaignAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CampaignAssignmentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCampaignTeamLeadsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CampaignTeamLeadWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCampaignActivitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CampaignActivityWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedCampaignsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CampaignWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUploadedCampaignImagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CampaignImageWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCompletedCampaignTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CampaignTaskWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountLeadEmployeesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeProfileWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAuditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
  }


  /**
   * Count Type PlacementCountOutputType
   */

  export type PlacementCountOutputType = {
    monthlyBillings: number
  }

  export type PlacementCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    monthlyBillings?: boolean | PlacementCountOutputTypeCountMonthlyBillingsArgs
  }

  // Custom InputTypes
  /**
   * PlacementCountOutputType without action
   */
  export type PlacementCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlacementCountOutputType
     */
    select?: PlacementCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PlacementCountOutputType without action
   */
  export type PlacementCountOutputTypeCountMonthlyBillingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MonthlyBillingWhereInput
  }


  /**
   * Count Type CampaignCountOutputType
   */

  export type CampaignCountOutputType = {
    images: number
    teamLeads: number
    assignments: number
    tasks: number
    activities: number
  }

  export type CampaignCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    images?: boolean | CampaignCountOutputTypeCountImagesArgs
    teamLeads?: boolean | CampaignCountOutputTypeCountTeamLeadsArgs
    assignments?: boolean | CampaignCountOutputTypeCountAssignmentsArgs
    tasks?: boolean | CampaignCountOutputTypeCountTasksArgs
    activities?: boolean | CampaignCountOutputTypeCountActivitiesArgs
  }

  // Custom InputTypes
  /**
   * CampaignCountOutputType without action
   */
  export type CampaignCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignCountOutputType
     */
    select?: CampaignCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CampaignCountOutputType without action
   */
  export type CampaignCountOutputTypeCountImagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CampaignImageWhereInput
  }

  /**
   * CampaignCountOutputType without action
   */
  export type CampaignCountOutputTypeCountTeamLeadsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CampaignTeamLeadWhereInput
  }

  /**
   * CampaignCountOutputType without action
   */
  export type CampaignCountOutputTypeCountAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CampaignAssignmentWhereInput
  }

  /**
   * CampaignCountOutputType without action
   */
  export type CampaignCountOutputTypeCountTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CampaignTaskWhereInput
  }

  /**
   * CampaignCountOutputType without action
   */
  export type CampaignCountOutputTypeCountActivitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CampaignActivityWhereInput
  }


  /**
   * Count Type CampaignAssignmentCountOutputType
   */

  export type CampaignAssignmentCountOutputType = {
    tasks: number
  }

  export type CampaignAssignmentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tasks?: boolean | CampaignAssignmentCountOutputTypeCountTasksArgs
  }

  // Custom InputTypes
  /**
   * CampaignAssignmentCountOutputType without action
   */
  export type CampaignAssignmentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignAssignmentCountOutputType
     */
    select?: CampaignAssignmentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CampaignAssignmentCountOutputType without action
   */
  export type CampaignAssignmentCountOutputTypeCountTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CampaignTaskWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Team
   */

  export type AggregateTeam = {
    _count: TeamCountAggregateOutputType | null
    _avg: TeamAvgAggregateOutputType | null
    _sum: TeamSumAggregateOutputType | null
    _min: TeamMinAggregateOutputType | null
    _max: TeamMaxAggregateOutputType | null
  }

  export type TeamAvgAggregateOutputType = {
    yearlyTarget: Decimal | null
  }

  export type TeamSumAggregateOutputType = {
    yearlyTarget: Decimal | null
  }

  export type TeamMinAggregateOutputType = {
    id: string | null
    name: string | null
    color: string | null
    yearlyTarget: Decimal | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TeamMaxAggregateOutputType = {
    id: string | null
    name: string | null
    color: string | null
    yearlyTarget: Decimal | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TeamCountAggregateOutputType = {
    id: number
    name: number
    color: number
    yearlyTarget: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TeamAvgAggregateInputType = {
    yearlyTarget?: true
  }

  export type TeamSumAggregateInputType = {
    yearlyTarget?: true
  }

  export type TeamMinAggregateInputType = {
    id?: true
    name?: true
    color?: true
    yearlyTarget?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TeamMaxAggregateInputType = {
    id?: true
    name?: true
    color?: true
    yearlyTarget?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TeamCountAggregateInputType = {
    id?: true
    name?: true
    color?: true
    yearlyTarget?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TeamAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Team to aggregate.
     */
    where?: TeamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teams to fetch.
     */
    orderBy?: TeamOrderByWithRelationInput | TeamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TeamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Teams
    **/
    _count?: true | TeamCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TeamAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TeamSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TeamMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TeamMaxAggregateInputType
  }

  export type GetTeamAggregateType<T extends TeamAggregateArgs> = {
        [P in keyof T & keyof AggregateTeam]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTeam[P]>
      : GetScalarType<T[P], AggregateTeam[P]>
  }




  export type TeamGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeamWhereInput
    orderBy?: TeamOrderByWithAggregationInput | TeamOrderByWithAggregationInput[]
    by: TeamScalarFieldEnum[] | TeamScalarFieldEnum
    having?: TeamScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TeamCountAggregateInputType | true
    _avg?: TeamAvgAggregateInputType
    _sum?: TeamSumAggregateInputType
    _min?: TeamMinAggregateInputType
    _max?: TeamMaxAggregateInputType
  }

  export type TeamGroupByOutputType = {
    id: string
    name: string
    color: string | null
    yearlyTarget: Decimal
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: TeamCountAggregateOutputType | null
    _avg: TeamAvgAggregateOutputType | null
    _sum: TeamSumAggregateOutputType | null
    _min: TeamMinAggregateOutputType | null
    _max: TeamMaxAggregateOutputType | null
  }

  type GetTeamGroupByPayload<T extends TeamGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TeamGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TeamGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TeamGroupByOutputType[P]>
            : GetScalarType<T[P], TeamGroupByOutputType[P]>
        }
      >
    >


  export type TeamSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    color?: boolean
    yearlyTarget?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    employees?: boolean | Team$employeesArgs<ExtArgs>
    _count?: boolean | TeamCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["team"]>

  export type TeamSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    color?: boolean
    yearlyTarget?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["team"]>

  export type TeamSelectScalar = {
    id?: boolean
    name?: boolean
    color?: boolean
    yearlyTarget?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TeamInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employees?: boolean | Team$employeesArgs<ExtArgs>
    _count?: boolean | TeamCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TeamIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $TeamPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Team"
    objects: {
      employees: Prisma.$EmployeeProfilePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      color: string | null
      yearlyTarget: Prisma.Decimal
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["team"]>
    composites: {}
  }

  type TeamGetPayload<S extends boolean | null | undefined | TeamDefaultArgs> = $Result.GetResult<Prisma.$TeamPayload, S>

  type TeamCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TeamFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TeamCountAggregateInputType | true
    }

  export interface TeamDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Team'], meta: { name: 'Team' } }
    /**
     * Find zero or one Team that matches the filter.
     * @param {TeamFindUniqueArgs} args - Arguments to find a Team
     * @example
     * // Get one Team
     * const team = await prisma.team.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TeamFindUniqueArgs>(args: SelectSubset<T, TeamFindUniqueArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Team that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TeamFindUniqueOrThrowArgs} args - Arguments to find a Team
     * @example
     * // Get one Team
     * const team = await prisma.team.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TeamFindUniqueOrThrowArgs>(args: SelectSubset<T, TeamFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Team that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamFindFirstArgs} args - Arguments to find a Team
     * @example
     * // Get one Team
     * const team = await prisma.team.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TeamFindFirstArgs>(args?: SelectSubset<T, TeamFindFirstArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Team that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamFindFirstOrThrowArgs} args - Arguments to find a Team
     * @example
     * // Get one Team
     * const team = await prisma.team.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TeamFindFirstOrThrowArgs>(args?: SelectSubset<T, TeamFindFirstOrThrowArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Teams that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Teams
     * const teams = await prisma.team.findMany()
     * 
     * // Get first 10 Teams
     * const teams = await prisma.team.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const teamWithIdOnly = await prisma.team.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TeamFindManyArgs>(args?: SelectSubset<T, TeamFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Team.
     * @param {TeamCreateArgs} args - Arguments to create a Team.
     * @example
     * // Create one Team
     * const Team = await prisma.team.create({
     *   data: {
     *     // ... data to create a Team
     *   }
     * })
     * 
     */
    create<T extends TeamCreateArgs>(args: SelectSubset<T, TeamCreateArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Teams.
     * @param {TeamCreateManyArgs} args - Arguments to create many Teams.
     * @example
     * // Create many Teams
     * const team = await prisma.team.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TeamCreateManyArgs>(args?: SelectSubset<T, TeamCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Teams and returns the data saved in the database.
     * @param {TeamCreateManyAndReturnArgs} args - Arguments to create many Teams.
     * @example
     * // Create many Teams
     * const team = await prisma.team.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Teams and only return the `id`
     * const teamWithIdOnly = await prisma.team.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TeamCreateManyAndReturnArgs>(args?: SelectSubset<T, TeamCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Team.
     * @param {TeamDeleteArgs} args - Arguments to delete one Team.
     * @example
     * // Delete one Team
     * const Team = await prisma.team.delete({
     *   where: {
     *     // ... filter to delete one Team
     *   }
     * })
     * 
     */
    delete<T extends TeamDeleteArgs>(args: SelectSubset<T, TeamDeleteArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Team.
     * @param {TeamUpdateArgs} args - Arguments to update one Team.
     * @example
     * // Update one Team
     * const team = await prisma.team.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TeamUpdateArgs>(args: SelectSubset<T, TeamUpdateArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Teams.
     * @param {TeamDeleteManyArgs} args - Arguments to filter Teams to delete.
     * @example
     * // Delete a few Teams
     * const { count } = await prisma.team.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TeamDeleteManyArgs>(args?: SelectSubset<T, TeamDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Teams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Teams
     * const team = await prisma.team.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TeamUpdateManyArgs>(args: SelectSubset<T, TeamUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Team.
     * @param {TeamUpsertArgs} args - Arguments to update or create a Team.
     * @example
     * // Update or create a Team
     * const team = await prisma.team.upsert({
     *   create: {
     *     // ... data to create a Team
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Team we want to update
     *   }
     * })
     */
    upsert<T extends TeamUpsertArgs>(args: SelectSubset<T, TeamUpsertArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Teams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamCountArgs} args - Arguments to filter Teams to count.
     * @example
     * // Count the number of Teams
     * const count = await prisma.team.count({
     *   where: {
     *     // ... the filter for the Teams we want to count
     *   }
     * })
    **/
    count<T extends TeamCountArgs>(
      args?: Subset<T, TeamCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TeamCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Team.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TeamAggregateArgs>(args: Subset<T, TeamAggregateArgs>): Prisma.PrismaPromise<GetTeamAggregateType<T>>

    /**
     * Group by Team.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TeamGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TeamGroupByArgs['orderBy'] }
        : { orderBy?: TeamGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TeamGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTeamGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Team model
   */
  readonly fields: TeamFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Team.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TeamClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    employees<T extends Team$employeesArgs<ExtArgs> = {}>(args?: Subset<T, Team$employeesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeeProfilePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Team model
   */ 
  interface TeamFieldRefs {
    readonly id: FieldRef<"Team", 'String'>
    readonly name: FieldRef<"Team", 'String'>
    readonly color: FieldRef<"Team", 'String'>
    readonly yearlyTarget: FieldRef<"Team", 'Decimal'>
    readonly isActive: FieldRef<"Team", 'Boolean'>
    readonly createdAt: FieldRef<"Team", 'DateTime'>
    readonly updatedAt: FieldRef<"Team", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Team findUnique
   */
  export type TeamFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter, which Team to fetch.
     */
    where: TeamWhereUniqueInput
  }

  /**
   * Team findUniqueOrThrow
   */
  export type TeamFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter, which Team to fetch.
     */
    where: TeamWhereUniqueInput
  }

  /**
   * Team findFirst
   */
  export type TeamFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter, which Team to fetch.
     */
    where?: TeamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teams to fetch.
     */
    orderBy?: TeamOrderByWithRelationInput | TeamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Teams.
     */
    cursor?: TeamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Teams.
     */
    distinct?: TeamScalarFieldEnum | TeamScalarFieldEnum[]
  }

  /**
   * Team findFirstOrThrow
   */
  export type TeamFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter, which Team to fetch.
     */
    where?: TeamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teams to fetch.
     */
    orderBy?: TeamOrderByWithRelationInput | TeamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Teams.
     */
    cursor?: TeamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Teams.
     */
    distinct?: TeamScalarFieldEnum | TeamScalarFieldEnum[]
  }

  /**
   * Team findMany
   */
  export type TeamFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter, which Teams to fetch.
     */
    where?: TeamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teams to fetch.
     */
    orderBy?: TeamOrderByWithRelationInput | TeamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Teams.
     */
    cursor?: TeamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teams.
     */
    skip?: number
    distinct?: TeamScalarFieldEnum | TeamScalarFieldEnum[]
  }

  /**
   * Team create
   */
  export type TeamCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * The data needed to create a Team.
     */
    data: XOR<TeamCreateInput, TeamUncheckedCreateInput>
  }

  /**
   * Team createMany
   */
  export type TeamCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Teams.
     */
    data: TeamCreateManyInput | TeamCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Team createManyAndReturn
   */
  export type TeamCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Teams.
     */
    data: TeamCreateManyInput | TeamCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Team update
   */
  export type TeamUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * The data needed to update a Team.
     */
    data: XOR<TeamUpdateInput, TeamUncheckedUpdateInput>
    /**
     * Choose, which Team to update.
     */
    where: TeamWhereUniqueInput
  }

  /**
   * Team updateMany
   */
  export type TeamUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Teams.
     */
    data: XOR<TeamUpdateManyMutationInput, TeamUncheckedUpdateManyInput>
    /**
     * Filter which Teams to update
     */
    where?: TeamWhereInput
  }

  /**
   * Team upsert
   */
  export type TeamUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * The filter to search for the Team to update in case it exists.
     */
    where: TeamWhereUniqueInput
    /**
     * In case the Team found by the `where` argument doesn't exist, create a new Team with this data.
     */
    create: XOR<TeamCreateInput, TeamUncheckedCreateInput>
    /**
     * In case the Team was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TeamUpdateInput, TeamUncheckedUpdateInput>
  }

  /**
   * Team delete
   */
  export type TeamDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter which Team to delete.
     */
    where: TeamWhereUniqueInput
  }

  /**
   * Team deleteMany
   */
  export type TeamDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Teams to delete
     */
    where?: TeamWhereInput
  }

  /**
   * Team.employees
   */
  export type Team$employeesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeProfile
     */
    select?: EmployeeProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeProfileInclude<ExtArgs> | null
    where?: EmployeeProfileWhereInput
    orderBy?: EmployeeProfileOrderByWithRelationInput | EmployeeProfileOrderByWithRelationInput[]
    cursor?: EmployeeProfileWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmployeeProfileScalarFieldEnum | EmployeeProfileScalarFieldEnum[]
  }

  /**
   * Team without action
   */
  export type TeamDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    passwordHash: string | null
    name: string | null
    role: $Enums.Role | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    passwordHash: string | null
    name: string | null
    role: $Enums.Role | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    passwordHash: number
    name: number
    role: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    passwordHash?: true
    name?: true
    role?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    passwordHash?: true
    name?: true
    role?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    passwordHash?: true
    name?: true
    role?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    passwordHash: string
    name: string
    role: $Enums.Role
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    passwordHash?: boolean
    name?: boolean
    role?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    employeeProfile?: boolean | User$employeeProfileArgs<ExtArgs>
    refreshTokens?: boolean | User$refreshTokensArgs<ExtArgs>
    dailyEntries?: boolean | User$dailyEntriesArgs<ExtArgs>
    placements?: boolean | User$placementsArgs<ExtArgs>
    incentives?: boolean | User$incentivesArgs<ExtArgs>
    campaignAssignments?: boolean | User$campaignAssignmentsArgs<ExtArgs>
    campaignTeamLeads?: boolean | User$campaignTeamLeadsArgs<ExtArgs>
    campaignActivities?: boolean | User$campaignActivitiesArgs<ExtArgs>
    createdCampaigns?: boolean | User$createdCampaignsArgs<ExtArgs>
    uploadedCampaignImages?: boolean | User$uploadedCampaignImagesArgs<ExtArgs>
    completedCampaignTasks?: boolean | User$completedCampaignTasksArgs<ExtArgs>
    leadEmployees?: boolean | User$leadEmployeesArgs<ExtArgs>
    auditLogs?: boolean | User$auditLogsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    passwordHash?: boolean
    name?: boolean
    role?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    passwordHash?: boolean
    name?: boolean
    role?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employeeProfile?: boolean | User$employeeProfileArgs<ExtArgs>
    refreshTokens?: boolean | User$refreshTokensArgs<ExtArgs>
    dailyEntries?: boolean | User$dailyEntriesArgs<ExtArgs>
    placements?: boolean | User$placementsArgs<ExtArgs>
    incentives?: boolean | User$incentivesArgs<ExtArgs>
    campaignAssignments?: boolean | User$campaignAssignmentsArgs<ExtArgs>
    campaignTeamLeads?: boolean | User$campaignTeamLeadsArgs<ExtArgs>
    campaignActivities?: boolean | User$campaignActivitiesArgs<ExtArgs>
    createdCampaigns?: boolean | User$createdCampaignsArgs<ExtArgs>
    uploadedCampaignImages?: boolean | User$uploadedCampaignImagesArgs<ExtArgs>
    completedCampaignTasks?: boolean | User$completedCampaignTasksArgs<ExtArgs>
    leadEmployees?: boolean | User$leadEmployeesArgs<ExtArgs>
    auditLogs?: boolean | User$auditLogsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      employeeProfile: Prisma.$EmployeeProfilePayload<ExtArgs> | null
      refreshTokens: Prisma.$RefreshTokenPayload<ExtArgs>[]
      dailyEntries: Prisma.$DailyEntryPayload<ExtArgs>[]
      placements: Prisma.$PlacementPayload<ExtArgs>[]
      incentives: Prisma.$IncentivePayload<ExtArgs>[]
      campaignAssignments: Prisma.$CampaignAssignmentPayload<ExtArgs>[]
      campaignTeamLeads: Prisma.$CampaignTeamLeadPayload<ExtArgs>[]
      campaignActivities: Prisma.$CampaignActivityPayload<ExtArgs>[]
      createdCampaigns: Prisma.$CampaignPayload<ExtArgs>[]
      uploadedCampaignImages: Prisma.$CampaignImagePayload<ExtArgs>[]
      completedCampaignTasks: Prisma.$CampaignTaskPayload<ExtArgs>[]
      leadEmployees: Prisma.$EmployeeProfilePayload<ExtArgs>[]
      auditLogs: Prisma.$AuditLogPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      passwordHash: string
      name: string
      role: $Enums.Role
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    employeeProfile<T extends User$employeeProfileArgs<ExtArgs> = {}>(args?: Subset<T, User$employeeProfileArgs<ExtArgs>>): Prisma__EmployeeProfileClient<$Result.GetResult<Prisma.$EmployeeProfilePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    refreshTokens<T extends User$refreshTokensArgs<ExtArgs> = {}>(args?: Subset<T, User$refreshTokensArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findMany"> | Null>
    dailyEntries<T extends User$dailyEntriesArgs<ExtArgs> = {}>(args?: Subset<T, User$dailyEntriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DailyEntryPayload<ExtArgs>, T, "findMany"> | Null>
    placements<T extends User$placementsArgs<ExtArgs> = {}>(args?: Subset<T, User$placementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlacementPayload<ExtArgs>, T, "findMany"> | Null>
    incentives<T extends User$incentivesArgs<ExtArgs> = {}>(args?: Subset<T, User$incentivesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IncentivePayload<ExtArgs>, T, "findMany"> | Null>
    campaignAssignments<T extends User$campaignAssignmentsArgs<ExtArgs> = {}>(args?: Subset<T, User$campaignAssignmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignAssignmentPayload<ExtArgs>, T, "findMany"> | Null>
    campaignTeamLeads<T extends User$campaignTeamLeadsArgs<ExtArgs> = {}>(args?: Subset<T, User$campaignTeamLeadsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignTeamLeadPayload<ExtArgs>, T, "findMany"> | Null>
    campaignActivities<T extends User$campaignActivitiesArgs<ExtArgs> = {}>(args?: Subset<T, User$campaignActivitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignActivityPayload<ExtArgs>, T, "findMany"> | Null>
    createdCampaigns<T extends User$createdCampaignsArgs<ExtArgs> = {}>(args?: Subset<T, User$createdCampaignsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findMany"> | Null>
    uploadedCampaignImages<T extends User$uploadedCampaignImagesArgs<ExtArgs> = {}>(args?: Subset<T, User$uploadedCampaignImagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignImagePayload<ExtArgs>, T, "findMany"> | Null>
    completedCampaignTasks<T extends User$completedCampaignTasksArgs<ExtArgs> = {}>(args?: Subset<T, User$completedCampaignTasksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignTaskPayload<ExtArgs>, T, "findMany"> | Null>
    leadEmployees<T extends User$leadEmployeesArgs<ExtArgs> = {}>(args?: Subset<T, User$leadEmployeesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeeProfilePayload<ExtArgs>, T, "findMany"> | Null>
    auditLogs<T extends User$auditLogsArgs<ExtArgs> = {}>(args?: Subset<T, User$auditLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly passwordHash: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'Role'>
    readonly isActive: FieldRef<"User", 'Boolean'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User.employeeProfile
   */
  export type User$employeeProfileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeProfile
     */
    select?: EmployeeProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeProfileInclude<ExtArgs> | null
    where?: EmployeeProfileWhereInput
  }

  /**
   * User.refreshTokens
   */
  export type User$refreshTokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    where?: RefreshTokenWhereInput
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    cursor?: RefreshTokenWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RefreshTokenScalarFieldEnum | RefreshTokenScalarFieldEnum[]
  }

  /**
   * User.dailyEntries
   */
  export type User$dailyEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyEntry
     */
    select?: DailyEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyEntryInclude<ExtArgs> | null
    where?: DailyEntryWhereInput
    orderBy?: DailyEntryOrderByWithRelationInput | DailyEntryOrderByWithRelationInput[]
    cursor?: DailyEntryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DailyEntryScalarFieldEnum | DailyEntryScalarFieldEnum[]
  }

  /**
   * User.placements
   */
  export type User$placementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Placement
     */
    select?: PlacementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlacementInclude<ExtArgs> | null
    where?: PlacementWhereInput
    orderBy?: PlacementOrderByWithRelationInput | PlacementOrderByWithRelationInput[]
    cursor?: PlacementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlacementScalarFieldEnum | PlacementScalarFieldEnum[]
  }

  /**
   * User.incentives
   */
  export type User$incentivesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Incentive
     */
    select?: IncentiveSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncentiveInclude<ExtArgs> | null
    where?: IncentiveWhereInput
    orderBy?: IncentiveOrderByWithRelationInput | IncentiveOrderByWithRelationInput[]
    cursor?: IncentiveWhereUniqueInput
    take?: number
    skip?: number
    distinct?: IncentiveScalarFieldEnum | IncentiveScalarFieldEnum[]
  }

  /**
   * User.campaignAssignments
   */
  export type User$campaignAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignAssignment
     */
    select?: CampaignAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignAssignmentInclude<ExtArgs> | null
    where?: CampaignAssignmentWhereInput
    orderBy?: CampaignAssignmentOrderByWithRelationInput | CampaignAssignmentOrderByWithRelationInput[]
    cursor?: CampaignAssignmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CampaignAssignmentScalarFieldEnum | CampaignAssignmentScalarFieldEnum[]
  }

  /**
   * User.campaignTeamLeads
   */
  export type User$campaignTeamLeadsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignTeamLead
     */
    select?: CampaignTeamLeadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignTeamLeadInclude<ExtArgs> | null
    where?: CampaignTeamLeadWhereInput
    orderBy?: CampaignTeamLeadOrderByWithRelationInput | CampaignTeamLeadOrderByWithRelationInput[]
    cursor?: CampaignTeamLeadWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CampaignTeamLeadScalarFieldEnum | CampaignTeamLeadScalarFieldEnum[]
  }

  /**
   * User.campaignActivities
   */
  export type User$campaignActivitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignActivity
     */
    select?: CampaignActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignActivityInclude<ExtArgs> | null
    where?: CampaignActivityWhereInput
    orderBy?: CampaignActivityOrderByWithRelationInput | CampaignActivityOrderByWithRelationInput[]
    cursor?: CampaignActivityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CampaignActivityScalarFieldEnum | CampaignActivityScalarFieldEnum[]
  }

  /**
   * User.createdCampaigns
   */
  export type User$createdCampaignsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    where?: CampaignWhereInput
    orderBy?: CampaignOrderByWithRelationInput | CampaignOrderByWithRelationInput[]
    cursor?: CampaignWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CampaignScalarFieldEnum | CampaignScalarFieldEnum[]
  }

  /**
   * User.uploadedCampaignImages
   */
  export type User$uploadedCampaignImagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignImage
     */
    select?: CampaignImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignImageInclude<ExtArgs> | null
    where?: CampaignImageWhereInput
    orderBy?: CampaignImageOrderByWithRelationInput | CampaignImageOrderByWithRelationInput[]
    cursor?: CampaignImageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CampaignImageScalarFieldEnum | CampaignImageScalarFieldEnum[]
  }

  /**
   * User.completedCampaignTasks
   */
  export type User$completedCampaignTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignTask
     */
    select?: CampaignTaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignTaskInclude<ExtArgs> | null
    where?: CampaignTaskWhereInput
    orderBy?: CampaignTaskOrderByWithRelationInput | CampaignTaskOrderByWithRelationInput[]
    cursor?: CampaignTaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CampaignTaskScalarFieldEnum | CampaignTaskScalarFieldEnum[]
  }

  /**
   * User.leadEmployees
   */
  export type User$leadEmployeesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeProfile
     */
    select?: EmployeeProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeProfileInclude<ExtArgs> | null
    where?: EmployeeProfileWhereInput
    orderBy?: EmployeeProfileOrderByWithRelationInput | EmployeeProfileOrderByWithRelationInput[]
    cursor?: EmployeeProfileWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmployeeProfileScalarFieldEnum | EmployeeProfileScalarFieldEnum[]
  }

  /**
   * User.auditLogs
   */
  export type User$auditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    cursor?: AuditLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model EmployeeProfile
   */

  export type AggregateEmployeeProfile = {
    _count: EmployeeProfileCountAggregateOutputType | null
    _avg: EmployeeProfileAvgAggregateOutputType | null
    _sum: EmployeeProfileSumAggregateOutputType | null
    _min: EmployeeProfileMinAggregateOutputType | null
    _max: EmployeeProfileMaxAggregateOutputType | null
  }

  export type EmployeeProfileAvgAggregateOutputType = {
    yearlyTarget: Decimal | null
  }

  export type EmployeeProfileSumAggregateOutputType = {
    yearlyTarget: Decimal | null
  }

  export type EmployeeProfileMinAggregateOutputType = {
    id: string | null
    teamId: string | null
    managerId: string | null
    level: string | null
    yearlyTarget: Decimal | null
    isActive: boolean | null
    deletedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EmployeeProfileMaxAggregateOutputType = {
    id: string | null
    teamId: string | null
    managerId: string | null
    level: string | null
    yearlyTarget: Decimal | null
    isActive: boolean | null
    deletedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EmployeeProfileCountAggregateOutputType = {
    id: number
    teamId: number
    managerId: number
    level: number
    yearlyTarget: number
    isActive: number
    deletedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EmployeeProfileAvgAggregateInputType = {
    yearlyTarget?: true
  }

  export type EmployeeProfileSumAggregateInputType = {
    yearlyTarget?: true
  }

  export type EmployeeProfileMinAggregateInputType = {
    id?: true
    teamId?: true
    managerId?: true
    level?: true
    yearlyTarget?: true
    isActive?: true
    deletedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EmployeeProfileMaxAggregateInputType = {
    id?: true
    teamId?: true
    managerId?: true
    level?: true
    yearlyTarget?: true
    isActive?: true
    deletedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EmployeeProfileCountAggregateInputType = {
    id?: true
    teamId?: true
    managerId?: true
    level?: true
    yearlyTarget?: true
    isActive?: true
    deletedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EmployeeProfileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmployeeProfile to aggregate.
     */
    where?: EmployeeProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeeProfiles to fetch.
     */
    orderBy?: EmployeeProfileOrderByWithRelationInput | EmployeeProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmployeeProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeeProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeeProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EmployeeProfiles
    **/
    _count?: true | EmployeeProfileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EmployeeProfileAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EmployeeProfileSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmployeeProfileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmployeeProfileMaxAggregateInputType
  }

  export type GetEmployeeProfileAggregateType<T extends EmployeeProfileAggregateArgs> = {
        [P in keyof T & keyof AggregateEmployeeProfile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmployeeProfile[P]>
      : GetScalarType<T[P], AggregateEmployeeProfile[P]>
  }




  export type EmployeeProfileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeProfileWhereInput
    orderBy?: EmployeeProfileOrderByWithAggregationInput | EmployeeProfileOrderByWithAggregationInput[]
    by: EmployeeProfileScalarFieldEnum[] | EmployeeProfileScalarFieldEnum
    having?: EmployeeProfileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmployeeProfileCountAggregateInputType | true
    _avg?: EmployeeProfileAvgAggregateInputType
    _sum?: EmployeeProfileSumAggregateInputType
    _min?: EmployeeProfileMinAggregateInputType
    _max?: EmployeeProfileMaxAggregateInputType
  }

  export type EmployeeProfileGroupByOutputType = {
    id: string
    teamId: string | null
    managerId: string | null
    level: string | null
    yearlyTarget: Decimal
    isActive: boolean
    deletedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: EmployeeProfileCountAggregateOutputType | null
    _avg: EmployeeProfileAvgAggregateOutputType | null
    _sum: EmployeeProfileSumAggregateOutputType | null
    _min: EmployeeProfileMinAggregateOutputType | null
    _max: EmployeeProfileMaxAggregateOutputType | null
  }

  type GetEmployeeProfileGroupByPayload<T extends EmployeeProfileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmployeeProfileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmployeeProfileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmployeeProfileGroupByOutputType[P]>
            : GetScalarType<T[P], EmployeeProfileGroupByOutputType[P]>
        }
      >
    >


  export type EmployeeProfileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    teamId?: boolean
    managerId?: boolean
    level?: boolean
    yearlyTarget?: boolean
    isActive?: boolean
    deletedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    team?: boolean | EmployeeProfile$teamArgs<ExtArgs>
    manager?: boolean | EmployeeProfile$managerArgs<ExtArgs>
  }, ExtArgs["result"]["employeeProfile"]>

  export type EmployeeProfileSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    teamId?: boolean
    managerId?: boolean
    level?: boolean
    yearlyTarget?: boolean
    isActive?: boolean
    deletedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    team?: boolean | EmployeeProfile$teamArgs<ExtArgs>
    manager?: boolean | EmployeeProfile$managerArgs<ExtArgs>
  }, ExtArgs["result"]["employeeProfile"]>

  export type EmployeeProfileSelectScalar = {
    id?: boolean
    teamId?: boolean
    managerId?: boolean
    level?: boolean
    yearlyTarget?: boolean
    isActive?: boolean
    deletedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type EmployeeProfileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    team?: boolean | EmployeeProfile$teamArgs<ExtArgs>
    manager?: boolean | EmployeeProfile$managerArgs<ExtArgs>
  }
  export type EmployeeProfileIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    team?: boolean | EmployeeProfile$teamArgs<ExtArgs>
    manager?: boolean | EmployeeProfile$managerArgs<ExtArgs>
  }

  export type $EmployeeProfilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EmployeeProfile"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      team: Prisma.$TeamPayload<ExtArgs> | null
      manager: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      teamId: string | null
      managerId: string | null
      level: string | null
      yearlyTarget: Prisma.Decimal
      isActive: boolean
      deletedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["employeeProfile"]>
    composites: {}
  }

  type EmployeeProfileGetPayload<S extends boolean | null | undefined | EmployeeProfileDefaultArgs> = $Result.GetResult<Prisma.$EmployeeProfilePayload, S>

  type EmployeeProfileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EmployeeProfileFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EmployeeProfileCountAggregateInputType | true
    }

  export interface EmployeeProfileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EmployeeProfile'], meta: { name: 'EmployeeProfile' } }
    /**
     * Find zero or one EmployeeProfile that matches the filter.
     * @param {EmployeeProfileFindUniqueArgs} args - Arguments to find a EmployeeProfile
     * @example
     * // Get one EmployeeProfile
     * const employeeProfile = await prisma.employeeProfile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmployeeProfileFindUniqueArgs>(args: SelectSubset<T, EmployeeProfileFindUniqueArgs<ExtArgs>>): Prisma__EmployeeProfileClient<$Result.GetResult<Prisma.$EmployeeProfilePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one EmployeeProfile that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EmployeeProfileFindUniqueOrThrowArgs} args - Arguments to find a EmployeeProfile
     * @example
     * // Get one EmployeeProfile
     * const employeeProfile = await prisma.employeeProfile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmployeeProfileFindUniqueOrThrowArgs>(args: SelectSubset<T, EmployeeProfileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmployeeProfileClient<$Result.GetResult<Prisma.$EmployeeProfilePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first EmployeeProfile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeProfileFindFirstArgs} args - Arguments to find a EmployeeProfile
     * @example
     * // Get one EmployeeProfile
     * const employeeProfile = await prisma.employeeProfile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmployeeProfileFindFirstArgs>(args?: SelectSubset<T, EmployeeProfileFindFirstArgs<ExtArgs>>): Prisma__EmployeeProfileClient<$Result.GetResult<Prisma.$EmployeeProfilePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first EmployeeProfile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeProfileFindFirstOrThrowArgs} args - Arguments to find a EmployeeProfile
     * @example
     * // Get one EmployeeProfile
     * const employeeProfile = await prisma.employeeProfile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmployeeProfileFindFirstOrThrowArgs>(args?: SelectSubset<T, EmployeeProfileFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmployeeProfileClient<$Result.GetResult<Prisma.$EmployeeProfilePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more EmployeeProfiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeProfileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EmployeeProfiles
     * const employeeProfiles = await prisma.employeeProfile.findMany()
     * 
     * // Get first 10 EmployeeProfiles
     * const employeeProfiles = await prisma.employeeProfile.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const employeeProfileWithIdOnly = await prisma.employeeProfile.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EmployeeProfileFindManyArgs>(args?: SelectSubset<T, EmployeeProfileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeeProfilePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a EmployeeProfile.
     * @param {EmployeeProfileCreateArgs} args - Arguments to create a EmployeeProfile.
     * @example
     * // Create one EmployeeProfile
     * const EmployeeProfile = await prisma.employeeProfile.create({
     *   data: {
     *     // ... data to create a EmployeeProfile
     *   }
     * })
     * 
     */
    create<T extends EmployeeProfileCreateArgs>(args: SelectSubset<T, EmployeeProfileCreateArgs<ExtArgs>>): Prisma__EmployeeProfileClient<$Result.GetResult<Prisma.$EmployeeProfilePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many EmployeeProfiles.
     * @param {EmployeeProfileCreateManyArgs} args - Arguments to create many EmployeeProfiles.
     * @example
     * // Create many EmployeeProfiles
     * const employeeProfile = await prisma.employeeProfile.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmployeeProfileCreateManyArgs>(args?: SelectSubset<T, EmployeeProfileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EmployeeProfiles and returns the data saved in the database.
     * @param {EmployeeProfileCreateManyAndReturnArgs} args - Arguments to create many EmployeeProfiles.
     * @example
     * // Create many EmployeeProfiles
     * const employeeProfile = await prisma.employeeProfile.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EmployeeProfiles and only return the `id`
     * const employeeProfileWithIdOnly = await prisma.employeeProfile.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EmployeeProfileCreateManyAndReturnArgs>(args?: SelectSubset<T, EmployeeProfileCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeeProfilePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a EmployeeProfile.
     * @param {EmployeeProfileDeleteArgs} args - Arguments to delete one EmployeeProfile.
     * @example
     * // Delete one EmployeeProfile
     * const EmployeeProfile = await prisma.employeeProfile.delete({
     *   where: {
     *     // ... filter to delete one EmployeeProfile
     *   }
     * })
     * 
     */
    delete<T extends EmployeeProfileDeleteArgs>(args: SelectSubset<T, EmployeeProfileDeleteArgs<ExtArgs>>): Prisma__EmployeeProfileClient<$Result.GetResult<Prisma.$EmployeeProfilePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one EmployeeProfile.
     * @param {EmployeeProfileUpdateArgs} args - Arguments to update one EmployeeProfile.
     * @example
     * // Update one EmployeeProfile
     * const employeeProfile = await prisma.employeeProfile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmployeeProfileUpdateArgs>(args: SelectSubset<T, EmployeeProfileUpdateArgs<ExtArgs>>): Prisma__EmployeeProfileClient<$Result.GetResult<Prisma.$EmployeeProfilePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more EmployeeProfiles.
     * @param {EmployeeProfileDeleteManyArgs} args - Arguments to filter EmployeeProfiles to delete.
     * @example
     * // Delete a few EmployeeProfiles
     * const { count } = await prisma.employeeProfile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmployeeProfileDeleteManyArgs>(args?: SelectSubset<T, EmployeeProfileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmployeeProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeProfileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EmployeeProfiles
     * const employeeProfile = await prisma.employeeProfile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmployeeProfileUpdateManyArgs>(args: SelectSubset<T, EmployeeProfileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EmployeeProfile.
     * @param {EmployeeProfileUpsertArgs} args - Arguments to update or create a EmployeeProfile.
     * @example
     * // Update or create a EmployeeProfile
     * const employeeProfile = await prisma.employeeProfile.upsert({
     *   create: {
     *     // ... data to create a EmployeeProfile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EmployeeProfile we want to update
     *   }
     * })
     */
    upsert<T extends EmployeeProfileUpsertArgs>(args: SelectSubset<T, EmployeeProfileUpsertArgs<ExtArgs>>): Prisma__EmployeeProfileClient<$Result.GetResult<Prisma.$EmployeeProfilePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of EmployeeProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeProfileCountArgs} args - Arguments to filter EmployeeProfiles to count.
     * @example
     * // Count the number of EmployeeProfiles
     * const count = await prisma.employeeProfile.count({
     *   where: {
     *     // ... the filter for the EmployeeProfiles we want to count
     *   }
     * })
    **/
    count<T extends EmployeeProfileCountArgs>(
      args?: Subset<T, EmployeeProfileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmployeeProfileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EmployeeProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeProfileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmployeeProfileAggregateArgs>(args: Subset<T, EmployeeProfileAggregateArgs>): Prisma.PrismaPromise<GetEmployeeProfileAggregateType<T>>

    /**
     * Group by EmployeeProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeProfileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmployeeProfileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmployeeProfileGroupByArgs['orderBy'] }
        : { orderBy?: EmployeeProfileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmployeeProfileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmployeeProfileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EmployeeProfile model
   */
  readonly fields: EmployeeProfileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EmployeeProfile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmployeeProfileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    team<T extends EmployeeProfile$teamArgs<ExtArgs> = {}>(args?: Subset<T, EmployeeProfile$teamArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    manager<T extends EmployeeProfile$managerArgs<ExtArgs> = {}>(args?: Subset<T, EmployeeProfile$managerArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EmployeeProfile model
   */ 
  interface EmployeeProfileFieldRefs {
    readonly id: FieldRef<"EmployeeProfile", 'String'>
    readonly teamId: FieldRef<"EmployeeProfile", 'String'>
    readonly managerId: FieldRef<"EmployeeProfile", 'String'>
    readonly level: FieldRef<"EmployeeProfile", 'String'>
    readonly yearlyTarget: FieldRef<"EmployeeProfile", 'Decimal'>
    readonly isActive: FieldRef<"EmployeeProfile", 'Boolean'>
    readonly deletedAt: FieldRef<"EmployeeProfile", 'DateTime'>
    readonly createdAt: FieldRef<"EmployeeProfile", 'DateTime'>
    readonly updatedAt: FieldRef<"EmployeeProfile", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EmployeeProfile findUnique
   */
  export type EmployeeProfileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeProfile
     */
    select?: EmployeeProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeProfileInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeProfile to fetch.
     */
    where: EmployeeProfileWhereUniqueInput
  }

  /**
   * EmployeeProfile findUniqueOrThrow
   */
  export type EmployeeProfileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeProfile
     */
    select?: EmployeeProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeProfileInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeProfile to fetch.
     */
    where: EmployeeProfileWhereUniqueInput
  }

  /**
   * EmployeeProfile findFirst
   */
  export type EmployeeProfileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeProfile
     */
    select?: EmployeeProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeProfileInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeProfile to fetch.
     */
    where?: EmployeeProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeeProfiles to fetch.
     */
    orderBy?: EmployeeProfileOrderByWithRelationInput | EmployeeProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmployeeProfiles.
     */
    cursor?: EmployeeProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeeProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeeProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmployeeProfiles.
     */
    distinct?: EmployeeProfileScalarFieldEnum | EmployeeProfileScalarFieldEnum[]
  }

  /**
   * EmployeeProfile findFirstOrThrow
   */
  export type EmployeeProfileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeProfile
     */
    select?: EmployeeProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeProfileInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeProfile to fetch.
     */
    where?: EmployeeProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeeProfiles to fetch.
     */
    orderBy?: EmployeeProfileOrderByWithRelationInput | EmployeeProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmployeeProfiles.
     */
    cursor?: EmployeeProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeeProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeeProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmployeeProfiles.
     */
    distinct?: EmployeeProfileScalarFieldEnum | EmployeeProfileScalarFieldEnum[]
  }

  /**
   * EmployeeProfile findMany
   */
  export type EmployeeProfileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeProfile
     */
    select?: EmployeeProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeProfileInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeProfiles to fetch.
     */
    where?: EmployeeProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeeProfiles to fetch.
     */
    orderBy?: EmployeeProfileOrderByWithRelationInput | EmployeeProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EmployeeProfiles.
     */
    cursor?: EmployeeProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeeProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeeProfiles.
     */
    skip?: number
    distinct?: EmployeeProfileScalarFieldEnum | EmployeeProfileScalarFieldEnum[]
  }

  /**
   * EmployeeProfile create
   */
  export type EmployeeProfileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeProfile
     */
    select?: EmployeeProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeProfileInclude<ExtArgs> | null
    /**
     * The data needed to create a EmployeeProfile.
     */
    data: XOR<EmployeeProfileCreateInput, EmployeeProfileUncheckedCreateInput>
  }

  /**
   * EmployeeProfile createMany
   */
  export type EmployeeProfileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EmployeeProfiles.
     */
    data: EmployeeProfileCreateManyInput | EmployeeProfileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EmployeeProfile createManyAndReturn
   */
  export type EmployeeProfileCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeProfile
     */
    select?: EmployeeProfileSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many EmployeeProfiles.
     */
    data: EmployeeProfileCreateManyInput | EmployeeProfileCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeProfileIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EmployeeProfile update
   */
  export type EmployeeProfileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeProfile
     */
    select?: EmployeeProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeProfileInclude<ExtArgs> | null
    /**
     * The data needed to update a EmployeeProfile.
     */
    data: XOR<EmployeeProfileUpdateInput, EmployeeProfileUncheckedUpdateInput>
    /**
     * Choose, which EmployeeProfile to update.
     */
    where: EmployeeProfileWhereUniqueInput
  }

  /**
   * EmployeeProfile updateMany
   */
  export type EmployeeProfileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EmployeeProfiles.
     */
    data: XOR<EmployeeProfileUpdateManyMutationInput, EmployeeProfileUncheckedUpdateManyInput>
    /**
     * Filter which EmployeeProfiles to update
     */
    where?: EmployeeProfileWhereInput
  }

  /**
   * EmployeeProfile upsert
   */
  export type EmployeeProfileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeProfile
     */
    select?: EmployeeProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeProfileInclude<ExtArgs> | null
    /**
     * The filter to search for the EmployeeProfile to update in case it exists.
     */
    where: EmployeeProfileWhereUniqueInput
    /**
     * In case the EmployeeProfile found by the `where` argument doesn't exist, create a new EmployeeProfile with this data.
     */
    create: XOR<EmployeeProfileCreateInput, EmployeeProfileUncheckedCreateInput>
    /**
     * In case the EmployeeProfile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmployeeProfileUpdateInput, EmployeeProfileUncheckedUpdateInput>
  }

  /**
   * EmployeeProfile delete
   */
  export type EmployeeProfileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeProfile
     */
    select?: EmployeeProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeProfileInclude<ExtArgs> | null
    /**
     * Filter which EmployeeProfile to delete.
     */
    where: EmployeeProfileWhereUniqueInput
  }

  /**
   * EmployeeProfile deleteMany
   */
  export type EmployeeProfileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmployeeProfiles to delete
     */
    where?: EmployeeProfileWhereInput
  }

  /**
   * EmployeeProfile.team
   */
  export type EmployeeProfile$teamArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    where?: TeamWhereInput
  }

  /**
   * EmployeeProfile.manager
   */
  export type EmployeeProfile$managerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * EmployeeProfile without action
   */
  export type EmployeeProfileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeProfile
     */
    select?: EmployeeProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeProfileInclude<ExtArgs> | null
  }


  /**
   * Model DailyEntry
   */

  export type AggregateDailyEntry = {
    _count: DailyEntryCountAggregateOutputType | null
    _avg: DailyEntryAvgAggregateOutputType | null
    _sum: DailyEntrySumAggregateOutputType | null
    _min: DailyEntryMinAggregateOutputType | null
    _max: DailyEntryMaxAggregateOutputType | null
  }

  export type DailyEntryAvgAggregateOutputType = {
    revenue: Decimal | null
    marginPercent: Decimal | null
  }

  export type DailyEntrySumAggregateOutputType = {
    revenue: Decimal | null
    marginPercent: Decimal | null
  }

  export type DailyEntryMinAggregateOutputType = {
    id: string | null
    employeeId: string | null
    date: Date | null
    clientName: string | null
    placementType: $Enums.PlacementType | null
    revenue: Decimal | null
    marginPercent: Decimal | null
    billingStatus: $Enums.BillingStatus | null
    doi: Date | null
    doj: Date | null
    remarks: string | null
    createdAt: Date | null
  }

  export type DailyEntryMaxAggregateOutputType = {
    id: string | null
    employeeId: string | null
    date: Date | null
    clientName: string | null
    placementType: $Enums.PlacementType | null
    revenue: Decimal | null
    marginPercent: Decimal | null
    billingStatus: $Enums.BillingStatus | null
    doi: Date | null
    doj: Date | null
    remarks: string | null
    createdAt: Date | null
  }

  export type DailyEntryCountAggregateOutputType = {
    id: number
    employeeId: number
    date: number
    clientName: number
    placementType: number
    revenue: number
    marginPercent: number
    billingStatus: number
    doi: number
    doj: number
    remarks: number
    createdAt: number
    _all: number
  }


  export type DailyEntryAvgAggregateInputType = {
    revenue?: true
    marginPercent?: true
  }

  export type DailyEntrySumAggregateInputType = {
    revenue?: true
    marginPercent?: true
  }

  export type DailyEntryMinAggregateInputType = {
    id?: true
    employeeId?: true
    date?: true
    clientName?: true
    placementType?: true
    revenue?: true
    marginPercent?: true
    billingStatus?: true
    doi?: true
    doj?: true
    remarks?: true
    createdAt?: true
  }

  export type DailyEntryMaxAggregateInputType = {
    id?: true
    employeeId?: true
    date?: true
    clientName?: true
    placementType?: true
    revenue?: true
    marginPercent?: true
    billingStatus?: true
    doi?: true
    doj?: true
    remarks?: true
    createdAt?: true
  }

  export type DailyEntryCountAggregateInputType = {
    id?: true
    employeeId?: true
    date?: true
    clientName?: true
    placementType?: true
    revenue?: true
    marginPercent?: true
    billingStatus?: true
    doi?: true
    doj?: true
    remarks?: true
    createdAt?: true
    _all?: true
  }

  export type DailyEntryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DailyEntry to aggregate.
     */
    where?: DailyEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DailyEntries to fetch.
     */
    orderBy?: DailyEntryOrderByWithRelationInput | DailyEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DailyEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DailyEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DailyEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DailyEntries
    **/
    _count?: true | DailyEntryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DailyEntryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DailyEntrySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DailyEntryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DailyEntryMaxAggregateInputType
  }

  export type GetDailyEntryAggregateType<T extends DailyEntryAggregateArgs> = {
        [P in keyof T & keyof AggregateDailyEntry]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDailyEntry[P]>
      : GetScalarType<T[P], AggregateDailyEntry[P]>
  }




  export type DailyEntryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DailyEntryWhereInput
    orderBy?: DailyEntryOrderByWithAggregationInput | DailyEntryOrderByWithAggregationInput[]
    by: DailyEntryScalarFieldEnum[] | DailyEntryScalarFieldEnum
    having?: DailyEntryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DailyEntryCountAggregateInputType | true
    _avg?: DailyEntryAvgAggregateInputType
    _sum?: DailyEntrySumAggregateInputType
    _min?: DailyEntryMinAggregateInputType
    _max?: DailyEntryMaxAggregateInputType
  }

  export type DailyEntryGroupByOutputType = {
    id: string
    employeeId: string
    date: Date
    clientName: string
    placementType: $Enums.PlacementType
    revenue: Decimal
    marginPercent: Decimal
    billingStatus: $Enums.BillingStatus
    doi: Date
    doj: Date
    remarks: string | null
    createdAt: Date
    _count: DailyEntryCountAggregateOutputType | null
    _avg: DailyEntryAvgAggregateOutputType | null
    _sum: DailyEntrySumAggregateOutputType | null
    _min: DailyEntryMinAggregateOutputType | null
    _max: DailyEntryMaxAggregateOutputType | null
  }

  type GetDailyEntryGroupByPayload<T extends DailyEntryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DailyEntryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DailyEntryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DailyEntryGroupByOutputType[P]>
            : GetScalarType<T[P], DailyEntryGroupByOutputType[P]>
        }
      >
    >


  export type DailyEntrySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    date?: boolean
    clientName?: boolean
    placementType?: boolean
    revenue?: boolean
    marginPercent?: boolean
    billingStatus?: boolean
    doi?: boolean
    doj?: boolean
    remarks?: boolean
    createdAt?: boolean
    employee?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dailyEntry"]>

  export type DailyEntrySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    date?: boolean
    clientName?: boolean
    placementType?: boolean
    revenue?: boolean
    marginPercent?: boolean
    billingStatus?: boolean
    doi?: boolean
    doj?: boolean
    remarks?: boolean
    createdAt?: boolean
    employee?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dailyEntry"]>

  export type DailyEntrySelectScalar = {
    id?: boolean
    employeeId?: boolean
    date?: boolean
    clientName?: boolean
    placementType?: boolean
    revenue?: boolean
    marginPercent?: boolean
    billingStatus?: boolean
    doi?: boolean
    doj?: boolean
    remarks?: boolean
    createdAt?: boolean
  }

  export type DailyEntryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type DailyEntryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $DailyEntryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DailyEntry"
    objects: {
      employee: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      employeeId: string
      date: Date
      clientName: string
      placementType: $Enums.PlacementType
      revenue: Prisma.Decimal
      marginPercent: Prisma.Decimal
      billingStatus: $Enums.BillingStatus
      doi: Date
      doj: Date
      remarks: string | null
      createdAt: Date
    }, ExtArgs["result"]["dailyEntry"]>
    composites: {}
  }

  type DailyEntryGetPayload<S extends boolean | null | undefined | DailyEntryDefaultArgs> = $Result.GetResult<Prisma.$DailyEntryPayload, S>

  type DailyEntryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DailyEntryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DailyEntryCountAggregateInputType | true
    }

  export interface DailyEntryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DailyEntry'], meta: { name: 'DailyEntry' } }
    /**
     * Find zero or one DailyEntry that matches the filter.
     * @param {DailyEntryFindUniqueArgs} args - Arguments to find a DailyEntry
     * @example
     * // Get one DailyEntry
     * const dailyEntry = await prisma.dailyEntry.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DailyEntryFindUniqueArgs>(args: SelectSubset<T, DailyEntryFindUniqueArgs<ExtArgs>>): Prisma__DailyEntryClient<$Result.GetResult<Prisma.$DailyEntryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one DailyEntry that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DailyEntryFindUniqueOrThrowArgs} args - Arguments to find a DailyEntry
     * @example
     * // Get one DailyEntry
     * const dailyEntry = await prisma.dailyEntry.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DailyEntryFindUniqueOrThrowArgs>(args: SelectSubset<T, DailyEntryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DailyEntryClient<$Result.GetResult<Prisma.$DailyEntryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first DailyEntry that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyEntryFindFirstArgs} args - Arguments to find a DailyEntry
     * @example
     * // Get one DailyEntry
     * const dailyEntry = await prisma.dailyEntry.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DailyEntryFindFirstArgs>(args?: SelectSubset<T, DailyEntryFindFirstArgs<ExtArgs>>): Prisma__DailyEntryClient<$Result.GetResult<Prisma.$DailyEntryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first DailyEntry that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyEntryFindFirstOrThrowArgs} args - Arguments to find a DailyEntry
     * @example
     * // Get one DailyEntry
     * const dailyEntry = await prisma.dailyEntry.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DailyEntryFindFirstOrThrowArgs>(args?: SelectSubset<T, DailyEntryFindFirstOrThrowArgs<ExtArgs>>): Prisma__DailyEntryClient<$Result.GetResult<Prisma.$DailyEntryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more DailyEntries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyEntryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DailyEntries
     * const dailyEntries = await prisma.dailyEntry.findMany()
     * 
     * // Get first 10 DailyEntries
     * const dailyEntries = await prisma.dailyEntry.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dailyEntryWithIdOnly = await prisma.dailyEntry.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DailyEntryFindManyArgs>(args?: SelectSubset<T, DailyEntryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DailyEntryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a DailyEntry.
     * @param {DailyEntryCreateArgs} args - Arguments to create a DailyEntry.
     * @example
     * // Create one DailyEntry
     * const DailyEntry = await prisma.dailyEntry.create({
     *   data: {
     *     // ... data to create a DailyEntry
     *   }
     * })
     * 
     */
    create<T extends DailyEntryCreateArgs>(args: SelectSubset<T, DailyEntryCreateArgs<ExtArgs>>): Prisma__DailyEntryClient<$Result.GetResult<Prisma.$DailyEntryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many DailyEntries.
     * @param {DailyEntryCreateManyArgs} args - Arguments to create many DailyEntries.
     * @example
     * // Create many DailyEntries
     * const dailyEntry = await prisma.dailyEntry.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DailyEntryCreateManyArgs>(args?: SelectSubset<T, DailyEntryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DailyEntries and returns the data saved in the database.
     * @param {DailyEntryCreateManyAndReturnArgs} args - Arguments to create many DailyEntries.
     * @example
     * // Create many DailyEntries
     * const dailyEntry = await prisma.dailyEntry.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DailyEntries and only return the `id`
     * const dailyEntryWithIdOnly = await prisma.dailyEntry.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DailyEntryCreateManyAndReturnArgs>(args?: SelectSubset<T, DailyEntryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DailyEntryPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a DailyEntry.
     * @param {DailyEntryDeleteArgs} args - Arguments to delete one DailyEntry.
     * @example
     * // Delete one DailyEntry
     * const DailyEntry = await prisma.dailyEntry.delete({
     *   where: {
     *     // ... filter to delete one DailyEntry
     *   }
     * })
     * 
     */
    delete<T extends DailyEntryDeleteArgs>(args: SelectSubset<T, DailyEntryDeleteArgs<ExtArgs>>): Prisma__DailyEntryClient<$Result.GetResult<Prisma.$DailyEntryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one DailyEntry.
     * @param {DailyEntryUpdateArgs} args - Arguments to update one DailyEntry.
     * @example
     * // Update one DailyEntry
     * const dailyEntry = await prisma.dailyEntry.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DailyEntryUpdateArgs>(args: SelectSubset<T, DailyEntryUpdateArgs<ExtArgs>>): Prisma__DailyEntryClient<$Result.GetResult<Prisma.$DailyEntryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more DailyEntries.
     * @param {DailyEntryDeleteManyArgs} args - Arguments to filter DailyEntries to delete.
     * @example
     * // Delete a few DailyEntries
     * const { count } = await prisma.dailyEntry.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DailyEntryDeleteManyArgs>(args?: SelectSubset<T, DailyEntryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DailyEntries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyEntryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DailyEntries
     * const dailyEntry = await prisma.dailyEntry.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DailyEntryUpdateManyArgs>(args: SelectSubset<T, DailyEntryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DailyEntry.
     * @param {DailyEntryUpsertArgs} args - Arguments to update or create a DailyEntry.
     * @example
     * // Update or create a DailyEntry
     * const dailyEntry = await prisma.dailyEntry.upsert({
     *   create: {
     *     // ... data to create a DailyEntry
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DailyEntry we want to update
     *   }
     * })
     */
    upsert<T extends DailyEntryUpsertArgs>(args: SelectSubset<T, DailyEntryUpsertArgs<ExtArgs>>): Prisma__DailyEntryClient<$Result.GetResult<Prisma.$DailyEntryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of DailyEntries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyEntryCountArgs} args - Arguments to filter DailyEntries to count.
     * @example
     * // Count the number of DailyEntries
     * const count = await prisma.dailyEntry.count({
     *   where: {
     *     // ... the filter for the DailyEntries we want to count
     *   }
     * })
    **/
    count<T extends DailyEntryCountArgs>(
      args?: Subset<T, DailyEntryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DailyEntryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DailyEntry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyEntryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DailyEntryAggregateArgs>(args: Subset<T, DailyEntryAggregateArgs>): Prisma.PrismaPromise<GetDailyEntryAggregateType<T>>

    /**
     * Group by DailyEntry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyEntryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DailyEntryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DailyEntryGroupByArgs['orderBy'] }
        : { orderBy?: DailyEntryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DailyEntryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDailyEntryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DailyEntry model
   */
  readonly fields: DailyEntryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DailyEntry.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DailyEntryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    employee<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DailyEntry model
   */ 
  interface DailyEntryFieldRefs {
    readonly id: FieldRef<"DailyEntry", 'String'>
    readonly employeeId: FieldRef<"DailyEntry", 'String'>
    readonly date: FieldRef<"DailyEntry", 'DateTime'>
    readonly clientName: FieldRef<"DailyEntry", 'String'>
    readonly placementType: FieldRef<"DailyEntry", 'PlacementType'>
    readonly revenue: FieldRef<"DailyEntry", 'Decimal'>
    readonly marginPercent: FieldRef<"DailyEntry", 'Decimal'>
    readonly billingStatus: FieldRef<"DailyEntry", 'BillingStatus'>
    readonly doi: FieldRef<"DailyEntry", 'DateTime'>
    readonly doj: FieldRef<"DailyEntry", 'DateTime'>
    readonly remarks: FieldRef<"DailyEntry", 'String'>
    readonly createdAt: FieldRef<"DailyEntry", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DailyEntry findUnique
   */
  export type DailyEntryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyEntry
     */
    select?: DailyEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyEntryInclude<ExtArgs> | null
    /**
     * Filter, which DailyEntry to fetch.
     */
    where: DailyEntryWhereUniqueInput
  }

  /**
   * DailyEntry findUniqueOrThrow
   */
  export type DailyEntryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyEntry
     */
    select?: DailyEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyEntryInclude<ExtArgs> | null
    /**
     * Filter, which DailyEntry to fetch.
     */
    where: DailyEntryWhereUniqueInput
  }

  /**
   * DailyEntry findFirst
   */
  export type DailyEntryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyEntry
     */
    select?: DailyEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyEntryInclude<ExtArgs> | null
    /**
     * Filter, which DailyEntry to fetch.
     */
    where?: DailyEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DailyEntries to fetch.
     */
    orderBy?: DailyEntryOrderByWithRelationInput | DailyEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DailyEntries.
     */
    cursor?: DailyEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DailyEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DailyEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DailyEntries.
     */
    distinct?: DailyEntryScalarFieldEnum | DailyEntryScalarFieldEnum[]
  }

  /**
   * DailyEntry findFirstOrThrow
   */
  export type DailyEntryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyEntry
     */
    select?: DailyEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyEntryInclude<ExtArgs> | null
    /**
     * Filter, which DailyEntry to fetch.
     */
    where?: DailyEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DailyEntries to fetch.
     */
    orderBy?: DailyEntryOrderByWithRelationInput | DailyEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DailyEntries.
     */
    cursor?: DailyEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DailyEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DailyEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DailyEntries.
     */
    distinct?: DailyEntryScalarFieldEnum | DailyEntryScalarFieldEnum[]
  }

  /**
   * DailyEntry findMany
   */
  export type DailyEntryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyEntry
     */
    select?: DailyEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyEntryInclude<ExtArgs> | null
    /**
     * Filter, which DailyEntries to fetch.
     */
    where?: DailyEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DailyEntries to fetch.
     */
    orderBy?: DailyEntryOrderByWithRelationInput | DailyEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DailyEntries.
     */
    cursor?: DailyEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DailyEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DailyEntries.
     */
    skip?: number
    distinct?: DailyEntryScalarFieldEnum | DailyEntryScalarFieldEnum[]
  }

  /**
   * DailyEntry create
   */
  export type DailyEntryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyEntry
     */
    select?: DailyEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyEntryInclude<ExtArgs> | null
    /**
     * The data needed to create a DailyEntry.
     */
    data: XOR<DailyEntryCreateInput, DailyEntryUncheckedCreateInput>
  }

  /**
   * DailyEntry createMany
   */
  export type DailyEntryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DailyEntries.
     */
    data: DailyEntryCreateManyInput | DailyEntryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DailyEntry createManyAndReturn
   */
  export type DailyEntryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyEntry
     */
    select?: DailyEntrySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many DailyEntries.
     */
    data: DailyEntryCreateManyInput | DailyEntryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyEntryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DailyEntry update
   */
  export type DailyEntryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyEntry
     */
    select?: DailyEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyEntryInclude<ExtArgs> | null
    /**
     * The data needed to update a DailyEntry.
     */
    data: XOR<DailyEntryUpdateInput, DailyEntryUncheckedUpdateInput>
    /**
     * Choose, which DailyEntry to update.
     */
    where: DailyEntryWhereUniqueInput
  }

  /**
   * DailyEntry updateMany
   */
  export type DailyEntryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DailyEntries.
     */
    data: XOR<DailyEntryUpdateManyMutationInput, DailyEntryUncheckedUpdateManyInput>
    /**
     * Filter which DailyEntries to update
     */
    where?: DailyEntryWhereInput
  }

  /**
   * DailyEntry upsert
   */
  export type DailyEntryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyEntry
     */
    select?: DailyEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyEntryInclude<ExtArgs> | null
    /**
     * The filter to search for the DailyEntry to update in case it exists.
     */
    where: DailyEntryWhereUniqueInput
    /**
     * In case the DailyEntry found by the `where` argument doesn't exist, create a new DailyEntry with this data.
     */
    create: XOR<DailyEntryCreateInput, DailyEntryUncheckedCreateInput>
    /**
     * In case the DailyEntry was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DailyEntryUpdateInput, DailyEntryUncheckedUpdateInput>
  }

  /**
   * DailyEntry delete
   */
  export type DailyEntryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyEntry
     */
    select?: DailyEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyEntryInclude<ExtArgs> | null
    /**
     * Filter which DailyEntry to delete.
     */
    where: DailyEntryWhereUniqueInput
  }

  /**
   * DailyEntry deleteMany
   */
  export type DailyEntryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DailyEntries to delete
     */
    where?: DailyEntryWhereInput
  }

  /**
   * DailyEntry without action
   */
  export type DailyEntryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyEntry
     */
    select?: DailyEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyEntryInclude<ExtArgs> | null
  }


  /**
   * Model Placement
   */

  export type AggregatePlacement = {
    _count: PlacementCountAggregateOutputType | null
    _avg: PlacementAvgAggregateOutputType | null
    _sum: PlacementSumAggregateOutputType | null
    _min: PlacementMinAggregateOutputType | null
    _max: PlacementMaxAggregateOutputType | null
  }

  export type PlacementAvgAggregateOutputType = {
    daysCompleted: number | null
    billedHours: number | null
    marginPercent: Decimal | null
    revenue: Decimal | null
    incentiveAmountInr: Decimal | null
  }

  export type PlacementSumAggregateOutputType = {
    daysCompleted: number | null
    billedHours: number | null
    marginPercent: Decimal | null
    revenue: Decimal | null
    incentiveAmountInr: Decimal | null
  }

  export type PlacementMinAggregateOutputType = {
    id: string | null
    employeeId: string | null
    candidateName: string | null
    clientName: string | null
    doi: Date | null
    doj: Date | null
    daysCompleted: number | null
    placementType: $Enums.PlacementType | null
    billedHours: number | null
    marginPercent: Decimal | null
    revenue: Decimal | null
    billingStatus: $Enums.BillingStatus | null
    incentivePayoutEta: Date | null
    incentiveAmountInr: Decimal | null
    incentivePaid: boolean | null
    qualifier: boolean | null
    createdAt: Date | null
  }

  export type PlacementMaxAggregateOutputType = {
    id: string | null
    employeeId: string | null
    candidateName: string | null
    clientName: string | null
    doi: Date | null
    doj: Date | null
    daysCompleted: number | null
    placementType: $Enums.PlacementType | null
    billedHours: number | null
    marginPercent: Decimal | null
    revenue: Decimal | null
    billingStatus: $Enums.BillingStatus | null
    incentivePayoutEta: Date | null
    incentiveAmountInr: Decimal | null
    incentivePaid: boolean | null
    qualifier: boolean | null
    createdAt: Date | null
  }

  export type PlacementCountAggregateOutputType = {
    id: number
    employeeId: number
    candidateName: number
    clientName: number
    doi: number
    doj: number
    daysCompleted: number
    placementType: number
    billedHours: number
    marginPercent: number
    revenue: number
    billingStatus: number
    incentivePayoutEta: number
    incentiveAmountInr: number
    incentivePaid: number
    qualifier: number
    createdAt: number
    _all: number
  }


  export type PlacementAvgAggregateInputType = {
    daysCompleted?: true
    billedHours?: true
    marginPercent?: true
    revenue?: true
    incentiveAmountInr?: true
  }

  export type PlacementSumAggregateInputType = {
    daysCompleted?: true
    billedHours?: true
    marginPercent?: true
    revenue?: true
    incentiveAmountInr?: true
  }

  export type PlacementMinAggregateInputType = {
    id?: true
    employeeId?: true
    candidateName?: true
    clientName?: true
    doi?: true
    doj?: true
    daysCompleted?: true
    placementType?: true
    billedHours?: true
    marginPercent?: true
    revenue?: true
    billingStatus?: true
    incentivePayoutEta?: true
    incentiveAmountInr?: true
    incentivePaid?: true
    qualifier?: true
    createdAt?: true
  }

  export type PlacementMaxAggregateInputType = {
    id?: true
    employeeId?: true
    candidateName?: true
    clientName?: true
    doi?: true
    doj?: true
    daysCompleted?: true
    placementType?: true
    billedHours?: true
    marginPercent?: true
    revenue?: true
    billingStatus?: true
    incentivePayoutEta?: true
    incentiveAmountInr?: true
    incentivePaid?: true
    qualifier?: true
    createdAt?: true
  }

  export type PlacementCountAggregateInputType = {
    id?: true
    employeeId?: true
    candidateName?: true
    clientName?: true
    doi?: true
    doj?: true
    daysCompleted?: true
    placementType?: true
    billedHours?: true
    marginPercent?: true
    revenue?: true
    billingStatus?: true
    incentivePayoutEta?: true
    incentiveAmountInr?: true
    incentivePaid?: true
    qualifier?: true
    createdAt?: true
    _all?: true
  }

  export type PlacementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Placement to aggregate.
     */
    where?: PlacementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Placements to fetch.
     */
    orderBy?: PlacementOrderByWithRelationInput | PlacementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PlacementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Placements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Placements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Placements
    **/
    _count?: true | PlacementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PlacementAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PlacementSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlacementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlacementMaxAggregateInputType
  }

  export type GetPlacementAggregateType<T extends PlacementAggregateArgs> = {
        [P in keyof T & keyof AggregatePlacement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlacement[P]>
      : GetScalarType<T[P], AggregatePlacement[P]>
  }




  export type PlacementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlacementWhereInput
    orderBy?: PlacementOrderByWithAggregationInput | PlacementOrderByWithAggregationInput[]
    by: PlacementScalarFieldEnum[] | PlacementScalarFieldEnum
    having?: PlacementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PlacementCountAggregateInputType | true
    _avg?: PlacementAvgAggregateInputType
    _sum?: PlacementSumAggregateInputType
    _min?: PlacementMinAggregateInputType
    _max?: PlacementMaxAggregateInputType
  }

  export type PlacementGroupByOutputType = {
    id: string
    employeeId: string
    candidateName: string
    clientName: string
    doi: Date
    doj: Date
    daysCompleted: number
    placementType: $Enums.PlacementType
    billedHours: number | null
    marginPercent: Decimal
    revenue: Decimal
    billingStatus: $Enums.BillingStatus
    incentivePayoutEta: Date | null
    incentiveAmountInr: Decimal
    incentivePaid: boolean
    qualifier: boolean
    createdAt: Date
    _count: PlacementCountAggregateOutputType | null
    _avg: PlacementAvgAggregateOutputType | null
    _sum: PlacementSumAggregateOutputType | null
    _min: PlacementMinAggregateOutputType | null
    _max: PlacementMaxAggregateOutputType | null
  }

  type GetPlacementGroupByPayload<T extends PlacementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PlacementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlacementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlacementGroupByOutputType[P]>
            : GetScalarType<T[P], PlacementGroupByOutputType[P]>
        }
      >
    >


  export type PlacementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    candidateName?: boolean
    clientName?: boolean
    doi?: boolean
    doj?: boolean
    daysCompleted?: boolean
    placementType?: boolean
    billedHours?: boolean
    marginPercent?: boolean
    revenue?: boolean
    billingStatus?: boolean
    incentivePayoutEta?: boolean
    incentiveAmountInr?: boolean
    incentivePaid?: boolean
    qualifier?: boolean
    createdAt?: boolean
    employee?: boolean | UserDefaultArgs<ExtArgs>
    monthlyBillings?: boolean | Placement$monthlyBillingsArgs<ExtArgs>
    _count?: boolean | PlacementCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["placement"]>

  export type PlacementSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    candidateName?: boolean
    clientName?: boolean
    doi?: boolean
    doj?: boolean
    daysCompleted?: boolean
    placementType?: boolean
    billedHours?: boolean
    marginPercent?: boolean
    revenue?: boolean
    billingStatus?: boolean
    incentivePayoutEta?: boolean
    incentiveAmountInr?: boolean
    incentivePaid?: boolean
    qualifier?: boolean
    createdAt?: boolean
    employee?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["placement"]>

  export type PlacementSelectScalar = {
    id?: boolean
    employeeId?: boolean
    candidateName?: boolean
    clientName?: boolean
    doi?: boolean
    doj?: boolean
    daysCompleted?: boolean
    placementType?: boolean
    billedHours?: boolean
    marginPercent?: boolean
    revenue?: boolean
    billingStatus?: boolean
    incentivePayoutEta?: boolean
    incentiveAmountInr?: boolean
    incentivePaid?: boolean
    qualifier?: boolean
    createdAt?: boolean
  }

  export type PlacementInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | UserDefaultArgs<ExtArgs>
    monthlyBillings?: boolean | Placement$monthlyBillingsArgs<ExtArgs>
    _count?: boolean | PlacementCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PlacementIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $PlacementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Placement"
    objects: {
      employee: Prisma.$UserPayload<ExtArgs>
      monthlyBillings: Prisma.$MonthlyBillingPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      employeeId: string
      candidateName: string
      clientName: string
      doi: Date
      doj: Date
      daysCompleted: number
      placementType: $Enums.PlacementType
      billedHours: number | null
      marginPercent: Prisma.Decimal
      revenue: Prisma.Decimal
      billingStatus: $Enums.BillingStatus
      incentivePayoutEta: Date | null
      incentiveAmountInr: Prisma.Decimal
      incentivePaid: boolean
      qualifier: boolean
      createdAt: Date
    }, ExtArgs["result"]["placement"]>
    composites: {}
  }

  type PlacementGetPayload<S extends boolean | null | undefined | PlacementDefaultArgs> = $Result.GetResult<Prisma.$PlacementPayload, S>

  type PlacementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PlacementFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PlacementCountAggregateInputType | true
    }

  export interface PlacementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Placement'], meta: { name: 'Placement' } }
    /**
     * Find zero or one Placement that matches the filter.
     * @param {PlacementFindUniqueArgs} args - Arguments to find a Placement
     * @example
     * // Get one Placement
     * const placement = await prisma.placement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PlacementFindUniqueArgs>(args: SelectSubset<T, PlacementFindUniqueArgs<ExtArgs>>): Prisma__PlacementClient<$Result.GetResult<Prisma.$PlacementPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Placement that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PlacementFindUniqueOrThrowArgs} args - Arguments to find a Placement
     * @example
     * // Get one Placement
     * const placement = await prisma.placement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PlacementFindUniqueOrThrowArgs>(args: SelectSubset<T, PlacementFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PlacementClient<$Result.GetResult<Prisma.$PlacementPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Placement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlacementFindFirstArgs} args - Arguments to find a Placement
     * @example
     * // Get one Placement
     * const placement = await prisma.placement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PlacementFindFirstArgs>(args?: SelectSubset<T, PlacementFindFirstArgs<ExtArgs>>): Prisma__PlacementClient<$Result.GetResult<Prisma.$PlacementPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Placement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlacementFindFirstOrThrowArgs} args - Arguments to find a Placement
     * @example
     * // Get one Placement
     * const placement = await prisma.placement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PlacementFindFirstOrThrowArgs>(args?: SelectSubset<T, PlacementFindFirstOrThrowArgs<ExtArgs>>): Prisma__PlacementClient<$Result.GetResult<Prisma.$PlacementPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Placements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlacementFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Placements
     * const placements = await prisma.placement.findMany()
     * 
     * // Get first 10 Placements
     * const placements = await prisma.placement.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const placementWithIdOnly = await prisma.placement.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PlacementFindManyArgs>(args?: SelectSubset<T, PlacementFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlacementPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Placement.
     * @param {PlacementCreateArgs} args - Arguments to create a Placement.
     * @example
     * // Create one Placement
     * const Placement = await prisma.placement.create({
     *   data: {
     *     // ... data to create a Placement
     *   }
     * })
     * 
     */
    create<T extends PlacementCreateArgs>(args: SelectSubset<T, PlacementCreateArgs<ExtArgs>>): Prisma__PlacementClient<$Result.GetResult<Prisma.$PlacementPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Placements.
     * @param {PlacementCreateManyArgs} args - Arguments to create many Placements.
     * @example
     * // Create many Placements
     * const placement = await prisma.placement.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PlacementCreateManyArgs>(args?: SelectSubset<T, PlacementCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Placements and returns the data saved in the database.
     * @param {PlacementCreateManyAndReturnArgs} args - Arguments to create many Placements.
     * @example
     * // Create many Placements
     * const placement = await prisma.placement.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Placements and only return the `id`
     * const placementWithIdOnly = await prisma.placement.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PlacementCreateManyAndReturnArgs>(args?: SelectSubset<T, PlacementCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlacementPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Placement.
     * @param {PlacementDeleteArgs} args - Arguments to delete one Placement.
     * @example
     * // Delete one Placement
     * const Placement = await prisma.placement.delete({
     *   where: {
     *     // ... filter to delete one Placement
     *   }
     * })
     * 
     */
    delete<T extends PlacementDeleteArgs>(args: SelectSubset<T, PlacementDeleteArgs<ExtArgs>>): Prisma__PlacementClient<$Result.GetResult<Prisma.$PlacementPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Placement.
     * @param {PlacementUpdateArgs} args - Arguments to update one Placement.
     * @example
     * // Update one Placement
     * const placement = await prisma.placement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PlacementUpdateArgs>(args: SelectSubset<T, PlacementUpdateArgs<ExtArgs>>): Prisma__PlacementClient<$Result.GetResult<Prisma.$PlacementPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Placements.
     * @param {PlacementDeleteManyArgs} args - Arguments to filter Placements to delete.
     * @example
     * // Delete a few Placements
     * const { count } = await prisma.placement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PlacementDeleteManyArgs>(args?: SelectSubset<T, PlacementDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Placements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlacementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Placements
     * const placement = await prisma.placement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PlacementUpdateManyArgs>(args: SelectSubset<T, PlacementUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Placement.
     * @param {PlacementUpsertArgs} args - Arguments to update or create a Placement.
     * @example
     * // Update or create a Placement
     * const placement = await prisma.placement.upsert({
     *   create: {
     *     // ... data to create a Placement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Placement we want to update
     *   }
     * })
     */
    upsert<T extends PlacementUpsertArgs>(args: SelectSubset<T, PlacementUpsertArgs<ExtArgs>>): Prisma__PlacementClient<$Result.GetResult<Prisma.$PlacementPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Placements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlacementCountArgs} args - Arguments to filter Placements to count.
     * @example
     * // Count the number of Placements
     * const count = await prisma.placement.count({
     *   where: {
     *     // ... the filter for the Placements we want to count
     *   }
     * })
    **/
    count<T extends PlacementCountArgs>(
      args?: Subset<T, PlacementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlacementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Placement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlacementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlacementAggregateArgs>(args: Subset<T, PlacementAggregateArgs>): Prisma.PrismaPromise<GetPlacementAggregateType<T>>

    /**
     * Group by Placement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlacementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PlacementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PlacementGroupByArgs['orderBy'] }
        : { orderBy?: PlacementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PlacementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlacementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Placement model
   */
  readonly fields: PlacementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Placement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PlacementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    employee<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    monthlyBillings<T extends Placement$monthlyBillingsArgs<ExtArgs> = {}>(args?: Subset<T, Placement$monthlyBillingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MonthlyBillingPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Placement model
   */ 
  interface PlacementFieldRefs {
    readonly id: FieldRef<"Placement", 'String'>
    readonly employeeId: FieldRef<"Placement", 'String'>
    readonly candidateName: FieldRef<"Placement", 'String'>
    readonly clientName: FieldRef<"Placement", 'String'>
    readonly doi: FieldRef<"Placement", 'DateTime'>
    readonly doj: FieldRef<"Placement", 'DateTime'>
    readonly daysCompleted: FieldRef<"Placement", 'Int'>
    readonly placementType: FieldRef<"Placement", 'PlacementType'>
    readonly billedHours: FieldRef<"Placement", 'Int'>
    readonly marginPercent: FieldRef<"Placement", 'Decimal'>
    readonly revenue: FieldRef<"Placement", 'Decimal'>
    readonly billingStatus: FieldRef<"Placement", 'BillingStatus'>
    readonly incentivePayoutEta: FieldRef<"Placement", 'DateTime'>
    readonly incentiveAmountInr: FieldRef<"Placement", 'Decimal'>
    readonly incentivePaid: FieldRef<"Placement", 'Boolean'>
    readonly qualifier: FieldRef<"Placement", 'Boolean'>
    readonly createdAt: FieldRef<"Placement", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Placement findUnique
   */
  export type PlacementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Placement
     */
    select?: PlacementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlacementInclude<ExtArgs> | null
    /**
     * Filter, which Placement to fetch.
     */
    where: PlacementWhereUniqueInput
  }

  /**
   * Placement findUniqueOrThrow
   */
  export type PlacementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Placement
     */
    select?: PlacementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlacementInclude<ExtArgs> | null
    /**
     * Filter, which Placement to fetch.
     */
    where: PlacementWhereUniqueInput
  }

  /**
   * Placement findFirst
   */
  export type PlacementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Placement
     */
    select?: PlacementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlacementInclude<ExtArgs> | null
    /**
     * Filter, which Placement to fetch.
     */
    where?: PlacementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Placements to fetch.
     */
    orderBy?: PlacementOrderByWithRelationInput | PlacementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Placements.
     */
    cursor?: PlacementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Placements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Placements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Placements.
     */
    distinct?: PlacementScalarFieldEnum | PlacementScalarFieldEnum[]
  }

  /**
   * Placement findFirstOrThrow
   */
  export type PlacementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Placement
     */
    select?: PlacementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlacementInclude<ExtArgs> | null
    /**
     * Filter, which Placement to fetch.
     */
    where?: PlacementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Placements to fetch.
     */
    orderBy?: PlacementOrderByWithRelationInput | PlacementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Placements.
     */
    cursor?: PlacementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Placements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Placements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Placements.
     */
    distinct?: PlacementScalarFieldEnum | PlacementScalarFieldEnum[]
  }

  /**
   * Placement findMany
   */
  export type PlacementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Placement
     */
    select?: PlacementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlacementInclude<ExtArgs> | null
    /**
     * Filter, which Placements to fetch.
     */
    where?: PlacementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Placements to fetch.
     */
    orderBy?: PlacementOrderByWithRelationInput | PlacementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Placements.
     */
    cursor?: PlacementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Placements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Placements.
     */
    skip?: number
    distinct?: PlacementScalarFieldEnum | PlacementScalarFieldEnum[]
  }

  /**
   * Placement create
   */
  export type PlacementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Placement
     */
    select?: PlacementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlacementInclude<ExtArgs> | null
    /**
     * The data needed to create a Placement.
     */
    data: XOR<PlacementCreateInput, PlacementUncheckedCreateInput>
  }

  /**
   * Placement createMany
   */
  export type PlacementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Placements.
     */
    data: PlacementCreateManyInput | PlacementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Placement createManyAndReturn
   */
  export type PlacementCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Placement
     */
    select?: PlacementSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Placements.
     */
    data: PlacementCreateManyInput | PlacementCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlacementIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Placement update
   */
  export type PlacementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Placement
     */
    select?: PlacementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlacementInclude<ExtArgs> | null
    /**
     * The data needed to update a Placement.
     */
    data: XOR<PlacementUpdateInput, PlacementUncheckedUpdateInput>
    /**
     * Choose, which Placement to update.
     */
    where: PlacementWhereUniqueInput
  }

  /**
   * Placement updateMany
   */
  export type PlacementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Placements.
     */
    data: XOR<PlacementUpdateManyMutationInput, PlacementUncheckedUpdateManyInput>
    /**
     * Filter which Placements to update
     */
    where?: PlacementWhereInput
  }

  /**
   * Placement upsert
   */
  export type PlacementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Placement
     */
    select?: PlacementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlacementInclude<ExtArgs> | null
    /**
     * The filter to search for the Placement to update in case it exists.
     */
    where: PlacementWhereUniqueInput
    /**
     * In case the Placement found by the `where` argument doesn't exist, create a new Placement with this data.
     */
    create: XOR<PlacementCreateInput, PlacementUncheckedCreateInput>
    /**
     * In case the Placement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PlacementUpdateInput, PlacementUncheckedUpdateInput>
  }

  /**
   * Placement delete
   */
  export type PlacementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Placement
     */
    select?: PlacementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlacementInclude<ExtArgs> | null
    /**
     * Filter which Placement to delete.
     */
    where: PlacementWhereUniqueInput
  }

  /**
   * Placement deleteMany
   */
  export type PlacementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Placements to delete
     */
    where?: PlacementWhereInput
  }

  /**
   * Placement.monthlyBillings
   */
  export type Placement$monthlyBillingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MonthlyBilling
     */
    select?: MonthlyBillingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MonthlyBillingInclude<ExtArgs> | null
    where?: MonthlyBillingWhereInput
    orderBy?: MonthlyBillingOrderByWithRelationInput | MonthlyBillingOrderByWithRelationInput[]
    cursor?: MonthlyBillingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MonthlyBillingScalarFieldEnum | MonthlyBillingScalarFieldEnum[]
  }

  /**
   * Placement without action
   */
  export type PlacementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Placement
     */
    select?: PlacementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlacementInclude<ExtArgs> | null
  }


  /**
   * Model MonthlyBilling
   */

  export type AggregateMonthlyBilling = {
    _count: MonthlyBillingCountAggregateOutputType | null
    _avg: MonthlyBillingAvgAggregateOutputType | null
    _sum: MonthlyBillingSumAggregateOutputType | null
    _min: MonthlyBillingMinAggregateOutputType | null
    _max: MonthlyBillingMaxAggregateOutputType | null
  }

  export type MonthlyBillingAvgAggregateOutputType = {
    hours: number | null
  }

  export type MonthlyBillingSumAggregateOutputType = {
    hours: number | null
  }

  export type MonthlyBillingMinAggregateOutputType = {
    id: string | null
    placementId: string | null
    month: string | null
    hours: number | null
    status: $Enums.BillingStatus | null
  }

  export type MonthlyBillingMaxAggregateOutputType = {
    id: string | null
    placementId: string | null
    month: string | null
    hours: number | null
    status: $Enums.BillingStatus | null
  }

  export type MonthlyBillingCountAggregateOutputType = {
    id: number
    placementId: number
    month: number
    hours: number
    status: number
    _all: number
  }


  export type MonthlyBillingAvgAggregateInputType = {
    hours?: true
  }

  export type MonthlyBillingSumAggregateInputType = {
    hours?: true
  }

  export type MonthlyBillingMinAggregateInputType = {
    id?: true
    placementId?: true
    month?: true
    hours?: true
    status?: true
  }

  export type MonthlyBillingMaxAggregateInputType = {
    id?: true
    placementId?: true
    month?: true
    hours?: true
    status?: true
  }

  export type MonthlyBillingCountAggregateInputType = {
    id?: true
    placementId?: true
    month?: true
    hours?: true
    status?: true
    _all?: true
  }

  export type MonthlyBillingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MonthlyBilling to aggregate.
     */
    where?: MonthlyBillingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MonthlyBillings to fetch.
     */
    orderBy?: MonthlyBillingOrderByWithRelationInput | MonthlyBillingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MonthlyBillingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MonthlyBillings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MonthlyBillings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MonthlyBillings
    **/
    _count?: true | MonthlyBillingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MonthlyBillingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MonthlyBillingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MonthlyBillingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MonthlyBillingMaxAggregateInputType
  }

  export type GetMonthlyBillingAggregateType<T extends MonthlyBillingAggregateArgs> = {
        [P in keyof T & keyof AggregateMonthlyBilling]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMonthlyBilling[P]>
      : GetScalarType<T[P], AggregateMonthlyBilling[P]>
  }




  export type MonthlyBillingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MonthlyBillingWhereInput
    orderBy?: MonthlyBillingOrderByWithAggregationInput | MonthlyBillingOrderByWithAggregationInput[]
    by: MonthlyBillingScalarFieldEnum[] | MonthlyBillingScalarFieldEnum
    having?: MonthlyBillingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MonthlyBillingCountAggregateInputType | true
    _avg?: MonthlyBillingAvgAggregateInputType
    _sum?: MonthlyBillingSumAggregateInputType
    _min?: MonthlyBillingMinAggregateInputType
    _max?: MonthlyBillingMaxAggregateInputType
  }

  export type MonthlyBillingGroupByOutputType = {
    id: string
    placementId: string
    month: string
    hours: number | null
    status: $Enums.BillingStatus
    _count: MonthlyBillingCountAggregateOutputType | null
    _avg: MonthlyBillingAvgAggregateOutputType | null
    _sum: MonthlyBillingSumAggregateOutputType | null
    _min: MonthlyBillingMinAggregateOutputType | null
    _max: MonthlyBillingMaxAggregateOutputType | null
  }

  type GetMonthlyBillingGroupByPayload<T extends MonthlyBillingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MonthlyBillingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MonthlyBillingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MonthlyBillingGroupByOutputType[P]>
            : GetScalarType<T[P], MonthlyBillingGroupByOutputType[P]>
        }
      >
    >


  export type MonthlyBillingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    placementId?: boolean
    month?: boolean
    hours?: boolean
    status?: boolean
    placement?: boolean | PlacementDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["monthlyBilling"]>

  export type MonthlyBillingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    placementId?: boolean
    month?: boolean
    hours?: boolean
    status?: boolean
    placement?: boolean | PlacementDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["monthlyBilling"]>

  export type MonthlyBillingSelectScalar = {
    id?: boolean
    placementId?: boolean
    month?: boolean
    hours?: boolean
    status?: boolean
  }

  export type MonthlyBillingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    placement?: boolean | PlacementDefaultArgs<ExtArgs>
  }
  export type MonthlyBillingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    placement?: boolean | PlacementDefaultArgs<ExtArgs>
  }

  export type $MonthlyBillingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MonthlyBilling"
    objects: {
      placement: Prisma.$PlacementPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      placementId: string
      month: string
      hours: number | null
      status: $Enums.BillingStatus
    }, ExtArgs["result"]["monthlyBilling"]>
    composites: {}
  }

  type MonthlyBillingGetPayload<S extends boolean | null | undefined | MonthlyBillingDefaultArgs> = $Result.GetResult<Prisma.$MonthlyBillingPayload, S>

  type MonthlyBillingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MonthlyBillingFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MonthlyBillingCountAggregateInputType | true
    }

  export interface MonthlyBillingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MonthlyBilling'], meta: { name: 'MonthlyBilling' } }
    /**
     * Find zero or one MonthlyBilling that matches the filter.
     * @param {MonthlyBillingFindUniqueArgs} args - Arguments to find a MonthlyBilling
     * @example
     * // Get one MonthlyBilling
     * const monthlyBilling = await prisma.monthlyBilling.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MonthlyBillingFindUniqueArgs>(args: SelectSubset<T, MonthlyBillingFindUniqueArgs<ExtArgs>>): Prisma__MonthlyBillingClient<$Result.GetResult<Prisma.$MonthlyBillingPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one MonthlyBilling that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MonthlyBillingFindUniqueOrThrowArgs} args - Arguments to find a MonthlyBilling
     * @example
     * // Get one MonthlyBilling
     * const monthlyBilling = await prisma.monthlyBilling.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MonthlyBillingFindUniqueOrThrowArgs>(args: SelectSubset<T, MonthlyBillingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MonthlyBillingClient<$Result.GetResult<Prisma.$MonthlyBillingPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first MonthlyBilling that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MonthlyBillingFindFirstArgs} args - Arguments to find a MonthlyBilling
     * @example
     * // Get one MonthlyBilling
     * const monthlyBilling = await prisma.monthlyBilling.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MonthlyBillingFindFirstArgs>(args?: SelectSubset<T, MonthlyBillingFindFirstArgs<ExtArgs>>): Prisma__MonthlyBillingClient<$Result.GetResult<Prisma.$MonthlyBillingPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first MonthlyBilling that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MonthlyBillingFindFirstOrThrowArgs} args - Arguments to find a MonthlyBilling
     * @example
     * // Get one MonthlyBilling
     * const monthlyBilling = await prisma.monthlyBilling.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MonthlyBillingFindFirstOrThrowArgs>(args?: SelectSubset<T, MonthlyBillingFindFirstOrThrowArgs<ExtArgs>>): Prisma__MonthlyBillingClient<$Result.GetResult<Prisma.$MonthlyBillingPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more MonthlyBillings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MonthlyBillingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MonthlyBillings
     * const monthlyBillings = await prisma.monthlyBilling.findMany()
     * 
     * // Get first 10 MonthlyBillings
     * const monthlyBillings = await prisma.monthlyBilling.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const monthlyBillingWithIdOnly = await prisma.monthlyBilling.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MonthlyBillingFindManyArgs>(args?: SelectSubset<T, MonthlyBillingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MonthlyBillingPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a MonthlyBilling.
     * @param {MonthlyBillingCreateArgs} args - Arguments to create a MonthlyBilling.
     * @example
     * // Create one MonthlyBilling
     * const MonthlyBilling = await prisma.monthlyBilling.create({
     *   data: {
     *     // ... data to create a MonthlyBilling
     *   }
     * })
     * 
     */
    create<T extends MonthlyBillingCreateArgs>(args: SelectSubset<T, MonthlyBillingCreateArgs<ExtArgs>>): Prisma__MonthlyBillingClient<$Result.GetResult<Prisma.$MonthlyBillingPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many MonthlyBillings.
     * @param {MonthlyBillingCreateManyArgs} args - Arguments to create many MonthlyBillings.
     * @example
     * // Create many MonthlyBillings
     * const monthlyBilling = await prisma.monthlyBilling.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MonthlyBillingCreateManyArgs>(args?: SelectSubset<T, MonthlyBillingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MonthlyBillings and returns the data saved in the database.
     * @param {MonthlyBillingCreateManyAndReturnArgs} args - Arguments to create many MonthlyBillings.
     * @example
     * // Create many MonthlyBillings
     * const monthlyBilling = await prisma.monthlyBilling.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MonthlyBillings and only return the `id`
     * const monthlyBillingWithIdOnly = await prisma.monthlyBilling.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MonthlyBillingCreateManyAndReturnArgs>(args?: SelectSubset<T, MonthlyBillingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MonthlyBillingPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a MonthlyBilling.
     * @param {MonthlyBillingDeleteArgs} args - Arguments to delete one MonthlyBilling.
     * @example
     * // Delete one MonthlyBilling
     * const MonthlyBilling = await prisma.monthlyBilling.delete({
     *   where: {
     *     // ... filter to delete one MonthlyBilling
     *   }
     * })
     * 
     */
    delete<T extends MonthlyBillingDeleteArgs>(args: SelectSubset<T, MonthlyBillingDeleteArgs<ExtArgs>>): Prisma__MonthlyBillingClient<$Result.GetResult<Prisma.$MonthlyBillingPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one MonthlyBilling.
     * @param {MonthlyBillingUpdateArgs} args - Arguments to update one MonthlyBilling.
     * @example
     * // Update one MonthlyBilling
     * const monthlyBilling = await prisma.monthlyBilling.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MonthlyBillingUpdateArgs>(args: SelectSubset<T, MonthlyBillingUpdateArgs<ExtArgs>>): Prisma__MonthlyBillingClient<$Result.GetResult<Prisma.$MonthlyBillingPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more MonthlyBillings.
     * @param {MonthlyBillingDeleteManyArgs} args - Arguments to filter MonthlyBillings to delete.
     * @example
     * // Delete a few MonthlyBillings
     * const { count } = await prisma.monthlyBilling.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MonthlyBillingDeleteManyArgs>(args?: SelectSubset<T, MonthlyBillingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MonthlyBillings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MonthlyBillingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MonthlyBillings
     * const monthlyBilling = await prisma.monthlyBilling.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MonthlyBillingUpdateManyArgs>(args: SelectSubset<T, MonthlyBillingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MonthlyBilling.
     * @param {MonthlyBillingUpsertArgs} args - Arguments to update or create a MonthlyBilling.
     * @example
     * // Update or create a MonthlyBilling
     * const monthlyBilling = await prisma.monthlyBilling.upsert({
     *   create: {
     *     // ... data to create a MonthlyBilling
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MonthlyBilling we want to update
     *   }
     * })
     */
    upsert<T extends MonthlyBillingUpsertArgs>(args: SelectSubset<T, MonthlyBillingUpsertArgs<ExtArgs>>): Prisma__MonthlyBillingClient<$Result.GetResult<Prisma.$MonthlyBillingPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of MonthlyBillings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MonthlyBillingCountArgs} args - Arguments to filter MonthlyBillings to count.
     * @example
     * // Count the number of MonthlyBillings
     * const count = await prisma.monthlyBilling.count({
     *   where: {
     *     // ... the filter for the MonthlyBillings we want to count
     *   }
     * })
    **/
    count<T extends MonthlyBillingCountArgs>(
      args?: Subset<T, MonthlyBillingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MonthlyBillingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MonthlyBilling.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MonthlyBillingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MonthlyBillingAggregateArgs>(args: Subset<T, MonthlyBillingAggregateArgs>): Prisma.PrismaPromise<GetMonthlyBillingAggregateType<T>>

    /**
     * Group by MonthlyBilling.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MonthlyBillingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MonthlyBillingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MonthlyBillingGroupByArgs['orderBy'] }
        : { orderBy?: MonthlyBillingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MonthlyBillingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMonthlyBillingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MonthlyBilling model
   */
  readonly fields: MonthlyBillingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MonthlyBilling.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MonthlyBillingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    placement<T extends PlacementDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PlacementDefaultArgs<ExtArgs>>): Prisma__PlacementClient<$Result.GetResult<Prisma.$PlacementPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MonthlyBilling model
   */ 
  interface MonthlyBillingFieldRefs {
    readonly id: FieldRef<"MonthlyBilling", 'String'>
    readonly placementId: FieldRef<"MonthlyBilling", 'String'>
    readonly month: FieldRef<"MonthlyBilling", 'String'>
    readonly hours: FieldRef<"MonthlyBilling", 'Int'>
    readonly status: FieldRef<"MonthlyBilling", 'BillingStatus'>
  }
    

  // Custom InputTypes
  /**
   * MonthlyBilling findUnique
   */
  export type MonthlyBillingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MonthlyBilling
     */
    select?: MonthlyBillingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MonthlyBillingInclude<ExtArgs> | null
    /**
     * Filter, which MonthlyBilling to fetch.
     */
    where: MonthlyBillingWhereUniqueInput
  }

  /**
   * MonthlyBilling findUniqueOrThrow
   */
  export type MonthlyBillingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MonthlyBilling
     */
    select?: MonthlyBillingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MonthlyBillingInclude<ExtArgs> | null
    /**
     * Filter, which MonthlyBilling to fetch.
     */
    where: MonthlyBillingWhereUniqueInput
  }

  /**
   * MonthlyBilling findFirst
   */
  export type MonthlyBillingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MonthlyBilling
     */
    select?: MonthlyBillingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MonthlyBillingInclude<ExtArgs> | null
    /**
     * Filter, which MonthlyBilling to fetch.
     */
    where?: MonthlyBillingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MonthlyBillings to fetch.
     */
    orderBy?: MonthlyBillingOrderByWithRelationInput | MonthlyBillingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MonthlyBillings.
     */
    cursor?: MonthlyBillingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MonthlyBillings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MonthlyBillings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MonthlyBillings.
     */
    distinct?: MonthlyBillingScalarFieldEnum | MonthlyBillingScalarFieldEnum[]
  }

  /**
   * MonthlyBilling findFirstOrThrow
   */
  export type MonthlyBillingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MonthlyBilling
     */
    select?: MonthlyBillingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MonthlyBillingInclude<ExtArgs> | null
    /**
     * Filter, which MonthlyBilling to fetch.
     */
    where?: MonthlyBillingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MonthlyBillings to fetch.
     */
    orderBy?: MonthlyBillingOrderByWithRelationInput | MonthlyBillingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MonthlyBillings.
     */
    cursor?: MonthlyBillingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MonthlyBillings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MonthlyBillings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MonthlyBillings.
     */
    distinct?: MonthlyBillingScalarFieldEnum | MonthlyBillingScalarFieldEnum[]
  }

  /**
   * MonthlyBilling findMany
   */
  export type MonthlyBillingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MonthlyBilling
     */
    select?: MonthlyBillingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MonthlyBillingInclude<ExtArgs> | null
    /**
     * Filter, which MonthlyBillings to fetch.
     */
    where?: MonthlyBillingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MonthlyBillings to fetch.
     */
    orderBy?: MonthlyBillingOrderByWithRelationInput | MonthlyBillingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MonthlyBillings.
     */
    cursor?: MonthlyBillingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MonthlyBillings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MonthlyBillings.
     */
    skip?: number
    distinct?: MonthlyBillingScalarFieldEnum | MonthlyBillingScalarFieldEnum[]
  }

  /**
   * MonthlyBilling create
   */
  export type MonthlyBillingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MonthlyBilling
     */
    select?: MonthlyBillingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MonthlyBillingInclude<ExtArgs> | null
    /**
     * The data needed to create a MonthlyBilling.
     */
    data: XOR<MonthlyBillingCreateInput, MonthlyBillingUncheckedCreateInput>
  }

  /**
   * MonthlyBilling createMany
   */
  export type MonthlyBillingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MonthlyBillings.
     */
    data: MonthlyBillingCreateManyInput | MonthlyBillingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MonthlyBilling createManyAndReturn
   */
  export type MonthlyBillingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MonthlyBilling
     */
    select?: MonthlyBillingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many MonthlyBillings.
     */
    data: MonthlyBillingCreateManyInput | MonthlyBillingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MonthlyBillingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MonthlyBilling update
   */
  export type MonthlyBillingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MonthlyBilling
     */
    select?: MonthlyBillingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MonthlyBillingInclude<ExtArgs> | null
    /**
     * The data needed to update a MonthlyBilling.
     */
    data: XOR<MonthlyBillingUpdateInput, MonthlyBillingUncheckedUpdateInput>
    /**
     * Choose, which MonthlyBilling to update.
     */
    where: MonthlyBillingWhereUniqueInput
  }

  /**
   * MonthlyBilling updateMany
   */
  export type MonthlyBillingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MonthlyBillings.
     */
    data: XOR<MonthlyBillingUpdateManyMutationInput, MonthlyBillingUncheckedUpdateManyInput>
    /**
     * Filter which MonthlyBillings to update
     */
    where?: MonthlyBillingWhereInput
  }

  /**
   * MonthlyBilling upsert
   */
  export type MonthlyBillingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MonthlyBilling
     */
    select?: MonthlyBillingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MonthlyBillingInclude<ExtArgs> | null
    /**
     * The filter to search for the MonthlyBilling to update in case it exists.
     */
    where: MonthlyBillingWhereUniqueInput
    /**
     * In case the MonthlyBilling found by the `where` argument doesn't exist, create a new MonthlyBilling with this data.
     */
    create: XOR<MonthlyBillingCreateInput, MonthlyBillingUncheckedCreateInput>
    /**
     * In case the MonthlyBilling was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MonthlyBillingUpdateInput, MonthlyBillingUncheckedUpdateInput>
  }

  /**
   * MonthlyBilling delete
   */
  export type MonthlyBillingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MonthlyBilling
     */
    select?: MonthlyBillingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MonthlyBillingInclude<ExtArgs> | null
    /**
     * Filter which MonthlyBilling to delete.
     */
    where: MonthlyBillingWhereUniqueInput
  }

  /**
   * MonthlyBilling deleteMany
   */
  export type MonthlyBillingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MonthlyBillings to delete
     */
    where?: MonthlyBillingWhereInput
  }

  /**
   * MonthlyBilling without action
   */
  export type MonthlyBillingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MonthlyBilling
     */
    select?: MonthlyBillingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MonthlyBillingInclude<ExtArgs> | null
  }


  /**
   * Model Incentive
   */

  export type AggregateIncentive = {
    _count: IncentiveCountAggregateOutputType | null
    _avg: IncentiveAvgAggregateOutputType | null
    _sum: IncentiveSumAggregateOutputType | null
    _min: IncentiveMinAggregateOutputType | null
    _max: IncentiveMaxAggregateOutputType | null
  }

  export type IncentiveAvgAggregateOutputType = {
    revenueTotal: Decimal | null
    amountUsd: Decimal | null
    amountInr: Decimal | null
  }

  export type IncentiveSumAggregateOutputType = {
    revenueTotal: Decimal | null
    amountUsd: Decimal | null
    amountInr: Decimal | null
  }

  export type IncentiveMinAggregateOutputType = {
    id: string | null
    employeeId: string | null
    periodStart: Date | null
    periodEnd: Date | null
    revenueTotal: Decimal | null
    slabName: string | null
    amountUsd: Decimal | null
    amountInr: Decimal | null
    createdAt: Date | null
  }

  export type IncentiveMaxAggregateOutputType = {
    id: string | null
    employeeId: string | null
    periodStart: Date | null
    periodEnd: Date | null
    revenueTotal: Decimal | null
    slabName: string | null
    amountUsd: Decimal | null
    amountInr: Decimal | null
    createdAt: Date | null
  }

  export type IncentiveCountAggregateOutputType = {
    id: number
    employeeId: number
    periodStart: number
    periodEnd: number
    revenueTotal: number
    slabName: number
    amountUsd: number
    amountInr: number
    createdAt: number
    _all: number
  }


  export type IncentiveAvgAggregateInputType = {
    revenueTotal?: true
    amountUsd?: true
    amountInr?: true
  }

  export type IncentiveSumAggregateInputType = {
    revenueTotal?: true
    amountUsd?: true
    amountInr?: true
  }

  export type IncentiveMinAggregateInputType = {
    id?: true
    employeeId?: true
    periodStart?: true
    periodEnd?: true
    revenueTotal?: true
    slabName?: true
    amountUsd?: true
    amountInr?: true
    createdAt?: true
  }

  export type IncentiveMaxAggregateInputType = {
    id?: true
    employeeId?: true
    periodStart?: true
    periodEnd?: true
    revenueTotal?: true
    slabName?: true
    amountUsd?: true
    amountInr?: true
    createdAt?: true
  }

  export type IncentiveCountAggregateInputType = {
    id?: true
    employeeId?: true
    periodStart?: true
    periodEnd?: true
    revenueTotal?: true
    slabName?: true
    amountUsd?: true
    amountInr?: true
    createdAt?: true
    _all?: true
  }

  export type IncentiveAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Incentive to aggregate.
     */
    where?: IncentiveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Incentives to fetch.
     */
    orderBy?: IncentiveOrderByWithRelationInput | IncentiveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: IncentiveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Incentives from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Incentives.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Incentives
    **/
    _count?: true | IncentiveCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: IncentiveAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: IncentiveSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: IncentiveMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: IncentiveMaxAggregateInputType
  }

  export type GetIncentiveAggregateType<T extends IncentiveAggregateArgs> = {
        [P in keyof T & keyof AggregateIncentive]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIncentive[P]>
      : GetScalarType<T[P], AggregateIncentive[P]>
  }




  export type IncentiveGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IncentiveWhereInput
    orderBy?: IncentiveOrderByWithAggregationInput | IncentiveOrderByWithAggregationInput[]
    by: IncentiveScalarFieldEnum[] | IncentiveScalarFieldEnum
    having?: IncentiveScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IncentiveCountAggregateInputType | true
    _avg?: IncentiveAvgAggregateInputType
    _sum?: IncentiveSumAggregateInputType
    _min?: IncentiveMinAggregateInputType
    _max?: IncentiveMaxAggregateInputType
  }

  export type IncentiveGroupByOutputType = {
    id: string
    employeeId: string
    periodStart: Date
    periodEnd: Date
    revenueTotal: Decimal
    slabName: string
    amountUsd: Decimal
    amountInr: Decimal
    createdAt: Date
    _count: IncentiveCountAggregateOutputType | null
    _avg: IncentiveAvgAggregateOutputType | null
    _sum: IncentiveSumAggregateOutputType | null
    _min: IncentiveMinAggregateOutputType | null
    _max: IncentiveMaxAggregateOutputType | null
  }

  type GetIncentiveGroupByPayload<T extends IncentiveGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<IncentiveGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof IncentiveGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IncentiveGroupByOutputType[P]>
            : GetScalarType<T[P], IncentiveGroupByOutputType[P]>
        }
      >
    >


  export type IncentiveSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    periodStart?: boolean
    periodEnd?: boolean
    revenueTotal?: boolean
    slabName?: boolean
    amountUsd?: boolean
    amountInr?: boolean
    createdAt?: boolean
    employee?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["incentive"]>

  export type IncentiveSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    periodStart?: boolean
    periodEnd?: boolean
    revenueTotal?: boolean
    slabName?: boolean
    amountUsd?: boolean
    amountInr?: boolean
    createdAt?: boolean
    employee?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["incentive"]>

  export type IncentiveSelectScalar = {
    id?: boolean
    employeeId?: boolean
    periodStart?: boolean
    periodEnd?: boolean
    revenueTotal?: boolean
    slabName?: boolean
    amountUsd?: boolean
    amountInr?: boolean
    createdAt?: boolean
  }

  export type IncentiveInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type IncentiveIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $IncentivePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Incentive"
    objects: {
      employee: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      employeeId: string
      periodStart: Date
      periodEnd: Date
      revenueTotal: Prisma.Decimal
      slabName: string
      amountUsd: Prisma.Decimal
      amountInr: Prisma.Decimal
      createdAt: Date
    }, ExtArgs["result"]["incentive"]>
    composites: {}
  }

  type IncentiveGetPayload<S extends boolean | null | undefined | IncentiveDefaultArgs> = $Result.GetResult<Prisma.$IncentivePayload, S>

  type IncentiveCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<IncentiveFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: IncentiveCountAggregateInputType | true
    }

  export interface IncentiveDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Incentive'], meta: { name: 'Incentive' } }
    /**
     * Find zero or one Incentive that matches the filter.
     * @param {IncentiveFindUniqueArgs} args - Arguments to find a Incentive
     * @example
     * // Get one Incentive
     * const incentive = await prisma.incentive.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends IncentiveFindUniqueArgs>(args: SelectSubset<T, IncentiveFindUniqueArgs<ExtArgs>>): Prisma__IncentiveClient<$Result.GetResult<Prisma.$IncentivePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Incentive that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {IncentiveFindUniqueOrThrowArgs} args - Arguments to find a Incentive
     * @example
     * // Get one Incentive
     * const incentive = await prisma.incentive.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends IncentiveFindUniqueOrThrowArgs>(args: SelectSubset<T, IncentiveFindUniqueOrThrowArgs<ExtArgs>>): Prisma__IncentiveClient<$Result.GetResult<Prisma.$IncentivePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Incentive that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncentiveFindFirstArgs} args - Arguments to find a Incentive
     * @example
     * // Get one Incentive
     * const incentive = await prisma.incentive.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends IncentiveFindFirstArgs>(args?: SelectSubset<T, IncentiveFindFirstArgs<ExtArgs>>): Prisma__IncentiveClient<$Result.GetResult<Prisma.$IncentivePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Incentive that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncentiveFindFirstOrThrowArgs} args - Arguments to find a Incentive
     * @example
     * // Get one Incentive
     * const incentive = await prisma.incentive.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends IncentiveFindFirstOrThrowArgs>(args?: SelectSubset<T, IncentiveFindFirstOrThrowArgs<ExtArgs>>): Prisma__IncentiveClient<$Result.GetResult<Prisma.$IncentivePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Incentives that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncentiveFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Incentives
     * const incentives = await prisma.incentive.findMany()
     * 
     * // Get first 10 Incentives
     * const incentives = await prisma.incentive.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const incentiveWithIdOnly = await prisma.incentive.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends IncentiveFindManyArgs>(args?: SelectSubset<T, IncentiveFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IncentivePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Incentive.
     * @param {IncentiveCreateArgs} args - Arguments to create a Incentive.
     * @example
     * // Create one Incentive
     * const Incentive = await prisma.incentive.create({
     *   data: {
     *     // ... data to create a Incentive
     *   }
     * })
     * 
     */
    create<T extends IncentiveCreateArgs>(args: SelectSubset<T, IncentiveCreateArgs<ExtArgs>>): Prisma__IncentiveClient<$Result.GetResult<Prisma.$IncentivePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Incentives.
     * @param {IncentiveCreateManyArgs} args - Arguments to create many Incentives.
     * @example
     * // Create many Incentives
     * const incentive = await prisma.incentive.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends IncentiveCreateManyArgs>(args?: SelectSubset<T, IncentiveCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Incentives and returns the data saved in the database.
     * @param {IncentiveCreateManyAndReturnArgs} args - Arguments to create many Incentives.
     * @example
     * // Create many Incentives
     * const incentive = await prisma.incentive.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Incentives and only return the `id`
     * const incentiveWithIdOnly = await prisma.incentive.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends IncentiveCreateManyAndReturnArgs>(args?: SelectSubset<T, IncentiveCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IncentivePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Incentive.
     * @param {IncentiveDeleteArgs} args - Arguments to delete one Incentive.
     * @example
     * // Delete one Incentive
     * const Incentive = await prisma.incentive.delete({
     *   where: {
     *     // ... filter to delete one Incentive
     *   }
     * })
     * 
     */
    delete<T extends IncentiveDeleteArgs>(args: SelectSubset<T, IncentiveDeleteArgs<ExtArgs>>): Prisma__IncentiveClient<$Result.GetResult<Prisma.$IncentivePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Incentive.
     * @param {IncentiveUpdateArgs} args - Arguments to update one Incentive.
     * @example
     * // Update one Incentive
     * const incentive = await prisma.incentive.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends IncentiveUpdateArgs>(args: SelectSubset<T, IncentiveUpdateArgs<ExtArgs>>): Prisma__IncentiveClient<$Result.GetResult<Prisma.$IncentivePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Incentives.
     * @param {IncentiveDeleteManyArgs} args - Arguments to filter Incentives to delete.
     * @example
     * // Delete a few Incentives
     * const { count } = await prisma.incentive.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends IncentiveDeleteManyArgs>(args?: SelectSubset<T, IncentiveDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Incentives.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncentiveUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Incentives
     * const incentive = await prisma.incentive.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends IncentiveUpdateManyArgs>(args: SelectSubset<T, IncentiveUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Incentive.
     * @param {IncentiveUpsertArgs} args - Arguments to update or create a Incentive.
     * @example
     * // Update or create a Incentive
     * const incentive = await prisma.incentive.upsert({
     *   create: {
     *     // ... data to create a Incentive
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Incentive we want to update
     *   }
     * })
     */
    upsert<T extends IncentiveUpsertArgs>(args: SelectSubset<T, IncentiveUpsertArgs<ExtArgs>>): Prisma__IncentiveClient<$Result.GetResult<Prisma.$IncentivePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Incentives.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncentiveCountArgs} args - Arguments to filter Incentives to count.
     * @example
     * // Count the number of Incentives
     * const count = await prisma.incentive.count({
     *   where: {
     *     // ... the filter for the Incentives we want to count
     *   }
     * })
    **/
    count<T extends IncentiveCountArgs>(
      args?: Subset<T, IncentiveCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IncentiveCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Incentive.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncentiveAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IncentiveAggregateArgs>(args: Subset<T, IncentiveAggregateArgs>): Prisma.PrismaPromise<GetIncentiveAggregateType<T>>

    /**
     * Group by Incentive.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncentiveGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends IncentiveGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: IncentiveGroupByArgs['orderBy'] }
        : { orderBy?: IncentiveGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, IncentiveGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIncentiveGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Incentive model
   */
  readonly fields: IncentiveFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Incentive.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__IncentiveClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    employee<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Incentive model
   */ 
  interface IncentiveFieldRefs {
    readonly id: FieldRef<"Incentive", 'String'>
    readonly employeeId: FieldRef<"Incentive", 'String'>
    readonly periodStart: FieldRef<"Incentive", 'DateTime'>
    readonly periodEnd: FieldRef<"Incentive", 'DateTime'>
    readonly revenueTotal: FieldRef<"Incentive", 'Decimal'>
    readonly slabName: FieldRef<"Incentive", 'String'>
    readonly amountUsd: FieldRef<"Incentive", 'Decimal'>
    readonly amountInr: FieldRef<"Incentive", 'Decimal'>
    readonly createdAt: FieldRef<"Incentive", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Incentive findUnique
   */
  export type IncentiveFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Incentive
     */
    select?: IncentiveSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncentiveInclude<ExtArgs> | null
    /**
     * Filter, which Incentive to fetch.
     */
    where: IncentiveWhereUniqueInput
  }

  /**
   * Incentive findUniqueOrThrow
   */
  export type IncentiveFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Incentive
     */
    select?: IncentiveSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncentiveInclude<ExtArgs> | null
    /**
     * Filter, which Incentive to fetch.
     */
    where: IncentiveWhereUniqueInput
  }

  /**
   * Incentive findFirst
   */
  export type IncentiveFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Incentive
     */
    select?: IncentiveSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncentiveInclude<ExtArgs> | null
    /**
     * Filter, which Incentive to fetch.
     */
    where?: IncentiveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Incentives to fetch.
     */
    orderBy?: IncentiveOrderByWithRelationInput | IncentiveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Incentives.
     */
    cursor?: IncentiveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Incentives from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Incentives.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Incentives.
     */
    distinct?: IncentiveScalarFieldEnum | IncentiveScalarFieldEnum[]
  }

  /**
   * Incentive findFirstOrThrow
   */
  export type IncentiveFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Incentive
     */
    select?: IncentiveSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncentiveInclude<ExtArgs> | null
    /**
     * Filter, which Incentive to fetch.
     */
    where?: IncentiveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Incentives to fetch.
     */
    orderBy?: IncentiveOrderByWithRelationInput | IncentiveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Incentives.
     */
    cursor?: IncentiveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Incentives from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Incentives.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Incentives.
     */
    distinct?: IncentiveScalarFieldEnum | IncentiveScalarFieldEnum[]
  }

  /**
   * Incentive findMany
   */
  export type IncentiveFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Incentive
     */
    select?: IncentiveSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncentiveInclude<ExtArgs> | null
    /**
     * Filter, which Incentives to fetch.
     */
    where?: IncentiveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Incentives to fetch.
     */
    orderBy?: IncentiveOrderByWithRelationInput | IncentiveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Incentives.
     */
    cursor?: IncentiveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Incentives from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Incentives.
     */
    skip?: number
    distinct?: IncentiveScalarFieldEnum | IncentiveScalarFieldEnum[]
  }

  /**
   * Incentive create
   */
  export type IncentiveCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Incentive
     */
    select?: IncentiveSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncentiveInclude<ExtArgs> | null
    /**
     * The data needed to create a Incentive.
     */
    data: XOR<IncentiveCreateInput, IncentiveUncheckedCreateInput>
  }

  /**
   * Incentive createMany
   */
  export type IncentiveCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Incentives.
     */
    data: IncentiveCreateManyInput | IncentiveCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Incentive createManyAndReturn
   */
  export type IncentiveCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Incentive
     */
    select?: IncentiveSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Incentives.
     */
    data: IncentiveCreateManyInput | IncentiveCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncentiveIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Incentive update
   */
  export type IncentiveUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Incentive
     */
    select?: IncentiveSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncentiveInclude<ExtArgs> | null
    /**
     * The data needed to update a Incentive.
     */
    data: XOR<IncentiveUpdateInput, IncentiveUncheckedUpdateInput>
    /**
     * Choose, which Incentive to update.
     */
    where: IncentiveWhereUniqueInput
  }

  /**
   * Incentive updateMany
   */
  export type IncentiveUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Incentives.
     */
    data: XOR<IncentiveUpdateManyMutationInput, IncentiveUncheckedUpdateManyInput>
    /**
     * Filter which Incentives to update
     */
    where?: IncentiveWhereInput
  }

  /**
   * Incentive upsert
   */
  export type IncentiveUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Incentive
     */
    select?: IncentiveSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncentiveInclude<ExtArgs> | null
    /**
     * The filter to search for the Incentive to update in case it exists.
     */
    where: IncentiveWhereUniqueInput
    /**
     * In case the Incentive found by the `where` argument doesn't exist, create a new Incentive with this data.
     */
    create: XOR<IncentiveCreateInput, IncentiveUncheckedCreateInput>
    /**
     * In case the Incentive was found with the provided `where` argument, update it with this data.
     */
    update: XOR<IncentiveUpdateInput, IncentiveUncheckedUpdateInput>
  }

  /**
   * Incentive delete
   */
  export type IncentiveDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Incentive
     */
    select?: IncentiveSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncentiveInclude<ExtArgs> | null
    /**
     * Filter which Incentive to delete.
     */
    where: IncentiveWhereUniqueInput
  }

  /**
   * Incentive deleteMany
   */
  export type IncentiveDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Incentives to delete
     */
    where?: IncentiveWhereInput
  }

  /**
   * Incentive without action
   */
  export type IncentiveDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Incentive
     */
    select?: IncentiveSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncentiveInclude<ExtArgs> | null
  }


  /**
   * Model RefreshToken
   */

  export type AggregateRefreshToken = {
    _count: RefreshTokenCountAggregateOutputType | null
    _min: RefreshTokenMinAggregateOutputType | null
    _max: RefreshTokenMaxAggregateOutputType | null
  }

  export type RefreshTokenMinAggregateOutputType = {
    id: string | null
    token: string | null
    userId: string | null
    isRevoked: boolean | null
    expiresAt: Date | null
    createdAt: Date | null
  }

  export type RefreshTokenMaxAggregateOutputType = {
    id: string | null
    token: string | null
    userId: string | null
    isRevoked: boolean | null
    expiresAt: Date | null
    createdAt: Date | null
  }

  export type RefreshTokenCountAggregateOutputType = {
    id: number
    token: number
    userId: number
    isRevoked: number
    expiresAt: number
    createdAt: number
    _all: number
  }


  export type RefreshTokenMinAggregateInputType = {
    id?: true
    token?: true
    userId?: true
    isRevoked?: true
    expiresAt?: true
    createdAt?: true
  }

  export type RefreshTokenMaxAggregateInputType = {
    id?: true
    token?: true
    userId?: true
    isRevoked?: true
    expiresAt?: true
    createdAt?: true
  }

  export type RefreshTokenCountAggregateInputType = {
    id?: true
    token?: true
    userId?: true
    isRevoked?: true
    expiresAt?: true
    createdAt?: true
    _all?: true
  }

  export type RefreshTokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RefreshToken to aggregate.
     */
    where?: RefreshTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefreshTokens to fetch.
     */
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RefreshTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefreshTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefreshTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RefreshTokens
    **/
    _count?: true | RefreshTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RefreshTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RefreshTokenMaxAggregateInputType
  }

  export type GetRefreshTokenAggregateType<T extends RefreshTokenAggregateArgs> = {
        [P in keyof T & keyof AggregateRefreshToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRefreshToken[P]>
      : GetScalarType<T[P], AggregateRefreshToken[P]>
  }




  export type RefreshTokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RefreshTokenWhereInput
    orderBy?: RefreshTokenOrderByWithAggregationInput | RefreshTokenOrderByWithAggregationInput[]
    by: RefreshTokenScalarFieldEnum[] | RefreshTokenScalarFieldEnum
    having?: RefreshTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RefreshTokenCountAggregateInputType | true
    _min?: RefreshTokenMinAggregateInputType
    _max?: RefreshTokenMaxAggregateInputType
  }

  export type RefreshTokenGroupByOutputType = {
    id: string
    token: string
    userId: string
    isRevoked: boolean
    expiresAt: Date
    createdAt: Date
    _count: RefreshTokenCountAggregateOutputType | null
    _min: RefreshTokenMinAggregateOutputType | null
    _max: RefreshTokenMaxAggregateOutputType | null
  }

  type GetRefreshTokenGroupByPayload<T extends RefreshTokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RefreshTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RefreshTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RefreshTokenGroupByOutputType[P]>
            : GetScalarType<T[P], RefreshTokenGroupByOutputType[P]>
        }
      >
    >


  export type RefreshTokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    token?: boolean
    userId?: boolean
    isRevoked?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["refreshToken"]>

  export type RefreshTokenSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    token?: boolean
    userId?: boolean
    isRevoked?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["refreshToken"]>

  export type RefreshTokenSelectScalar = {
    id?: boolean
    token?: boolean
    userId?: boolean
    isRevoked?: boolean
    expiresAt?: boolean
    createdAt?: boolean
  }

  export type RefreshTokenInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type RefreshTokenIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $RefreshTokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RefreshToken"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      token: string
      userId: string
      isRevoked: boolean
      expiresAt: Date
      createdAt: Date
    }, ExtArgs["result"]["refreshToken"]>
    composites: {}
  }

  type RefreshTokenGetPayload<S extends boolean | null | undefined | RefreshTokenDefaultArgs> = $Result.GetResult<Prisma.$RefreshTokenPayload, S>

  type RefreshTokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RefreshTokenFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RefreshTokenCountAggregateInputType | true
    }

  export interface RefreshTokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RefreshToken'], meta: { name: 'RefreshToken' } }
    /**
     * Find zero or one RefreshToken that matches the filter.
     * @param {RefreshTokenFindUniqueArgs} args - Arguments to find a RefreshToken
     * @example
     * // Get one RefreshToken
     * const refreshToken = await prisma.refreshToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RefreshTokenFindUniqueArgs>(args: SelectSubset<T, RefreshTokenFindUniqueArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one RefreshToken that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RefreshTokenFindUniqueOrThrowArgs} args - Arguments to find a RefreshToken
     * @example
     * // Get one RefreshToken
     * const refreshToken = await prisma.refreshToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RefreshTokenFindUniqueOrThrowArgs>(args: SelectSubset<T, RefreshTokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first RefreshToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenFindFirstArgs} args - Arguments to find a RefreshToken
     * @example
     * // Get one RefreshToken
     * const refreshToken = await prisma.refreshToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RefreshTokenFindFirstArgs>(args?: SelectSubset<T, RefreshTokenFindFirstArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first RefreshToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenFindFirstOrThrowArgs} args - Arguments to find a RefreshToken
     * @example
     * // Get one RefreshToken
     * const refreshToken = await prisma.refreshToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RefreshTokenFindFirstOrThrowArgs>(args?: SelectSubset<T, RefreshTokenFindFirstOrThrowArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more RefreshTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RefreshTokens
     * const refreshTokens = await prisma.refreshToken.findMany()
     * 
     * // Get first 10 RefreshTokens
     * const refreshTokens = await prisma.refreshToken.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const refreshTokenWithIdOnly = await prisma.refreshToken.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RefreshTokenFindManyArgs>(args?: SelectSubset<T, RefreshTokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a RefreshToken.
     * @param {RefreshTokenCreateArgs} args - Arguments to create a RefreshToken.
     * @example
     * // Create one RefreshToken
     * const RefreshToken = await prisma.refreshToken.create({
     *   data: {
     *     // ... data to create a RefreshToken
     *   }
     * })
     * 
     */
    create<T extends RefreshTokenCreateArgs>(args: SelectSubset<T, RefreshTokenCreateArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many RefreshTokens.
     * @param {RefreshTokenCreateManyArgs} args - Arguments to create many RefreshTokens.
     * @example
     * // Create many RefreshTokens
     * const refreshToken = await prisma.refreshToken.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RefreshTokenCreateManyArgs>(args?: SelectSubset<T, RefreshTokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RefreshTokens and returns the data saved in the database.
     * @param {RefreshTokenCreateManyAndReturnArgs} args - Arguments to create many RefreshTokens.
     * @example
     * // Create many RefreshTokens
     * const refreshToken = await prisma.refreshToken.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RefreshTokens and only return the `id`
     * const refreshTokenWithIdOnly = await prisma.refreshToken.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RefreshTokenCreateManyAndReturnArgs>(args?: SelectSubset<T, RefreshTokenCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a RefreshToken.
     * @param {RefreshTokenDeleteArgs} args - Arguments to delete one RefreshToken.
     * @example
     * // Delete one RefreshToken
     * const RefreshToken = await prisma.refreshToken.delete({
     *   where: {
     *     // ... filter to delete one RefreshToken
     *   }
     * })
     * 
     */
    delete<T extends RefreshTokenDeleteArgs>(args: SelectSubset<T, RefreshTokenDeleteArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one RefreshToken.
     * @param {RefreshTokenUpdateArgs} args - Arguments to update one RefreshToken.
     * @example
     * // Update one RefreshToken
     * const refreshToken = await prisma.refreshToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RefreshTokenUpdateArgs>(args: SelectSubset<T, RefreshTokenUpdateArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more RefreshTokens.
     * @param {RefreshTokenDeleteManyArgs} args - Arguments to filter RefreshTokens to delete.
     * @example
     * // Delete a few RefreshTokens
     * const { count } = await prisma.refreshToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RefreshTokenDeleteManyArgs>(args?: SelectSubset<T, RefreshTokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RefreshTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RefreshTokens
     * const refreshToken = await prisma.refreshToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RefreshTokenUpdateManyArgs>(args: SelectSubset<T, RefreshTokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RefreshToken.
     * @param {RefreshTokenUpsertArgs} args - Arguments to update or create a RefreshToken.
     * @example
     * // Update or create a RefreshToken
     * const refreshToken = await prisma.refreshToken.upsert({
     *   create: {
     *     // ... data to create a RefreshToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RefreshToken we want to update
     *   }
     * })
     */
    upsert<T extends RefreshTokenUpsertArgs>(args: SelectSubset<T, RefreshTokenUpsertArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of RefreshTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenCountArgs} args - Arguments to filter RefreshTokens to count.
     * @example
     * // Count the number of RefreshTokens
     * const count = await prisma.refreshToken.count({
     *   where: {
     *     // ... the filter for the RefreshTokens we want to count
     *   }
     * })
    **/
    count<T extends RefreshTokenCountArgs>(
      args?: Subset<T, RefreshTokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RefreshTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RefreshToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RefreshTokenAggregateArgs>(args: Subset<T, RefreshTokenAggregateArgs>): Prisma.PrismaPromise<GetRefreshTokenAggregateType<T>>

    /**
     * Group by RefreshToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RefreshTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RefreshTokenGroupByArgs['orderBy'] }
        : { orderBy?: RefreshTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RefreshTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRefreshTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RefreshToken model
   */
  readonly fields: RefreshTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RefreshToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RefreshTokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RefreshToken model
   */ 
  interface RefreshTokenFieldRefs {
    readonly id: FieldRef<"RefreshToken", 'String'>
    readonly token: FieldRef<"RefreshToken", 'String'>
    readonly userId: FieldRef<"RefreshToken", 'String'>
    readonly isRevoked: FieldRef<"RefreshToken", 'Boolean'>
    readonly expiresAt: FieldRef<"RefreshToken", 'DateTime'>
    readonly createdAt: FieldRef<"RefreshToken", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RefreshToken findUnique
   */
  export type RefreshTokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshToken to fetch.
     */
    where: RefreshTokenWhereUniqueInput
  }

  /**
   * RefreshToken findUniqueOrThrow
   */
  export type RefreshTokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshToken to fetch.
     */
    where: RefreshTokenWhereUniqueInput
  }

  /**
   * RefreshToken findFirst
   */
  export type RefreshTokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshToken to fetch.
     */
    where?: RefreshTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefreshTokens to fetch.
     */
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RefreshTokens.
     */
    cursor?: RefreshTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefreshTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefreshTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RefreshTokens.
     */
    distinct?: RefreshTokenScalarFieldEnum | RefreshTokenScalarFieldEnum[]
  }

  /**
   * RefreshToken findFirstOrThrow
   */
  export type RefreshTokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshToken to fetch.
     */
    where?: RefreshTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefreshTokens to fetch.
     */
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RefreshTokens.
     */
    cursor?: RefreshTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefreshTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefreshTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RefreshTokens.
     */
    distinct?: RefreshTokenScalarFieldEnum | RefreshTokenScalarFieldEnum[]
  }

  /**
   * RefreshToken findMany
   */
  export type RefreshTokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshTokens to fetch.
     */
    where?: RefreshTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefreshTokens to fetch.
     */
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RefreshTokens.
     */
    cursor?: RefreshTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefreshTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefreshTokens.
     */
    skip?: number
    distinct?: RefreshTokenScalarFieldEnum | RefreshTokenScalarFieldEnum[]
  }

  /**
   * RefreshToken create
   */
  export type RefreshTokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * The data needed to create a RefreshToken.
     */
    data: XOR<RefreshTokenCreateInput, RefreshTokenUncheckedCreateInput>
  }

  /**
   * RefreshToken createMany
   */
  export type RefreshTokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RefreshTokens.
     */
    data: RefreshTokenCreateManyInput | RefreshTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RefreshToken createManyAndReturn
   */
  export type RefreshTokenCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many RefreshTokens.
     */
    data: RefreshTokenCreateManyInput | RefreshTokenCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RefreshToken update
   */
  export type RefreshTokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * The data needed to update a RefreshToken.
     */
    data: XOR<RefreshTokenUpdateInput, RefreshTokenUncheckedUpdateInput>
    /**
     * Choose, which RefreshToken to update.
     */
    where: RefreshTokenWhereUniqueInput
  }

  /**
   * RefreshToken updateMany
   */
  export type RefreshTokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RefreshTokens.
     */
    data: XOR<RefreshTokenUpdateManyMutationInput, RefreshTokenUncheckedUpdateManyInput>
    /**
     * Filter which RefreshTokens to update
     */
    where?: RefreshTokenWhereInput
  }

  /**
   * RefreshToken upsert
   */
  export type RefreshTokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * The filter to search for the RefreshToken to update in case it exists.
     */
    where: RefreshTokenWhereUniqueInput
    /**
     * In case the RefreshToken found by the `where` argument doesn't exist, create a new RefreshToken with this data.
     */
    create: XOR<RefreshTokenCreateInput, RefreshTokenUncheckedCreateInput>
    /**
     * In case the RefreshToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RefreshTokenUpdateInput, RefreshTokenUncheckedUpdateInput>
  }

  /**
   * RefreshToken delete
   */
  export type RefreshTokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter which RefreshToken to delete.
     */
    where: RefreshTokenWhereUniqueInput
  }

  /**
   * RefreshToken deleteMany
   */
  export type RefreshTokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RefreshTokens to delete
     */
    where?: RefreshTokenWhereInput
  }

  /**
   * RefreshToken without action
   */
  export type RefreshTokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
  }


  /**
   * Model Campaign
   */

  export type AggregateCampaign = {
    _count: CampaignCountAggregateOutputType | null
    _avg: CampaignAvgAggregateOutputType | null
    _sum: CampaignSumAggregateOutputType | null
    _min: CampaignMinAggregateOutputType | null
    _max: CampaignMaxAggregateOutputType | null
  }

  export type CampaignAvgAggregateOutputType = {
    targetAmount: Decimal | null
  }

  export type CampaignSumAggregateOutputType = {
    targetAmount: Decimal | null
  }

  export type CampaignMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    objective: string | null
    status: $Enums.CampaignStatus | null
    targetAmount: Decimal | null
    startDate: Date | null
    endDate: Date | null
    createdById: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CampaignMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    objective: string | null
    status: $Enums.CampaignStatus | null
    targetAmount: Decimal | null
    startDate: Date | null
    endDate: Date | null
    createdById: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CampaignCountAggregateOutputType = {
    id: number
    name: number
    description: number
    objective: number
    status: number
    targetAmount: number
    startDate: number
    endDate: number
    createdById: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CampaignAvgAggregateInputType = {
    targetAmount?: true
  }

  export type CampaignSumAggregateInputType = {
    targetAmount?: true
  }

  export type CampaignMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    objective?: true
    status?: true
    targetAmount?: true
    startDate?: true
    endDate?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CampaignMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    objective?: true
    status?: true
    targetAmount?: true
    startDate?: true
    endDate?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CampaignCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    objective?: true
    status?: true
    targetAmount?: true
    startDate?: true
    endDate?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CampaignAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Campaign to aggregate.
     */
    where?: CampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Campaigns to fetch.
     */
    orderBy?: CampaignOrderByWithRelationInput | CampaignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Campaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Campaigns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Campaigns
    **/
    _count?: true | CampaignCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CampaignAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CampaignSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CampaignMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CampaignMaxAggregateInputType
  }

  export type GetCampaignAggregateType<T extends CampaignAggregateArgs> = {
        [P in keyof T & keyof AggregateCampaign]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCampaign[P]>
      : GetScalarType<T[P], AggregateCampaign[P]>
  }




  export type CampaignGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CampaignWhereInput
    orderBy?: CampaignOrderByWithAggregationInput | CampaignOrderByWithAggregationInput[]
    by: CampaignScalarFieldEnum[] | CampaignScalarFieldEnum
    having?: CampaignScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CampaignCountAggregateInputType | true
    _avg?: CampaignAvgAggregateInputType
    _sum?: CampaignSumAggregateInputType
    _min?: CampaignMinAggregateInputType
    _max?: CampaignMaxAggregateInputType
  }

  export type CampaignGroupByOutputType = {
    id: string
    name: string
    description: string | null
    objective: string | null
    status: $Enums.CampaignStatus
    targetAmount: Decimal
    startDate: Date
    endDate: Date
    createdById: string
    createdAt: Date
    updatedAt: Date
    _count: CampaignCountAggregateOutputType | null
    _avg: CampaignAvgAggregateOutputType | null
    _sum: CampaignSumAggregateOutputType | null
    _min: CampaignMinAggregateOutputType | null
    _max: CampaignMaxAggregateOutputType | null
  }

  type GetCampaignGroupByPayload<T extends CampaignGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CampaignGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CampaignGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CampaignGroupByOutputType[P]>
            : GetScalarType<T[P], CampaignGroupByOutputType[P]>
        }
      >
    >


  export type CampaignSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    objective?: boolean
    status?: boolean
    targetAmount?: boolean
    startDate?: boolean
    endDate?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    images?: boolean | Campaign$imagesArgs<ExtArgs>
    teamLeads?: boolean | Campaign$teamLeadsArgs<ExtArgs>
    assignments?: boolean | Campaign$assignmentsArgs<ExtArgs>
    tasks?: boolean | Campaign$tasksArgs<ExtArgs>
    activities?: boolean | Campaign$activitiesArgs<ExtArgs>
    _count?: boolean | CampaignCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["campaign"]>

  export type CampaignSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    objective?: boolean
    status?: boolean
    targetAmount?: boolean
    startDate?: boolean
    endDate?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["campaign"]>

  export type CampaignSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    objective?: boolean
    status?: boolean
    targetAmount?: boolean
    startDate?: boolean
    endDate?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CampaignInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    images?: boolean | Campaign$imagesArgs<ExtArgs>
    teamLeads?: boolean | Campaign$teamLeadsArgs<ExtArgs>
    assignments?: boolean | Campaign$assignmentsArgs<ExtArgs>
    tasks?: boolean | Campaign$tasksArgs<ExtArgs>
    activities?: boolean | Campaign$activitiesArgs<ExtArgs>
    _count?: boolean | CampaignCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CampaignIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $CampaignPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Campaign"
    objects: {
      createdBy: Prisma.$UserPayload<ExtArgs>
      images: Prisma.$CampaignImagePayload<ExtArgs>[]
      teamLeads: Prisma.$CampaignTeamLeadPayload<ExtArgs>[]
      assignments: Prisma.$CampaignAssignmentPayload<ExtArgs>[]
      tasks: Prisma.$CampaignTaskPayload<ExtArgs>[]
      activities: Prisma.$CampaignActivityPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      objective: string | null
      status: $Enums.CampaignStatus
      targetAmount: Prisma.Decimal
      startDate: Date
      endDate: Date
      createdById: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["campaign"]>
    composites: {}
  }

  type CampaignGetPayload<S extends boolean | null | undefined | CampaignDefaultArgs> = $Result.GetResult<Prisma.$CampaignPayload, S>

  type CampaignCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CampaignFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CampaignCountAggregateInputType | true
    }

  export interface CampaignDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Campaign'], meta: { name: 'Campaign' } }
    /**
     * Find zero or one Campaign that matches the filter.
     * @param {CampaignFindUniqueArgs} args - Arguments to find a Campaign
     * @example
     * // Get one Campaign
     * const campaign = await prisma.campaign.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CampaignFindUniqueArgs>(args: SelectSubset<T, CampaignFindUniqueArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Campaign that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CampaignFindUniqueOrThrowArgs} args - Arguments to find a Campaign
     * @example
     * // Get one Campaign
     * const campaign = await prisma.campaign.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CampaignFindUniqueOrThrowArgs>(args: SelectSubset<T, CampaignFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Campaign that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignFindFirstArgs} args - Arguments to find a Campaign
     * @example
     * // Get one Campaign
     * const campaign = await prisma.campaign.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CampaignFindFirstArgs>(args?: SelectSubset<T, CampaignFindFirstArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Campaign that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignFindFirstOrThrowArgs} args - Arguments to find a Campaign
     * @example
     * // Get one Campaign
     * const campaign = await prisma.campaign.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CampaignFindFirstOrThrowArgs>(args?: SelectSubset<T, CampaignFindFirstOrThrowArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Campaigns that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Campaigns
     * const campaigns = await prisma.campaign.findMany()
     * 
     * // Get first 10 Campaigns
     * const campaigns = await prisma.campaign.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const campaignWithIdOnly = await prisma.campaign.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CampaignFindManyArgs>(args?: SelectSubset<T, CampaignFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Campaign.
     * @param {CampaignCreateArgs} args - Arguments to create a Campaign.
     * @example
     * // Create one Campaign
     * const Campaign = await prisma.campaign.create({
     *   data: {
     *     // ... data to create a Campaign
     *   }
     * })
     * 
     */
    create<T extends CampaignCreateArgs>(args: SelectSubset<T, CampaignCreateArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Campaigns.
     * @param {CampaignCreateManyArgs} args - Arguments to create many Campaigns.
     * @example
     * // Create many Campaigns
     * const campaign = await prisma.campaign.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CampaignCreateManyArgs>(args?: SelectSubset<T, CampaignCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Campaigns and returns the data saved in the database.
     * @param {CampaignCreateManyAndReturnArgs} args - Arguments to create many Campaigns.
     * @example
     * // Create many Campaigns
     * const campaign = await prisma.campaign.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Campaigns and only return the `id`
     * const campaignWithIdOnly = await prisma.campaign.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CampaignCreateManyAndReturnArgs>(args?: SelectSubset<T, CampaignCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Campaign.
     * @param {CampaignDeleteArgs} args - Arguments to delete one Campaign.
     * @example
     * // Delete one Campaign
     * const Campaign = await prisma.campaign.delete({
     *   where: {
     *     // ... filter to delete one Campaign
     *   }
     * })
     * 
     */
    delete<T extends CampaignDeleteArgs>(args: SelectSubset<T, CampaignDeleteArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Campaign.
     * @param {CampaignUpdateArgs} args - Arguments to update one Campaign.
     * @example
     * // Update one Campaign
     * const campaign = await prisma.campaign.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CampaignUpdateArgs>(args: SelectSubset<T, CampaignUpdateArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Campaigns.
     * @param {CampaignDeleteManyArgs} args - Arguments to filter Campaigns to delete.
     * @example
     * // Delete a few Campaigns
     * const { count } = await prisma.campaign.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CampaignDeleteManyArgs>(args?: SelectSubset<T, CampaignDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Campaigns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Campaigns
     * const campaign = await prisma.campaign.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CampaignUpdateManyArgs>(args: SelectSubset<T, CampaignUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Campaign.
     * @param {CampaignUpsertArgs} args - Arguments to update or create a Campaign.
     * @example
     * // Update or create a Campaign
     * const campaign = await prisma.campaign.upsert({
     *   create: {
     *     // ... data to create a Campaign
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Campaign we want to update
     *   }
     * })
     */
    upsert<T extends CampaignUpsertArgs>(args: SelectSubset<T, CampaignUpsertArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Campaigns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignCountArgs} args - Arguments to filter Campaigns to count.
     * @example
     * // Count the number of Campaigns
     * const count = await prisma.campaign.count({
     *   where: {
     *     // ... the filter for the Campaigns we want to count
     *   }
     * })
    **/
    count<T extends CampaignCountArgs>(
      args?: Subset<T, CampaignCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CampaignCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Campaign.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CampaignAggregateArgs>(args: Subset<T, CampaignAggregateArgs>): Prisma.PrismaPromise<GetCampaignAggregateType<T>>

    /**
     * Group by Campaign.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CampaignGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CampaignGroupByArgs['orderBy'] }
        : { orderBy?: CampaignGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CampaignGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCampaignGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Campaign model
   */
  readonly fields: CampaignFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Campaign.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CampaignClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    createdBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    images<T extends Campaign$imagesArgs<ExtArgs> = {}>(args?: Subset<T, Campaign$imagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignImagePayload<ExtArgs>, T, "findMany"> | Null>
    teamLeads<T extends Campaign$teamLeadsArgs<ExtArgs> = {}>(args?: Subset<T, Campaign$teamLeadsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignTeamLeadPayload<ExtArgs>, T, "findMany"> | Null>
    assignments<T extends Campaign$assignmentsArgs<ExtArgs> = {}>(args?: Subset<T, Campaign$assignmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignAssignmentPayload<ExtArgs>, T, "findMany"> | Null>
    tasks<T extends Campaign$tasksArgs<ExtArgs> = {}>(args?: Subset<T, Campaign$tasksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignTaskPayload<ExtArgs>, T, "findMany"> | Null>
    activities<T extends Campaign$activitiesArgs<ExtArgs> = {}>(args?: Subset<T, Campaign$activitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignActivityPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Campaign model
   */ 
  interface CampaignFieldRefs {
    readonly id: FieldRef<"Campaign", 'String'>
    readonly name: FieldRef<"Campaign", 'String'>
    readonly description: FieldRef<"Campaign", 'String'>
    readonly objective: FieldRef<"Campaign", 'String'>
    readonly status: FieldRef<"Campaign", 'CampaignStatus'>
    readonly targetAmount: FieldRef<"Campaign", 'Decimal'>
    readonly startDate: FieldRef<"Campaign", 'DateTime'>
    readonly endDate: FieldRef<"Campaign", 'DateTime'>
    readonly createdById: FieldRef<"Campaign", 'String'>
    readonly createdAt: FieldRef<"Campaign", 'DateTime'>
    readonly updatedAt: FieldRef<"Campaign", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Campaign findUnique
   */
  export type CampaignFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * Filter, which Campaign to fetch.
     */
    where: CampaignWhereUniqueInput
  }

  /**
   * Campaign findUniqueOrThrow
   */
  export type CampaignFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * Filter, which Campaign to fetch.
     */
    where: CampaignWhereUniqueInput
  }

  /**
   * Campaign findFirst
   */
  export type CampaignFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * Filter, which Campaign to fetch.
     */
    where?: CampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Campaigns to fetch.
     */
    orderBy?: CampaignOrderByWithRelationInput | CampaignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Campaigns.
     */
    cursor?: CampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Campaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Campaigns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Campaigns.
     */
    distinct?: CampaignScalarFieldEnum | CampaignScalarFieldEnum[]
  }

  /**
   * Campaign findFirstOrThrow
   */
  export type CampaignFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * Filter, which Campaign to fetch.
     */
    where?: CampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Campaigns to fetch.
     */
    orderBy?: CampaignOrderByWithRelationInput | CampaignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Campaigns.
     */
    cursor?: CampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Campaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Campaigns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Campaigns.
     */
    distinct?: CampaignScalarFieldEnum | CampaignScalarFieldEnum[]
  }

  /**
   * Campaign findMany
   */
  export type CampaignFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * Filter, which Campaigns to fetch.
     */
    where?: CampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Campaigns to fetch.
     */
    orderBy?: CampaignOrderByWithRelationInput | CampaignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Campaigns.
     */
    cursor?: CampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Campaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Campaigns.
     */
    skip?: number
    distinct?: CampaignScalarFieldEnum | CampaignScalarFieldEnum[]
  }

  /**
   * Campaign create
   */
  export type CampaignCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * The data needed to create a Campaign.
     */
    data: XOR<CampaignCreateInput, CampaignUncheckedCreateInput>
  }

  /**
   * Campaign createMany
   */
  export type CampaignCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Campaigns.
     */
    data: CampaignCreateManyInput | CampaignCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Campaign createManyAndReturn
   */
  export type CampaignCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Campaigns.
     */
    data: CampaignCreateManyInput | CampaignCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Campaign update
   */
  export type CampaignUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * The data needed to update a Campaign.
     */
    data: XOR<CampaignUpdateInput, CampaignUncheckedUpdateInput>
    /**
     * Choose, which Campaign to update.
     */
    where: CampaignWhereUniqueInput
  }

  /**
   * Campaign updateMany
   */
  export type CampaignUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Campaigns.
     */
    data: XOR<CampaignUpdateManyMutationInput, CampaignUncheckedUpdateManyInput>
    /**
     * Filter which Campaigns to update
     */
    where?: CampaignWhereInput
  }

  /**
   * Campaign upsert
   */
  export type CampaignUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * The filter to search for the Campaign to update in case it exists.
     */
    where: CampaignWhereUniqueInput
    /**
     * In case the Campaign found by the `where` argument doesn't exist, create a new Campaign with this data.
     */
    create: XOR<CampaignCreateInput, CampaignUncheckedCreateInput>
    /**
     * In case the Campaign was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CampaignUpdateInput, CampaignUncheckedUpdateInput>
  }

  /**
   * Campaign delete
   */
  export type CampaignDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * Filter which Campaign to delete.
     */
    where: CampaignWhereUniqueInput
  }

  /**
   * Campaign deleteMany
   */
  export type CampaignDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Campaigns to delete
     */
    where?: CampaignWhereInput
  }

  /**
   * Campaign.images
   */
  export type Campaign$imagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignImage
     */
    select?: CampaignImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignImageInclude<ExtArgs> | null
    where?: CampaignImageWhereInput
    orderBy?: CampaignImageOrderByWithRelationInput | CampaignImageOrderByWithRelationInput[]
    cursor?: CampaignImageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CampaignImageScalarFieldEnum | CampaignImageScalarFieldEnum[]
  }

  /**
   * Campaign.teamLeads
   */
  export type Campaign$teamLeadsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignTeamLead
     */
    select?: CampaignTeamLeadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignTeamLeadInclude<ExtArgs> | null
    where?: CampaignTeamLeadWhereInput
    orderBy?: CampaignTeamLeadOrderByWithRelationInput | CampaignTeamLeadOrderByWithRelationInput[]
    cursor?: CampaignTeamLeadWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CampaignTeamLeadScalarFieldEnum | CampaignTeamLeadScalarFieldEnum[]
  }

  /**
   * Campaign.assignments
   */
  export type Campaign$assignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignAssignment
     */
    select?: CampaignAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignAssignmentInclude<ExtArgs> | null
    where?: CampaignAssignmentWhereInput
    orderBy?: CampaignAssignmentOrderByWithRelationInput | CampaignAssignmentOrderByWithRelationInput[]
    cursor?: CampaignAssignmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CampaignAssignmentScalarFieldEnum | CampaignAssignmentScalarFieldEnum[]
  }

  /**
   * Campaign.tasks
   */
  export type Campaign$tasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignTask
     */
    select?: CampaignTaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignTaskInclude<ExtArgs> | null
    where?: CampaignTaskWhereInput
    orderBy?: CampaignTaskOrderByWithRelationInput | CampaignTaskOrderByWithRelationInput[]
    cursor?: CampaignTaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CampaignTaskScalarFieldEnum | CampaignTaskScalarFieldEnum[]
  }

  /**
   * Campaign.activities
   */
  export type Campaign$activitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignActivity
     */
    select?: CampaignActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignActivityInclude<ExtArgs> | null
    where?: CampaignActivityWhereInput
    orderBy?: CampaignActivityOrderByWithRelationInput | CampaignActivityOrderByWithRelationInput[]
    cursor?: CampaignActivityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CampaignActivityScalarFieldEnum | CampaignActivityScalarFieldEnum[]
  }

  /**
   * Campaign without action
   */
  export type CampaignDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
  }


  /**
   * Model CampaignImage
   */

  export type AggregateCampaignImage = {
    _count: CampaignImageCountAggregateOutputType | null
    _min: CampaignImageMinAggregateOutputType | null
    _max: CampaignImageMaxAggregateOutputType | null
  }

  export type CampaignImageMinAggregateOutputType = {
    id: string | null
    campaignId: string | null
    url: string | null
    title: string | null
    description: string | null
    uploadedById: string | null
    createdAt: Date | null
  }

  export type CampaignImageMaxAggregateOutputType = {
    id: string | null
    campaignId: string | null
    url: string | null
    title: string | null
    description: string | null
    uploadedById: string | null
    createdAt: Date | null
  }

  export type CampaignImageCountAggregateOutputType = {
    id: number
    campaignId: number
    url: number
    title: number
    description: number
    uploadedById: number
    createdAt: number
    _all: number
  }


  export type CampaignImageMinAggregateInputType = {
    id?: true
    campaignId?: true
    url?: true
    title?: true
    description?: true
    uploadedById?: true
    createdAt?: true
  }

  export type CampaignImageMaxAggregateInputType = {
    id?: true
    campaignId?: true
    url?: true
    title?: true
    description?: true
    uploadedById?: true
    createdAt?: true
  }

  export type CampaignImageCountAggregateInputType = {
    id?: true
    campaignId?: true
    url?: true
    title?: true
    description?: true
    uploadedById?: true
    createdAt?: true
    _all?: true
  }

  export type CampaignImageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CampaignImage to aggregate.
     */
    where?: CampaignImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignImages to fetch.
     */
    orderBy?: CampaignImageOrderByWithRelationInput | CampaignImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CampaignImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CampaignImages
    **/
    _count?: true | CampaignImageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CampaignImageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CampaignImageMaxAggregateInputType
  }

  export type GetCampaignImageAggregateType<T extends CampaignImageAggregateArgs> = {
        [P in keyof T & keyof AggregateCampaignImage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCampaignImage[P]>
      : GetScalarType<T[P], AggregateCampaignImage[P]>
  }




  export type CampaignImageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CampaignImageWhereInput
    orderBy?: CampaignImageOrderByWithAggregationInput | CampaignImageOrderByWithAggregationInput[]
    by: CampaignImageScalarFieldEnum[] | CampaignImageScalarFieldEnum
    having?: CampaignImageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CampaignImageCountAggregateInputType | true
    _min?: CampaignImageMinAggregateInputType
    _max?: CampaignImageMaxAggregateInputType
  }

  export type CampaignImageGroupByOutputType = {
    id: string
    campaignId: string
    url: string
    title: string | null
    description: string | null
    uploadedById: string
    createdAt: Date
    _count: CampaignImageCountAggregateOutputType | null
    _min: CampaignImageMinAggregateOutputType | null
    _max: CampaignImageMaxAggregateOutputType | null
  }

  type GetCampaignImageGroupByPayload<T extends CampaignImageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CampaignImageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CampaignImageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CampaignImageGroupByOutputType[P]>
            : GetScalarType<T[P], CampaignImageGroupByOutputType[P]>
        }
      >
    >


  export type CampaignImageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    campaignId?: boolean
    url?: boolean
    title?: boolean
    description?: boolean
    uploadedById?: boolean
    createdAt?: boolean
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
    uploadedBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["campaignImage"]>

  export type CampaignImageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    campaignId?: boolean
    url?: boolean
    title?: boolean
    description?: boolean
    uploadedById?: boolean
    createdAt?: boolean
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
    uploadedBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["campaignImage"]>

  export type CampaignImageSelectScalar = {
    id?: boolean
    campaignId?: boolean
    url?: boolean
    title?: boolean
    description?: boolean
    uploadedById?: boolean
    createdAt?: boolean
  }

  export type CampaignImageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
    uploadedBy?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type CampaignImageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
    uploadedBy?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $CampaignImagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CampaignImage"
    objects: {
      campaign: Prisma.$CampaignPayload<ExtArgs>
      uploadedBy: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      campaignId: string
      url: string
      title: string | null
      description: string | null
      uploadedById: string
      createdAt: Date
    }, ExtArgs["result"]["campaignImage"]>
    composites: {}
  }

  type CampaignImageGetPayload<S extends boolean | null | undefined | CampaignImageDefaultArgs> = $Result.GetResult<Prisma.$CampaignImagePayload, S>

  type CampaignImageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CampaignImageFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CampaignImageCountAggregateInputType | true
    }

  export interface CampaignImageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CampaignImage'], meta: { name: 'CampaignImage' } }
    /**
     * Find zero or one CampaignImage that matches the filter.
     * @param {CampaignImageFindUniqueArgs} args - Arguments to find a CampaignImage
     * @example
     * // Get one CampaignImage
     * const campaignImage = await prisma.campaignImage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CampaignImageFindUniqueArgs>(args: SelectSubset<T, CampaignImageFindUniqueArgs<ExtArgs>>): Prisma__CampaignImageClient<$Result.GetResult<Prisma.$CampaignImagePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CampaignImage that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CampaignImageFindUniqueOrThrowArgs} args - Arguments to find a CampaignImage
     * @example
     * // Get one CampaignImage
     * const campaignImage = await prisma.campaignImage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CampaignImageFindUniqueOrThrowArgs>(args: SelectSubset<T, CampaignImageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CampaignImageClient<$Result.GetResult<Prisma.$CampaignImagePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CampaignImage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignImageFindFirstArgs} args - Arguments to find a CampaignImage
     * @example
     * // Get one CampaignImage
     * const campaignImage = await prisma.campaignImage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CampaignImageFindFirstArgs>(args?: SelectSubset<T, CampaignImageFindFirstArgs<ExtArgs>>): Prisma__CampaignImageClient<$Result.GetResult<Prisma.$CampaignImagePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CampaignImage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignImageFindFirstOrThrowArgs} args - Arguments to find a CampaignImage
     * @example
     * // Get one CampaignImage
     * const campaignImage = await prisma.campaignImage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CampaignImageFindFirstOrThrowArgs>(args?: SelectSubset<T, CampaignImageFindFirstOrThrowArgs<ExtArgs>>): Prisma__CampaignImageClient<$Result.GetResult<Prisma.$CampaignImagePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CampaignImages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignImageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CampaignImages
     * const campaignImages = await prisma.campaignImage.findMany()
     * 
     * // Get first 10 CampaignImages
     * const campaignImages = await prisma.campaignImage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const campaignImageWithIdOnly = await prisma.campaignImage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CampaignImageFindManyArgs>(args?: SelectSubset<T, CampaignImageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignImagePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CampaignImage.
     * @param {CampaignImageCreateArgs} args - Arguments to create a CampaignImage.
     * @example
     * // Create one CampaignImage
     * const CampaignImage = await prisma.campaignImage.create({
     *   data: {
     *     // ... data to create a CampaignImage
     *   }
     * })
     * 
     */
    create<T extends CampaignImageCreateArgs>(args: SelectSubset<T, CampaignImageCreateArgs<ExtArgs>>): Prisma__CampaignImageClient<$Result.GetResult<Prisma.$CampaignImagePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CampaignImages.
     * @param {CampaignImageCreateManyArgs} args - Arguments to create many CampaignImages.
     * @example
     * // Create many CampaignImages
     * const campaignImage = await prisma.campaignImage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CampaignImageCreateManyArgs>(args?: SelectSubset<T, CampaignImageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CampaignImages and returns the data saved in the database.
     * @param {CampaignImageCreateManyAndReturnArgs} args - Arguments to create many CampaignImages.
     * @example
     * // Create many CampaignImages
     * const campaignImage = await prisma.campaignImage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CampaignImages and only return the `id`
     * const campaignImageWithIdOnly = await prisma.campaignImage.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CampaignImageCreateManyAndReturnArgs>(args?: SelectSubset<T, CampaignImageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignImagePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CampaignImage.
     * @param {CampaignImageDeleteArgs} args - Arguments to delete one CampaignImage.
     * @example
     * // Delete one CampaignImage
     * const CampaignImage = await prisma.campaignImage.delete({
     *   where: {
     *     // ... filter to delete one CampaignImage
     *   }
     * })
     * 
     */
    delete<T extends CampaignImageDeleteArgs>(args: SelectSubset<T, CampaignImageDeleteArgs<ExtArgs>>): Prisma__CampaignImageClient<$Result.GetResult<Prisma.$CampaignImagePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CampaignImage.
     * @param {CampaignImageUpdateArgs} args - Arguments to update one CampaignImage.
     * @example
     * // Update one CampaignImage
     * const campaignImage = await prisma.campaignImage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CampaignImageUpdateArgs>(args: SelectSubset<T, CampaignImageUpdateArgs<ExtArgs>>): Prisma__CampaignImageClient<$Result.GetResult<Prisma.$CampaignImagePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CampaignImages.
     * @param {CampaignImageDeleteManyArgs} args - Arguments to filter CampaignImages to delete.
     * @example
     * // Delete a few CampaignImages
     * const { count } = await prisma.campaignImage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CampaignImageDeleteManyArgs>(args?: SelectSubset<T, CampaignImageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CampaignImages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignImageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CampaignImages
     * const campaignImage = await prisma.campaignImage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CampaignImageUpdateManyArgs>(args: SelectSubset<T, CampaignImageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CampaignImage.
     * @param {CampaignImageUpsertArgs} args - Arguments to update or create a CampaignImage.
     * @example
     * // Update or create a CampaignImage
     * const campaignImage = await prisma.campaignImage.upsert({
     *   create: {
     *     // ... data to create a CampaignImage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CampaignImage we want to update
     *   }
     * })
     */
    upsert<T extends CampaignImageUpsertArgs>(args: SelectSubset<T, CampaignImageUpsertArgs<ExtArgs>>): Prisma__CampaignImageClient<$Result.GetResult<Prisma.$CampaignImagePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CampaignImages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignImageCountArgs} args - Arguments to filter CampaignImages to count.
     * @example
     * // Count the number of CampaignImages
     * const count = await prisma.campaignImage.count({
     *   where: {
     *     // ... the filter for the CampaignImages we want to count
     *   }
     * })
    **/
    count<T extends CampaignImageCountArgs>(
      args?: Subset<T, CampaignImageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CampaignImageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CampaignImage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignImageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CampaignImageAggregateArgs>(args: Subset<T, CampaignImageAggregateArgs>): Prisma.PrismaPromise<GetCampaignImageAggregateType<T>>

    /**
     * Group by CampaignImage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignImageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CampaignImageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CampaignImageGroupByArgs['orderBy'] }
        : { orderBy?: CampaignImageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CampaignImageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCampaignImageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CampaignImage model
   */
  readonly fields: CampaignImageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CampaignImage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CampaignImageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    campaign<T extends CampaignDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CampaignDefaultArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    uploadedBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CampaignImage model
   */ 
  interface CampaignImageFieldRefs {
    readonly id: FieldRef<"CampaignImage", 'String'>
    readonly campaignId: FieldRef<"CampaignImage", 'String'>
    readonly url: FieldRef<"CampaignImage", 'String'>
    readonly title: FieldRef<"CampaignImage", 'String'>
    readonly description: FieldRef<"CampaignImage", 'String'>
    readonly uploadedById: FieldRef<"CampaignImage", 'String'>
    readonly createdAt: FieldRef<"CampaignImage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CampaignImage findUnique
   */
  export type CampaignImageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignImage
     */
    select?: CampaignImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignImageInclude<ExtArgs> | null
    /**
     * Filter, which CampaignImage to fetch.
     */
    where: CampaignImageWhereUniqueInput
  }

  /**
   * CampaignImage findUniqueOrThrow
   */
  export type CampaignImageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignImage
     */
    select?: CampaignImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignImageInclude<ExtArgs> | null
    /**
     * Filter, which CampaignImage to fetch.
     */
    where: CampaignImageWhereUniqueInput
  }

  /**
   * CampaignImage findFirst
   */
  export type CampaignImageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignImage
     */
    select?: CampaignImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignImageInclude<ExtArgs> | null
    /**
     * Filter, which CampaignImage to fetch.
     */
    where?: CampaignImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignImages to fetch.
     */
    orderBy?: CampaignImageOrderByWithRelationInput | CampaignImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CampaignImages.
     */
    cursor?: CampaignImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CampaignImages.
     */
    distinct?: CampaignImageScalarFieldEnum | CampaignImageScalarFieldEnum[]
  }

  /**
   * CampaignImage findFirstOrThrow
   */
  export type CampaignImageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignImage
     */
    select?: CampaignImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignImageInclude<ExtArgs> | null
    /**
     * Filter, which CampaignImage to fetch.
     */
    where?: CampaignImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignImages to fetch.
     */
    orderBy?: CampaignImageOrderByWithRelationInput | CampaignImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CampaignImages.
     */
    cursor?: CampaignImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CampaignImages.
     */
    distinct?: CampaignImageScalarFieldEnum | CampaignImageScalarFieldEnum[]
  }

  /**
   * CampaignImage findMany
   */
  export type CampaignImageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignImage
     */
    select?: CampaignImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignImageInclude<ExtArgs> | null
    /**
     * Filter, which CampaignImages to fetch.
     */
    where?: CampaignImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignImages to fetch.
     */
    orderBy?: CampaignImageOrderByWithRelationInput | CampaignImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CampaignImages.
     */
    cursor?: CampaignImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignImages.
     */
    skip?: number
    distinct?: CampaignImageScalarFieldEnum | CampaignImageScalarFieldEnum[]
  }

  /**
   * CampaignImage create
   */
  export type CampaignImageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignImage
     */
    select?: CampaignImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignImageInclude<ExtArgs> | null
    /**
     * The data needed to create a CampaignImage.
     */
    data: XOR<CampaignImageCreateInput, CampaignImageUncheckedCreateInput>
  }

  /**
   * CampaignImage createMany
   */
  export type CampaignImageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CampaignImages.
     */
    data: CampaignImageCreateManyInput | CampaignImageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CampaignImage createManyAndReturn
   */
  export type CampaignImageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignImage
     */
    select?: CampaignImageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CampaignImages.
     */
    data: CampaignImageCreateManyInput | CampaignImageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignImageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CampaignImage update
   */
  export type CampaignImageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignImage
     */
    select?: CampaignImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignImageInclude<ExtArgs> | null
    /**
     * The data needed to update a CampaignImage.
     */
    data: XOR<CampaignImageUpdateInput, CampaignImageUncheckedUpdateInput>
    /**
     * Choose, which CampaignImage to update.
     */
    where: CampaignImageWhereUniqueInput
  }

  /**
   * CampaignImage updateMany
   */
  export type CampaignImageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CampaignImages.
     */
    data: XOR<CampaignImageUpdateManyMutationInput, CampaignImageUncheckedUpdateManyInput>
    /**
     * Filter which CampaignImages to update
     */
    where?: CampaignImageWhereInput
  }

  /**
   * CampaignImage upsert
   */
  export type CampaignImageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignImage
     */
    select?: CampaignImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignImageInclude<ExtArgs> | null
    /**
     * The filter to search for the CampaignImage to update in case it exists.
     */
    where: CampaignImageWhereUniqueInput
    /**
     * In case the CampaignImage found by the `where` argument doesn't exist, create a new CampaignImage with this data.
     */
    create: XOR<CampaignImageCreateInput, CampaignImageUncheckedCreateInput>
    /**
     * In case the CampaignImage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CampaignImageUpdateInput, CampaignImageUncheckedUpdateInput>
  }

  /**
   * CampaignImage delete
   */
  export type CampaignImageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignImage
     */
    select?: CampaignImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignImageInclude<ExtArgs> | null
    /**
     * Filter which CampaignImage to delete.
     */
    where: CampaignImageWhereUniqueInput
  }

  /**
   * CampaignImage deleteMany
   */
  export type CampaignImageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CampaignImages to delete
     */
    where?: CampaignImageWhereInput
  }

  /**
   * CampaignImage without action
   */
  export type CampaignImageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignImage
     */
    select?: CampaignImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignImageInclude<ExtArgs> | null
  }


  /**
   * Model CampaignTeamLead
   */

  export type AggregateCampaignTeamLead = {
    _count: CampaignTeamLeadCountAggregateOutputType | null
    _min: CampaignTeamLeadMinAggregateOutputType | null
    _max: CampaignTeamLeadMaxAggregateOutputType | null
  }

  export type CampaignTeamLeadMinAggregateOutputType = {
    id: string | null
    campaignId: string | null
    userId: string | null
    createdAt: Date | null
  }

  export type CampaignTeamLeadMaxAggregateOutputType = {
    id: string | null
    campaignId: string | null
    userId: string | null
    createdAt: Date | null
  }

  export type CampaignTeamLeadCountAggregateOutputType = {
    id: number
    campaignId: number
    userId: number
    createdAt: number
    _all: number
  }


  export type CampaignTeamLeadMinAggregateInputType = {
    id?: true
    campaignId?: true
    userId?: true
    createdAt?: true
  }

  export type CampaignTeamLeadMaxAggregateInputType = {
    id?: true
    campaignId?: true
    userId?: true
    createdAt?: true
  }

  export type CampaignTeamLeadCountAggregateInputType = {
    id?: true
    campaignId?: true
    userId?: true
    createdAt?: true
    _all?: true
  }

  export type CampaignTeamLeadAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CampaignTeamLead to aggregate.
     */
    where?: CampaignTeamLeadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignTeamLeads to fetch.
     */
    orderBy?: CampaignTeamLeadOrderByWithRelationInput | CampaignTeamLeadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CampaignTeamLeadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignTeamLeads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignTeamLeads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CampaignTeamLeads
    **/
    _count?: true | CampaignTeamLeadCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CampaignTeamLeadMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CampaignTeamLeadMaxAggregateInputType
  }

  export type GetCampaignTeamLeadAggregateType<T extends CampaignTeamLeadAggregateArgs> = {
        [P in keyof T & keyof AggregateCampaignTeamLead]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCampaignTeamLead[P]>
      : GetScalarType<T[P], AggregateCampaignTeamLead[P]>
  }




  export type CampaignTeamLeadGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CampaignTeamLeadWhereInput
    orderBy?: CampaignTeamLeadOrderByWithAggregationInput | CampaignTeamLeadOrderByWithAggregationInput[]
    by: CampaignTeamLeadScalarFieldEnum[] | CampaignTeamLeadScalarFieldEnum
    having?: CampaignTeamLeadScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CampaignTeamLeadCountAggregateInputType | true
    _min?: CampaignTeamLeadMinAggregateInputType
    _max?: CampaignTeamLeadMaxAggregateInputType
  }

  export type CampaignTeamLeadGroupByOutputType = {
    id: string
    campaignId: string
    userId: string
    createdAt: Date
    _count: CampaignTeamLeadCountAggregateOutputType | null
    _min: CampaignTeamLeadMinAggregateOutputType | null
    _max: CampaignTeamLeadMaxAggregateOutputType | null
  }

  type GetCampaignTeamLeadGroupByPayload<T extends CampaignTeamLeadGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CampaignTeamLeadGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CampaignTeamLeadGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CampaignTeamLeadGroupByOutputType[P]>
            : GetScalarType<T[P], CampaignTeamLeadGroupByOutputType[P]>
        }
      >
    >


  export type CampaignTeamLeadSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    campaignId?: boolean
    userId?: boolean
    createdAt?: boolean
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["campaignTeamLead"]>

  export type CampaignTeamLeadSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    campaignId?: boolean
    userId?: boolean
    createdAt?: boolean
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["campaignTeamLead"]>

  export type CampaignTeamLeadSelectScalar = {
    id?: boolean
    campaignId?: boolean
    userId?: boolean
    createdAt?: boolean
  }

  export type CampaignTeamLeadInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type CampaignTeamLeadIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $CampaignTeamLeadPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CampaignTeamLead"
    objects: {
      campaign: Prisma.$CampaignPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      campaignId: string
      userId: string
      createdAt: Date
    }, ExtArgs["result"]["campaignTeamLead"]>
    composites: {}
  }

  type CampaignTeamLeadGetPayload<S extends boolean | null | undefined | CampaignTeamLeadDefaultArgs> = $Result.GetResult<Prisma.$CampaignTeamLeadPayload, S>

  type CampaignTeamLeadCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CampaignTeamLeadFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CampaignTeamLeadCountAggregateInputType | true
    }

  export interface CampaignTeamLeadDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CampaignTeamLead'], meta: { name: 'CampaignTeamLead' } }
    /**
     * Find zero or one CampaignTeamLead that matches the filter.
     * @param {CampaignTeamLeadFindUniqueArgs} args - Arguments to find a CampaignTeamLead
     * @example
     * // Get one CampaignTeamLead
     * const campaignTeamLead = await prisma.campaignTeamLead.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CampaignTeamLeadFindUniqueArgs>(args: SelectSubset<T, CampaignTeamLeadFindUniqueArgs<ExtArgs>>): Prisma__CampaignTeamLeadClient<$Result.GetResult<Prisma.$CampaignTeamLeadPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CampaignTeamLead that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CampaignTeamLeadFindUniqueOrThrowArgs} args - Arguments to find a CampaignTeamLead
     * @example
     * // Get one CampaignTeamLead
     * const campaignTeamLead = await prisma.campaignTeamLead.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CampaignTeamLeadFindUniqueOrThrowArgs>(args: SelectSubset<T, CampaignTeamLeadFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CampaignTeamLeadClient<$Result.GetResult<Prisma.$CampaignTeamLeadPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CampaignTeamLead that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignTeamLeadFindFirstArgs} args - Arguments to find a CampaignTeamLead
     * @example
     * // Get one CampaignTeamLead
     * const campaignTeamLead = await prisma.campaignTeamLead.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CampaignTeamLeadFindFirstArgs>(args?: SelectSubset<T, CampaignTeamLeadFindFirstArgs<ExtArgs>>): Prisma__CampaignTeamLeadClient<$Result.GetResult<Prisma.$CampaignTeamLeadPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CampaignTeamLead that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignTeamLeadFindFirstOrThrowArgs} args - Arguments to find a CampaignTeamLead
     * @example
     * // Get one CampaignTeamLead
     * const campaignTeamLead = await prisma.campaignTeamLead.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CampaignTeamLeadFindFirstOrThrowArgs>(args?: SelectSubset<T, CampaignTeamLeadFindFirstOrThrowArgs<ExtArgs>>): Prisma__CampaignTeamLeadClient<$Result.GetResult<Prisma.$CampaignTeamLeadPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CampaignTeamLeads that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignTeamLeadFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CampaignTeamLeads
     * const campaignTeamLeads = await prisma.campaignTeamLead.findMany()
     * 
     * // Get first 10 CampaignTeamLeads
     * const campaignTeamLeads = await prisma.campaignTeamLead.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const campaignTeamLeadWithIdOnly = await prisma.campaignTeamLead.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CampaignTeamLeadFindManyArgs>(args?: SelectSubset<T, CampaignTeamLeadFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignTeamLeadPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CampaignTeamLead.
     * @param {CampaignTeamLeadCreateArgs} args - Arguments to create a CampaignTeamLead.
     * @example
     * // Create one CampaignTeamLead
     * const CampaignTeamLead = await prisma.campaignTeamLead.create({
     *   data: {
     *     // ... data to create a CampaignTeamLead
     *   }
     * })
     * 
     */
    create<T extends CampaignTeamLeadCreateArgs>(args: SelectSubset<T, CampaignTeamLeadCreateArgs<ExtArgs>>): Prisma__CampaignTeamLeadClient<$Result.GetResult<Prisma.$CampaignTeamLeadPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CampaignTeamLeads.
     * @param {CampaignTeamLeadCreateManyArgs} args - Arguments to create many CampaignTeamLeads.
     * @example
     * // Create many CampaignTeamLeads
     * const campaignTeamLead = await prisma.campaignTeamLead.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CampaignTeamLeadCreateManyArgs>(args?: SelectSubset<T, CampaignTeamLeadCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CampaignTeamLeads and returns the data saved in the database.
     * @param {CampaignTeamLeadCreateManyAndReturnArgs} args - Arguments to create many CampaignTeamLeads.
     * @example
     * // Create many CampaignTeamLeads
     * const campaignTeamLead = await prisma.campaignTeamLead.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CampaignTeamLeads and only return the `id`
     * const campaignTeamLeadWithIdOnly = await prisma.campaignTeamLead.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CampaignTeamLeadCreateManyAndReturnArgs>(args?: SelectSubset<T, CampaignTeamLeadCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignTeamLeadPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CampaignTeamLead.
     * @param {CampaignTeamLeadDeleteArgs} args - Arguments to delete one CampaignTeamLead.
     * @example
     * // Delete one CampaignTeamLead
     * const CampaignTeamLead = await prisma.campaignTeamLead.delete({
     *   where: {
     *     // ... filter to delete one CampaignTeamLead
     *   }
     * })
     * 
     */
    delete<T extends CampaignTeamLeadDeleteArgs>(args: SelectSubset<T, CampaignTeamLeadDeleteArgs<ExtArgs>>): Prisma__CampaignTeamLeadClient<$Result.GetResult<Prisma.$CampaignTeamLeadPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CampaignTeamLead.
     * @param {CampaignTeamLeadUpdateArgs} args - Arguments to update one CampaignTeamLead.
     * @example
     * // Update one CampaignTeamLead
     * const campaignTeamLead = await prisma.campaignTeamLead.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CampaignTeamLeadUpdateArgs>(args: SelectSubset<T, CampaignTeamLeadUpdateArgs<ExtArgs>>): Prisma__CampaignTeamLeadClient<$Result.GetResult<Prisma.$CampaignTeamLeadPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CampaignTeamLeads.
     * @param {CampaignTeamLeadDeleteManyArgs} args - Arguments to filter CampaignTeamLeads to delete.
     * @example
     * // Delete a few CampaignTeamLeads
     * const { count } = await prisma.campaignTeamLead.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CampaignTeamLeadDeleteManyArgs>(args?: SelectSubset<T, CampaignTeamLeadDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CampaignTeamLeads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignTeamLeadUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CampaignTeamLeads
     * const campaignTeamLead = await prisma.campaignTeamLead.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CampaignTeamLeadUpdateManyArgs>(args: SelectSubset<T, CampaignTeamLeadUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CampaignTeamLead.
     * @param {CampaignTeamLeadUpsertArgs} args - Arguments to update or create a CampaignTeamLead.
     * @example
     * // Update or create a CampaignTeamLead
     * const campaignTeamLead = await prisma.campaignTeamLead.upsert({
     *   create: {
     *     // ... data to create a CampaignTeamLead
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CampaignTeamLead we want to update
     *   }
     * })
     */
    upsert<T extends CampaignTeamLeadUpsertArgs>(args: SelectSubset<T, CampaignTeamLeadUpsertArgs<ExtArgs>>): Prisma__CampaignTeamLeadClient<$Result.GetResult<Prisma.$CampaignTeamLeadPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CampaignTeamLeads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignTeamLeadCountArgs} args - Arguments to filter CampaignTeamLeads to count.
     * @example
     * // Count the number of CampaignTeamLeads
     * const count = await prisma.campaignTeamLead.count({
     *   where: {
     *     // ... the filter for the CampaignTeamLeads we want to count
     *   }
     * })
    **/
    count<T extends CampaignTeamLeadCountArgs>(
      args?: Subset<T, CampaignTeamLeadCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CampaignTeamLeadCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CampaignTeamLead.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignTeamLeadAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CampaignTeamLeadAggregateArgs>(args: Subset<T, CampaignTeamLeadAggregateArgs>): Prisma.PrismaPromise<GetCampaignTeamLeadAggregateType<T>>

    /**
     * Group by CampaignTeamLead.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignTeamLeadGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CampaignTeamLeadGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CampaignTeamLeadGroupByArgs['orderBy'] }
        : { orderBy?: CampaignTeamLeadGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CampaignTeamLeadGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCampaignTeamLeadGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CampaignTeamLead model
   */
  readonly fields: CampaignTeamLeadFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CampaignTeamLead.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CampaignTeamLeadClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    campaign<T extends CampaignDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CampaignDefaultArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CampaignTeamLead model
   */ 
  interface CampaignTeamLeadFieldRefs {
    readonly id: FieldRef<"CampaignTeamLead", 'String'>
    readonly campaignId: FieldRef<"CampaignTeamLead", 'String'>
    readonly userId: FieldRef<"CampaignTeamLead", 'String'>
    readonly createdAt: FieldRef<"CampaignTeamLead", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CampaignTeamLead findUnique
   */
  export type CampaignTeamLeadFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignTeamLead
     */
    select?: CampaignTeamLeadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignTeamLeadInclude<ExtArgs> | null
    /**
     * Filter, which CampaignTeamLead to fetch.
     */
    where: CampaignTeamLeadWhereUniqueInput
  }

  /**
   * CampaignTeamLead findUniqueOrThrow
   */
  export type CampaignTeamLeadFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignTeamLead
     */
    select?: CampaignTeamLeadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignTeamLeadInclude<ExtArgs> | null
    /**
     * Filter, which CampaignTeamLead to fetch.
     */
    where: CampaignTeamLeadWhereUniqueInput
  }

  /**
   * CampaignTeamLead findFirst
   */
  export type CampaignTeamLeadFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignTeamLead
     */
    select?: CampaignTeamLeadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignTeamLeadInclude<ExtArgs> | null
    /**
     * Filter, which CampaignTeamLead to fetch.
     */
    where?: CampaignTeamLeadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignTeamLeads to fetch.
     */
    orderBy?: CampaignTeamLeadOrderByWithRelationInput | CampaignTeamLeadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CampaignTeamLeads.
     */
    cursor?: CampaignTeamLeadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignTeamLeads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignTeamLeads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CampaignTeamLeads.
     */
    distinct?: CampaignTeamLeadScalarFieldEnum | CampaignTeamLeadScalarFieldEnum[]
  }

  /**
   * CampaignTeamLead findFirstOrThrow
   */
  export type CampaignTeamLeadFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignTeamLead
     */
    select?: CampaignTeamLeadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignTeamLeadInclude<ExtArgs> | null
    /**
     * Filter, which CampaignTeamLead to fetch.
     */
    where?: CampaignTeamLeadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignTeamLeads to fetch.
     */
    orderBy?: CampaignTeamLeadOrderByWithRelationInput | CampaignTeamLeadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CampaignTeamLeads.
     */
    cursor?: CampaignTeamLeadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignTeamLeads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignTeamLeads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CampaignTeamLeads.
     */
    distinct?: CampaignTeamLeadScalarFieldEnum | CampaignTeamLeadScalarFieldEnum[]
  }

  /**
   * CampaignTeamLead findMany
   */
  export type CampaignTeamLeadFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignTeamLead
     */
    select?: CampaignTeamLeadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignTeamLeadInclude<ExtArgs> | null
    /**
     * Filter, which CampaignTeamLeads to fetch.
     */
    where?: CampaignTeamLeadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignTeamLeads to fetch.
     */
    orderBy?: CampaignTeamLeadOrderByWithRelationInput | CampaignTeamLeadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CampaignTeamLeads.
     */
    cursor?: CampaignTeamLeadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignTeamLeads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignTeamLeads.
     */
    skip?: number
    distinct?: CampaignTeamLeadScalarFieldEnum | CampaignTeamLeadScalarFieldEnum[]
  }

  /**
   * CampaignTeamLead create
   */
  export type CampaignTeamLeadCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignTeamLead
     */
    select?: CampaignTeamLeadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignTeamLeadInclude<ExtArgs> | null
    /**
     * The data needed to create a CampaignTeamLead.
     */
    data: XOR<CampaignTeamLeadCreateInput, CampaignTeamLeadUncheckedCreateInput>
  }

  /**
   * CampaignTeamLead createMany
   */
  export type CampaignTeamLeadCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CampaignTeamLeads.
     */
    data: CampaignTeamLeadCreateManyInput | CampaignTeamLeadCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CampaignTeamLead createManyAndReturn
   */
  export type CampaignTeamLeadCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignTeamLead
     */
    select?: CampaignTeamLeadSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CampaignTeamLeads.
     */
    data: CampaignTeamLeadCreateManyInput | CampaignTeamLeadCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignTeamLeadIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CampaignTeamLead update
   */
  export type CampaignTeamLeadUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignTeamLead
     */
    select?: CampaignTeamLeadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignTeamLeadInclude<ExtArgs> | null
    /**
     * The data needed to update a CampaignTeamLead.
     */
    data: XOR<CampaignTeamLeadUpdateInput, CampaignTeamLeadUncheckedUpdateInput>
    /**
     * Choose, which CampaignTeamLead to update.
     */
    where: CampaignTeamLeadWhereUniqueInput
  }

  /**
   * CampaignTeamLead updateMany
   */
  export type CampaignTeamLeadUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CampaignTeamLeads.
     */
    data: XOR<CampaignTeamLeadUpdateManyMutationInput, CampaignTeamLeadUncheckedUpdateManyInput>
    /**
     * Filter which CampaignTeamLeads to update
     */
    where?: CampaignTeamLeadWhereInput
  }

  /**
   * CampaignTeamLead upsert
   */
  export type CampaignTeamLeadUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignTeamLead
     */
    select?: CampaignTeamLeadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignTeamLeadInclude<ExtArgs> | null
    /**
     * The filter to search for the CampaignTeamLead to update in case it exists.
     */
    where: CampaignTeamLeadWhereUniqueInput
    /**
     * In case the CampaignTeamLead found by the `where` argument doesn't exist, create a new CampaignTeamLead with this data.
     */
    create: XOR<CampaignTeamLeadCreateInput, CampaignTeamLeadUncheckedCreateInput>
    /**
     * In case the CampaignTeamLead was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CampaignTeamLeadUpdateInput, CampaignTeamLeadUncheckedUpdateInput>
  }

  /**
   * CampaignTeamLead delete
   */
  export type CampaignTeamLeadDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignTeamLead
     */
    select?: CampaignTeamLeadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignTeamLeadInclude<ExtArgs> | null
    /**
     * Filter which CampaignTeamLead to delete.
     */
    where: CampaignTeamLeadWhereUniqueInput
  }

  /**
   * CampaignTeamLead deleteMany
   */
  export type CampaignTeamLeadDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CampaignTeamLeads to delete
     */
    where?: CampaignTeamLeadWhereInput
  }

  /**
   * CampaignTeamLead without action
   */
  export type CampaignTeamLeadDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignTeamLead
     */
    select?: CampaignTeamLeadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignTeamLeadInclude<ExtArgs> | null
  }


  /**
   * Model CampaignAssignment
   */

  export type AggregateCampaignAssignment = {
    _count: CampaignAssignmentCountAggregateOutputType | null
    _avg: CampaignAssignmentAvgAggregateOutputType | null
    _sum: CampaignAssignmentSumAggregateOutputType | null
    _min: CampaignAssignmentMinAggregateOutputType | null
    _max: CampaignAssignmentMaxAggregateOutputType | null
  }

  export type CampaignAssignmentAvgAggregateOutputType = {
    targetAmount: Decimal | null
    progressPercent: number | null
  }

  export type CampaignAssignmentSumAggregateOutputType = {
    targetAmount: Decimal | null
    progressPercent: number | null
  }

  export type CampaignAssignmentMinAggregateOutputType = {
    id: string | null
    campaignId: string | null
    userId: string | null
    role: $Enums.Role | null
    targetAmount: Decimal | null
    progressPercent: number | null
    isCompleted: boolean | null
    completedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CampaignAssignmentMaxAggregateOutputType = {
    id: string | null
    campaignId: string | null
    userId: string | null
    role: $Enums.Role | null
    targetAmount: Decimal | null
    progressPercent: number | null
    isCompleted: boolean | null
    completedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CampaignAssignmentCountAggregateOutputType = {
    id: number
    campaignId: number
    userId: number
    role: number
    targetAmount: number
    progressPercent: number
    isCompleted: number
    completedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CampaignAssignmentAvgAggregateInputType = {
    targetAmount?: true
    progressPercent?: true
  }

  export type CampaignAssignmentSumAggregateInputType = {
    targetAmount?: true
    progressPercent?: true
  }

  export type CampaignAssignmentMinAggregateInputType = {
    id?: true
    campaignId?: true
    userId?: true
    role?: true
    targetAmount?: true
    progressPercent?: true
    isCompleted?: true
    completedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CampaignAssignmentMaxAggregateInputType = {
    id?: true
    campaignId?: true
    userId?: true
    role?: true
    targetAmount?: true
    progressPercent?: true
    isCompleted?: true
    completedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CampaignAssignmentCountAggregateInputType = {
    id?: true
    campaignId?: true
    userId?: true
    role?: true
    targetAmount?: true
    progressPercent?: true
    isCompleted?: true
    completedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CampaignAssignmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CampaignAssignment to aggregate.
     */
    where?: CampaignAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignAssignments to fetch.
     */
    orderBy?: CampaignAssignmentOrderByWithRelationInput | CampaignAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CampaignAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignAssignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CampaignAssignments
    **/
    _count?: true | CampaignAssignmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CampaignAssignmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CampaignAssignmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CampaignAssignmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CampaignAssignmentMaxAggregateInputType
  }

  export type GetCampaignAssignmentAggregateType<T extends CampaignAssignmentAggregateArgs> = {
        [P in keyof T & keyof AggregateCampaignAssignment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCampaignAssignment[P]>
      : GetScalarType<T[P], AggregateCampaignAssignment[P]>
  }




  export type CampaignAssignmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CampaignAssignmentWhereInput
    orderBy?: CampaignAssignmentOrderByWithAggregationInput | CampaignAssignmentOrderByWithAggregationInput[]
    by: CampaignAssignmentScalarFieldEnum[] | CampaignAssignmentScalarFieldEnum
    having?: CampaignAssignmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CampaignAssignmentCountAggregateInputType | true
    _avg?: CampaignAssignmentAvgAggregateInputType
    _sum?: CampaignAssignmentSumAggregateInputType
    _min?: CampaignAssignmentMinAggregateInputType
    _max?: CampaignAssignmentMaxAggregateInputType
  }

  export type CampaignAssignmentGroupByOutputType = {
    id: string
    campaignId: string
    userId: string
    role: $Enums.Role
    targetAmount: Decimal
    progressPercent: number
    isCompleted: boolean
    completedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: CampaignAssignmentCountAggregateOutputType | null
    _avg: CampaignAssignmentAvgAggregateOutputType | null
    _sum: CampaignAssignmentSumAggregateOutputType | null
    _min: CampaignAssignmentMinAggregateOutputType | null
    _max: CampaignAssignmentMaxAggregateOutputType | null
  }

  type GetCampaignAssignmentGroupByPayload<T extends CampaignAssignmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CampaignAssignmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CampaignAssignmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CampaignAssignmentGroupByOutputType[P]>
            : GetScalarType<T[P], CampaignAssignmentGroupByOutputType[P]>
        }
      >
    >


  export type CampaignAssignmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    campaignId?: boolean
    userId?: boolean
    role?: boolean
    targetAmount?: boolean
    progressPercent?: boolean
    isCompleted?: boolean
    completedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    tasks?: boolean | CampaignAssignment$tasksArgs<ExtArgs>
    _count?: boolean | CampaignAssignmentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["campaignAssignment"]>

  export type CampaignAssignmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    campaignId?: boolean
    userId?: boolean
    role?: boolean
    targetAmount?: boolean
    progressPercent?: boolean
    isCompleted?: boolean
    completedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["campaignAssignment"]>

  export type CampaignAssignmentSelectScalar = {
    id?: boolean
    campaignId?: boolean
    userId?: boolean
    role?: boolean
    targetAmount?: boolean
    progressPercent?: boolean
    isCompleted?: boolean
    completedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CampaignAssignmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    tasks?: boolean | CampaignAssignment$tasksArgs<ExtArgs>
    _count?: boolean | CampaignAssignmentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CampaignAssignmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $CampaignAssignmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CampaignAssignment"
    objects: {
      campaign: Prisma.$CampaignPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
      tasks: Prisma.$CampaignTaskPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      campaignId: string
      userId: string
      role: $Enums.Role
      targetAmount: Prisma.Decimal
      progressPercent: number
      isCompleted: boolean
      completedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["campaignAssignment"]>
    composites: {}
  }

  type CampaignAssignmentGetPayload<S extends boolean | null | undefined | CampaignAssignmentDefaultArgs> = $Result.GetResult<Prisma.$CampaignAssignmentPayload, S>

  type CampaignAssignmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CampaignAssignmentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CampaignAssignmentCountAggregateInputType | true
    }

  export interface CampaignAssignmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CampaignAssignment'], meta: { name: 'CampaignAssignment' } }
    /**
     * Find zero or one CampaignAssignment that matches the filter.
     * @param {CampaignAssignmentFindUniqueArgs} args - Arguments to find a CampaignAssignment
     * @example
     * // Get one CampaignAssignment
     * const campaignAssignment = await prisma.campaignAssignment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CampaignAssignmentFindUniqueArgs>(args: SelectSubset<T, CampaignAssignmentFindUniqueArgs<ExtArgs>>): Prisma__CampaignAssignmentClient<$Result.GetResult<Prisma.$CampaignAssignmentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CampaignAssignment that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CampaignAssignmentFindUniqueOrThrowArgs} args - Arguments to find a CampaignAssignment
     * @example
     * // Get one CampaignAssignment
     * const campaignAssignment = await prisma.campaignAssignment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CampaignAssignmentFindUniqueOrThrowArgs>(args: SelectSubset<T, CampaignAssignmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CampaignAssignmentClient<$Result.GetResult<Prisma.$CampaignAssignmentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CampaignAssignment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignAssignmentFindFirstArgs} args - Arguments to find a CampaignAssignment
     * @example
     * // Get one CampaignAssignment
     * const campaignAssignment = await prisma.campaignAssignment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CampaignAssignmentFindFirstArgs>(args?: SelectSubset<T, CampaignAssignmentFindFirstArgs<ExtArgs>>): Prisma__CampaignAssignmentClient<$Result.GetResult<Prisma.$CampaignAssignmentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CampaignAssignment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignAssignmentFindFirstOrThrowArgs} args - Arguments to find a CampaignAssignment
     * @example
     * // Get one CampaignAssignment
     * const campaignAssignment = await prisma.campaignAssignment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CampaignAssignmentFindFirstOrThrowArgs>(args?: SelectSubset<T, CampaignAssignmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__CampaignAssignmentClient<$Result.GetResult<Prisma.$CampaignAssignmentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CampaignAssignments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignAssignmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CampaignAssignments
     * const campaignAssignments = await prisma.campaignAssignment.findMany()
     * 
     * // Get first 10 CampaignAssignments
     * const campaignAssignments = await prisma.campaignAssignment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const campaignAssignmentWithIdOnly = await prisma.campaignAssignment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CampaignAssignmentFindManyArgs>(args?: SelectSubset<T, CampaignAssignmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignAssignmentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CampaignAssignment.
     * @param {CampaignAssignmentCreateArgs} args - Arguments to create a CampaignAssignment.
     * @example
     * // Create one CampaignAssignment
     * const CampaignAssignment = await prisma.campaignAssignment.create({
     *   data: {
     *     // ... data to create a CampaignAssignment
     *   }
     * })
     * 
     */
    create<T extends CampaignAssignmentCreateArgs>(args: SelectSubset<T, CampaignAssignmentCreateArgs<ExtArgs>>): Prisma__CampaignAssignmentClient<$Result.GetResult<Prisma.$CampaignAssignmentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CampaignAssignments.
     * @param {CampaignAssignmentCreateManyArgs} args - Arguments to create many CampaignAssignments.
     * @example
     * // Create many CampaignAssignments
     * const campaignAssignment = await prisma.campaignAssignment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CampaignAssignmentCreateManyArgs>(args?: SelectSubset<T, CampaignAssignmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CampaignAssignments and returns the data saved in the database.
     * @param {CampaignAssignmentCreateManyAndReturnArgs} args - Arguments to create many CampaignAssignments.
     * @example
     * // Create many CampaignAssignments
     * const campaignAssignment = await prisma.campaignAssignment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CampaignAssignments and only return the `id`
     * const campaignAssignmentWithIdOnly = await prisma.campaignAssignment.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CampaignAssignmentCreateManyAndReturnArgs>(args?: SelectSubset<T, CampaignAssignmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignAssignmentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CampaignAssignment.
     * @param {CampaignAssignmentDeleteArgs} args - Arguments to delete one CampaignAssignment.
     * @example
     * // Delete one CampaignAssignment
     * const CampaignAssignment = await prisma.campaignAssignment.delete({
     *   where: {
     *     // ... filter to delete one CampaignAssignment
     *   }
     * })
     * 
     */
    delete<T extends CampaignAssignmentDeleteArgs>(args: SelectSubset<T, CampaignAssignmentDeleteArgs<ExtArgs>>): Prisma__CampaignAssignmentClient<$Result.GetResult<Prisma.$CampaignAssignmentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CampaignAssignment.
     * @param {CampaignAssignmentUpdateArgs} args - Arguments to update one CampaignAssignment.
     * @example
     * // Update one CampaignAssignment
     * const campaignAssignment = await prisma.campaignAssignment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CampaignAssignmentUpdateArgs>(args: SelectSubset<T, CampaignAssignmentUpdateArgs<ExtArgs>>): Prisma__CampaignAssignmentClient<$Result.GetResult<Prisma.$CampaignAssignmentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CampaignAssignments.
     * @param {CampaignAssignmentDeleteManyArgs} args - Arguments to filter CampaignAssignments to delete.
     * @example
     * // Delete a few CampaignAssignments
     * const { count } = await prisma.campaignAssignment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CampaignAssignmentDeleteManyArgs>(args?: SelectSubset<T, CampaignAssignmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CampaignAssignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignAssignmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CampaignAssignments
     * const campaignAssignment = await prisma.campaignAssignment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CampaignAssignmentUpdateManyArgs>(args: SelectSubset<T, CampaignAssignmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CampaignAssignment.
     * @param {CampaignAssignmentUpsertArgs} args - Arguments to update or create a CampaignAssignment.
     * @example
     * // Update or create a CampaignAssignment
     * const campaignAssignment = await prisma.campaignAssignment.upsert({
     *   create: {
     *     // ... data to create a CampaignAssignment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CampaignAssignment we want to update
     *   }
     * })
     */
    upsert<T extends CampaignAssignmentUpsertArgs>(args: SelectSubset<T, CampaignAssignmentUpsertArgs<ExtArgs>>): Prisma__CampaignAssignmentClient<$Result.GetResult<Prisma.$CampaignAssignmentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CampaignAssignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignAssignmentCountArgs} args - Arguments to filter CampaignAssignments to count.
     * @example
     * // Count the number of CampaignAssignments
     * const count = await prisma.campaignAssignment.count({
     *   where: {
     *     // ... the filter for the CampaignAssignments we want to count
     *   }
     * })
    **/
    count<T extends CampaignAssignmentCountArgs>(
      args?: Subset<T, CampaignAssignmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CampaignAssignmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CampaignAssignment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignAssignmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CampaignAssignmentAggregateArgs>(args: Subset<T, CampaignAssignmentAggregateArgs>): Prisma.PrismaPromise<GetCampaignAssignmentAggregateType<T>>

    /**
     * Group by CampaignAssignment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignAssignmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CampaignAssignmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CampaignAssignmentGroupByArgs['orderBy'] }
        : { orderBy?: CampaignAssignmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CampaignAssignmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCampaignAssignmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CampaignAssignment model
   */
  readonly fields: CampaignAssignmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CampaignAssignment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CampaignAssignmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    campaign<T extends CampaignDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CampaignDefaultArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    tasks<T extends CampaignAssignment$tasksArgs<ExtArgs> = {}>(args?: Subset<T, CampaignAssignment$tasksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignTaskPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CampaignAssignment model
   */ 
  interface CampaignAssignmentFieldRefs {
    readonly id: FieldRef<"CampaignAssignment", 'String'>
    readonly campaignId: FieldRef<"CampaignAssignment", 'String'>
    readonly userId: FieldRef<"CampaignAssignment", 'String'>
    readonly role: FieldRef<"CampaignAssignment", 'Role'>
    readonly targetAmount: FieldRef<"CampaignAssignment", 'Decimal'>
    readonly progressPercent: FieldRef<"CampaignAssignment", 'Int'>
    readonly isCompleted: FieldRef<"CampaignAssignment", 'Boolean'>
    readonly completedAt: FieldRef<"CampaignAssignment", 'DateTime'>
    readonly createdAt: FieldRef<"CampaignAssignment", 'DateTime'>
    readonly updatedAt: FieldRef<"CampaignAssignment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CampaignAssignment findUnique
   */
  export type CampaignAssignmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignAssignment
     */
    select?: CampaignAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which CampaignAssignment to fetch.
     */
    where: CampaignAssignmentWhereUniqueInput
  }

  /**
   * CampaignAssignment findUniqueOrThrow
   */
  export type CampaignAssignmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignAssignment
     */
    select?: CampaignAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which CampaignAssignment to fetch.
     */
    where: CampaignAssignmentWhereUniqueInput
  }

  /**
   * CampaignAssignment findFirst
   */
  export type CampaignAssignmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignAssignment
     */
    select?: CampaignAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which CampaignAssignment to fetch.
     */
    where?: CampaignAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignAssignments to fetch.
     */
    orderBy?: CampaignAssignmentOrderByWithRelationInput | CampaignAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CampaignAssignments.
     */
    cursor?: CampaignAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignAssignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CampaignAssignments.
     */
    distinct?: CampaignAssignmentScalarFieldEnum | CampaignAssignmentScalarFieldEnum[]
  }

  /**
   * CampaignAssignment findFirstOrThrow
   */
  export type CampaignAssignmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignAssignment
     */
    select?: CampaignAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which CampaignAssignment to fetch.
     */
    where?: CampaignAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignAssignments to fetch.
     */
    orderBy?: CampaignAssignmentOrderByWithRelationInput | CampaignAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CampaignAssignments.
     */
    cursor?: CampaignAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignAssignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CampaignAssignments.
     */
    distinct?: CampaignAssignmentScalarFieldEnum | CampaignAssignmentScalarFieldEnum[]
  }

  /**
   * CampaignAssignment findMany
   */
  export type CampaignAssignmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignAssignment
     */
    select?: CampaignAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which CampaignAssignments to fetch.
     */
    where?: CampaignAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignAssignments to fetch.
     */
    orderBy?: CampaignAssignmentOrderByWithRelationInput | CampaignAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CampaignAssignments.
     */
    cursor?: CampaignAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignAssignments.
     */
    skip?: number
    distinct?: CampaignAssignmentScalarFieldEnum | CampaignAssignmentScalarFieldEnum[]
  }

  /**
   * CampaignAssignment create
   */
  export type CampaignAssignmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignAssignment
     */
    select?: CampaignAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignAssignmentInclude<ExtArgs> | null
    /**
     * The data needed to create a CampaignAssignment.
     */
    data: XOR<CampaignAssignmentCreateInput, CampaignAssignmentUncheckedCreateInput>
  }

  /**
   * CampaignAssignment createMany
   */
  export type CampaignAssignmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CampaignAssignments.
     */
    data: CampaignAssignmentCreateManyInput | CampaignAssignmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CampaignAssignment createManyAndReturn
   */
  export type CampaignAssignmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignAssignment
     */
    select?: CampaignAssignmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CampaignAssignments.
     */
    data: CampaignAssignmentCreateManyInput | CampaignAssignmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignAssignmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CampaignAssignment update
   */
  export type CampaignAssignmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignAssignment
     */
    select?: CampaignAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignAssignmentInclude<ExtArgs> | null
    /**
     * The data needed to update a CampaignAssignment.
     */
    data: XOR<CampaignAssignmentUpdateInput, CampaignAssignmentUncheckedUpdateInput>
    /**
     * Choose, which CampaignAssignment to update.
     */
    where: CampaignAssignmentWhereUniqueInput
  }

  /**
   * CampaignAssignment updateMany
   */
  export type CampaignAssignmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CampaignAssignments.
     */
    data: XOR<CampaignAssignmentUpdateManyMutationInput, CampaignAssignmentUncheckedUpdateManyInput>
    /**
     * Filter which CampaignAssignments to update
     */
    where?: CampaignAssignmentWhereInput
  }

  /**
   * CampaignAssignment upsert
   */
  export type CampaignAssignmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignAssignment
     */
    select?: CampaignAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignAssignmentInclude<ExtArgs> | null
    /**
     * The filter to search for the CampaignAssignment to update in case it exists.
     */
    where: CampaignAssignmentWhereUniqueInput
    /**
     * In case the CampaignAssignment found by the `where` argument doesn't exist, create a new CampaignAssignment with this data.
     */
    create: XOR<CampaignAssignmentCreateInput, CampaignAssignmentUncheckedCreateInput>
    /**
     * In case the CampaignAssignment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CampaignAssignmentUpdateInput, CampaignAssignmentUncheckedUpdateInput>
  }

  /**
   * CampaignAssignment delete
   */
  export type CampaignAssignmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignAssignment
     */
    select?: CampaignAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignAssignmentInclude<ExtArgs> | null
    /**
     * Filter which CampaignAssignment to delete.
     */
    where: CampaignAssignmentWhereUniqueInput
  }

  /**
   * CampaignAssignment deleteMany
   */
  export type CampaignAssignmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CampaignAssignments to delete
     */
    where?: CampaignAssignmentWhereInput
  }

  /**
   * CampaignAssignment.tasks
   */
  export type CampaignAssignment$tasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignTask
     */
    select?: CampaignTaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignTaskInclude<ExtArgs> | null
    where?: CampaignTaskWhereInput
    orderBy?: CampaignTaskOrderByWithRelationInput | CampaignTaskOrderByWithRelationInput[]
    cursor?: CampaignTaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CampaignTaskScalarFieldEnum | CampaignTaskScalarFieldEnum[]
  }

  /**
   * CampaignAssignment without action
   */
  export type CampaignAssignmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignAssignment
     */
    select?: CampaignAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignAssignmentInclude<ExtArgs> | null
  }


  /**
   * Model CampaignTask
   */

  export type AggregateCampaignTask = {
    _count: CampaignTaskCountAggregateOutputType | null
    _min: CampaignTaskMinAggregateOutputType | null
    _max: CampaignTaskMaxAggregateOutputType | null
  }

  export type CampaignTaskMinAggregateOutputType = {
    id: string | null
    campaignId: string | null
    assignmentId: string | null
    title: string | null
    description: string | null
    isCompleted: boolean | null
    completedById: string | null
    dueDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CampaignTaskMaxAggregateOutputType = {
    id: string | null
    campaignId: string | null
    assignmentId: string | null
    title: string | null
    description: string | null
    isCompleted: boolean | null
    completedById: string | null
    dueDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CampaignTaskCountAggregateOutputType = {
    id: number
    campaignId: number
    assignmentId: number
    title: number
    description: number
    isCompleted: number
    completedById: number
    dueDate: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CampaignTaskMinAggregateInputType = {
    id?: true
    campaignId?: true
    assignmentId?: true
    title?: true
    description?: true
    isCompleted?: true
    completedById?: true
    dueDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CampaignTaskMaxAggregateInputType = {
    id?: true
    campaignId?: true
    assignmentId?: true
    title?: true
    description?: true
    isCompleted?: true
    completedById?: true
    dueDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CampaignTaskCountAggregateInputType = {
    id?: true
    campaignId?: true
    assignmentId?: true
    title?: true
    description?: true
    isCompleted?: true
    completedById?: true
    dueDate?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CampaignTaskAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CampaignTask to aggregate.
     */
    where?: CampaignTaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignTasks to fetch.
     */
    orderBy?: CampaignTaskOrderByWithRelationInput | CampaignTaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CampaignTaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignTasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignTasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CampaignTasks
    **/
    _count?: true | CampaignTaskCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CampaignTaskMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CampaignTaskMaxAggregateInputType
  }

  export type GetCampaignTaskAggregateType<T extends CampaignTaskAggregateArgs> = {
        [P in keyof T & keyof AggregateCampaignTask]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCampaignTask[P]>
      : GetScalarType<T[P], AggregateCampaignTask[P]>
  }




  export type CampaignTaskGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CampaignTaskWhereInput
    orderBy?: CampaignTaskOrderByWithAggregationInput | CampaignTaskOrderByWithAggregationInput[]
    by: CampaignTaskScalarFieldEnum[] | CampaignTaskScalarFieldEnum
    having?: CampaignTaskScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CampaignTaskCountAggregateInputType | true
    _min?: CampaignTaskMinAggregateInputType
    _max?: CampaignTaskMaxAggregateInputType
  }

  export type CampaignTaskGroupByOutputType = {
    id: string
    campaignId: string
    assignmentId: string | null
    title: string
    description: string | null
    isCompleted: boolean
    completedById: string | null
    dueDate: Date | null
    createdAt: Date
    updatedAt: Date
    _count: CampaignTaskCountAggregateOutputType | null
    _min: CampaignTaskMinAggregateOutputType | null
    _max: CampaignTaskMaxAggregateOutputType | null
  }

  type GetCampaignTaskGroupByPayload<T extends CampaignTaskGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CampaignTaskGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CampaignTaskGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CampaignTaskGroupByOutputType[P]>
            : GetScalarType<T[P], CampaignTaskGroupByOutputType[P]>
        }
      >
    >


  export type CampaignTaskSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    campaignId?: boolean
    assignmentId?: boolean
    title?: boolean
    description?: boolean
    isCompleted?: boolean
    completedById?: boolean
    dueDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
    assignment?: boolean | CampaignTask$assignmentArgs<ExtArgs>
    completedBy?: boolean | CampaignTask$completedByArgs<ExtArgs>
  }, ExtArgs["result"]["campaignTask"]>

  export type CampaignTaskSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    campaignId?: boolean
    assignmentId?: boolean
    title?: boolean
    description?: boolean
    isCompleted?: boolean
    completedById?: boolean
    dueDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
    assignment?: boolean | CampaignTask$assignmentArgs<ExtArgs>
    completedBy?: boolean | CampaignTask$completedByArgs<ExtArgs>
  }, ExtArgs["result"]["campaignTask"]>

  export type CampaignTaskSelectScalar = {
    id?: boolean
    campaignId?: boolean
    assignmentId?: boolean
    title?: boolean
    description?: boolean
    isCompleted?: boolean
    completedById?: boolean
    dueDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CampaignTaskInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
    assignment?: boolean | CampaignTask$assignmentArgs<ExtArgs>
    completedBy?: boolean | CampaignTask$completedByArgs<ExtArgs>
  }
  export type CampaignTaskIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
    assignment?: boolean | CampaignTask$assignmentArgs<ExtArgs>
    completedBy?: boolean | CampaignTask$completedByArgs<ExtArgs>
  }

  export type $CampaignTaskPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CampaignTask"
    objects: {
      campaign: Prisma.$CampaignPayload<ExtArgs>
      assignment: Prisma.$CampaignAssignmentPayload<ExtArgs> | null
      completedBy: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      campaignId: string
      assignmentId: string | null
      title: string
      description: string | null
      isCompleted: boolean
      completedById: string | null
      dueDate: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["campaignTask"]>
    composites: {}
  }

  type CampaignTaskGetPayload<S extends boolean | null | undefined | CampaignTaskDefaultArgs> = $Result.GetResult<Prisma.$CampaignTaskPayload, S>

  type CampaignTaskCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CampaignTaskFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CampaignTaskCountAggregateInputType | true
    }

  export interface CampaignTaskDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CampaignTask'], meta: { name: 'CampaignTask' } }
    /**
     * Find zero or one CampaignTask that matches the filter.
     * @param {CampaignTaskFindUniqueArgs} args - Arguments to find a CampaignTask
     * @example
     * // Get one CampaignTask
     * const campaignTask = await prisma.campaignTask.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CampaignTaskFindUniqueArgs>(args: SelectSubset<T, CampaignTaskFindUniqueArgs<ExtArgs>>): Prisma__CampaignTaskClient<$Result.GetResult<Prisma.$CampaignTaskPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CampaignTask that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CampaignTaskFindUniqueOrThrowArgs} args - Arguments to find a CampaignTask
     * @example
     * // Get one CampaignTask
     * const campaignTask = await prisma.campaignTask.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CampaignTaskFindUniqueOrThrowArgs>(args: SelectSubset<T, CampaignTaskFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CampaignTaskClient<$Result.GetResult<Prisma.$CampaignTaskPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CampaignTask that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignTaskFindFirstArgs} args - Arguments to find a CampaignTask
     * @example
     * // Get one CampaignTask
     * const campaignTask = await prisma.campaignTask.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CampaignTaskFindFirstArgs>(args?: SelectSubset<T, CampaignTaskFindFirstArgs<ExtArgs>>): Prisma__CampaignTaskClient<$Result.GetResult<Prisma.$CampaignTaskPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CampaignTask that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignTaskFindFirstOrThrowArgs} args - Arguments to find a CampaignTask
     * @example
     * // Get one CampaignTask
     * const campaignTask = await prisma.campaignTask.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CampaignTaskFindFirstOrThrowArgs>(args?: SelectSubset<T, CampaignTaskFindFirstOrThrowArgs<ExtArgs>>): Prisma__CampaignTaskClient<$Result.GetResult<Prisma.$CampaignTaskPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CampaignTasks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignTaskFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CampaignTasks
     * const campaignTasks = await prisma.campaignTask.findMany()
     * 
     * // Get first 10 CampaignTasks
     * const campaignTasks = await prisma.campaignTask.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const campaignTaskWithIdOnly = await prisma.campaignTask.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CampaignTaskFindManyArgs>(args?: SelectSubset<T, CampaignTaskFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignTaskPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CampaignTask.
     * @param {CampaignTaskCreateArgs} args - Arguments to create a CampaignTask.
     * @example
     * // Create one CampaignTask
     * const CampaignTask = await prisma.campaignTask.create({
     *   data: {
     *     // ... data to create a CampaignTask
     *   }
     * })
     * 
     */
    create<T extends CampaignTaskCreateArgs>(args: SelectSubset<T, CampaignTaskCreateArgs<ExtArgs>>): Prisma__CampaignTaskClient<$Result.GetResult<Prisma.$CampaignTaskPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CampaignTasks.
     * @param {CampaignTaskCreateManyArgs} args - Arguments to create many CampaignTasks.
     * @example
     * // Create many CampaignTasks
     * const campaignTask = await prisma.campaignTask.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CampaignTaskCreateManyArgs>(args?: SelectSubset<T, CampaignTaskCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CampaignTasks and returns the data saved in the database.
     * @param {CampaignTaskCreateManyAndReturnArgs} args - Arguments to create many CampaignTasks.
     * @example
     * // Create many CampaignTasks
     * const campaignTask = await prisma.campaignTask.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CampaignTasks and only return the `id`
     * const campaignTaskWithIdOnly = await prisma.campaignTask.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CampaignTaskCreateManyAndReturnArgs>(args?: SelectSubset<T, CampaignTaskCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignTaskPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CampaignTask.
     * @param {CampaignTaskDeleteArgs} args - Arguments to delete one CampaignTask.
     * @example
     * // Delete one CampaignTask
     * const CampaignTask = await prisma.campaignTask.delete({
     *   where: {
     *     // ... filter to delete one CampaignTask
     *   }
     * })
     * 
     */
    delete<T extends CampaignTaskDeleteArgs>(args: SelectSubset<T, CampaignTaskDeleteArgs<ExtArgs>>): Prisma__CampaignTaskClient<$Result.GetResult<Prisma.$CampaignTaskPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CampaignTask.
     * @param {CampaignTaskUpdateArgs} args - Arguments to update one CampaignTask.
     * @example
     * // Update one CampaignTask
     * const campaignTask = await prisma.campaignTask.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CampaignTaskUpdateArgs>(args: SelectSubset<T, CampaignTaskUpdateArgs<ExtArgs>>): Prisma__CampaignTaskClient<$Result.GetResult<Prisma.$CampaignTaskPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CampaignTasks.
     * @param {CampaignTaskDeleteManyArgs} args - Arguments to filter CampaignTasks to delete.
     * @example
     * // Delete a few CampaignTasks
     * const { count } = await prisma.campaignTask.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CampaignTaskDeleteManyArgs>(args?: SelectSubset<T, CampaignTaskDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CampaignTasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignTaskUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CampaignTasks
     * const campaignTask = await prisma.campaignTask.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CampaignTaskUpdateManyArgs>(args: SelectSubset<T, CampaignTaskUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CampaignTask.
     * @param {CampaignTaskUpsertArgs} args - Arguments to update or create a CampaignTask.
     * @example
     * // Update or create a CampaignTask
     * const campaignTask = await prisma.campaignTask.upsert({
     *   create: {
     *     // ... data to create a CampaignTask
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CampaignTask we want to update
     *   }
     * })
     */
    upsert<T extends CampaignTaskUpsertArgs>(args: SelectSubset<T, CampaignTaskUpsertArgs<ExtArgs>>): Prisma__CampaignTaskClient<$Result.GetResult<Prisma.$CampaignTaskPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CampaignTasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignTaskCountArgs} args - Arguments to filter CampaignTasks to count.
     * @example
     * // Count the number of CampaignTasks
     * const count = await prisma.campaignTask.count({
     *   where: {
     *     // ... the filter for the CampaignTasks we want to count
     *   }
     * })
    **/
    count<T extends CampaignTaskCountArgs>(
      args?: Subset<T, CampaignTaskCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CampaignTaskCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CampaignTask.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignTaskAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CampaignTaskAggregateArgs>(args: Subset<T, CampaignTaskAggregateArgs>): Prisma.PrismaPromise<GetCampaignTaskAggregateType<T>>

    /**
     * Group by CampaignTask.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignTaskGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CampaignTaskGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CampaignTaskGroupByArgs['orderBy'] }
        : { orderBy?: CampaignTaskGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CampaignTaskGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCampaignTaskGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CampaignTask model
   */
  readonly fields: CampaignTaskFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CampaignTask.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CampaignTaskClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    campaign<T extends CampaignDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CampaignDefaultArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    assignment<T extends CampaignTask$assignmentArgs<ExtArgs> = {}>(args?: Subset<T, CampaignTask$assignmentArgs<ExtArgs>>): Prisma__CampaignAssignmentClient<$Result.GetResult<Prisma.$CampaignAssignmentPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    completedBy<T extends CampaignTask$completedByArgs<ExtArgs> = {}>(args?: Subset<T, CampaignTask$completedByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CampaignTask model
   */ 
  interface CampaignTaskFieldRefs {
    readonly id: FieldRef<"CampaignTask", 'String'>
    readonly campaignId: FieldRef<"CampaignTask", 'String'>
    readonly assignmentId: FieldRef<"CampaignTask", 'String'>
    readonly title: FieldRef<"CampaignTask", 'String'>
    readonly description: FieldRef<"CampaignTask", 'String'>
    readonly isCompleted: FieldRef<"CampaignTask", 'Boolean'>
    readonly completedById: FieldRef<"CampaignTask", 'String'>
    readonly dueDate: FieldRef<"CampaignTask", 'DateTime'>
    readonly createdAt: FieldRef<"CampaignTask", 'DateTime'>
    readonly updatedAt: FieldRef<"CampaignTask", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CampaignTask findUnique
   */
  export type CampaignTaskFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignTask
     */
    select?: CampaignTaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignTaskInclude<ExtArgs> | null
    /**
     * Filter, which CampaignTask to fetch.
     */
    where: CampaignTaskWhereUniqueInput
  }

  /**
   * CampaignTask findUniqueOrThrow
   */
  export type CampaignTaskFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignTask
     */
    select?: CampaignTaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignTaskInclude<ExtArgs> | null
    /**
     * Filter, which CampaignTask to fetch.
     */
    where: CampaignTaskWhereUniqueInput
  }

  /**
   * CampaignTask findFirst
   */
  export type CampaignTaskFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignTask
     */
    select?: CampaignTaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignTaskInclude<ExtArgs> | null
    /**
     * Filter, which CampaignTask to fetch.
     */
    where?: CampaignTaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignTasks to fetch.
     */
    orderBy?: CampaignTaskOrderByWithRelationInput | CampaignTaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CampaignTasks.
     */
    cursor?: CampaignTaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignTasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignTasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CampaignTasks.
     */
    distinct?: CampaignTaskScalarFieldEnum | CampaignTaskScalarFieldEnum[]
  }

  /**
   * CampaignTask findFirstOrThrow
   */
  export type CampaignTaskFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignTask
     */
    select?: CampaignTaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignTaskInclude<ExtArgs> | null
    /**
     * Filter, which CampaignTask to fetch.
     */
    where?: CampaignTaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignTasks to fetch.
     */
    orderBy?: CampaignTaskOrderByWithRelationInput | CampaignTaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CampaignTasks.
     */
    cursor?: CampaignTaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignTasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignTasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CampaignTasks.
     */
    distinct?: CampaignTaskScalarFieldEnum | CampaignTaskScalarFieldEnum[]
  }

  /**
   * CampaignTask findMany
   */
  export type CampaignTaskFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignTask
     */
    select?: CampaignTaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignTaskInclude<ExtArgs> | null
    /**
     * Filter, which CampaignTasks to fetch.
     */
    where?: CampaignTaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignTasks to fetch.
     */
    orderBy?: CampaignTaskOrderByWithRelationInput | CampaignTaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CampaignTasks.
     */
    cursor?: CampaignTaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignTasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignTasks.
     */
    skip?: number
    distinct?: CampaignTaskScalarFieldEnum | CampaignTaskScalarFieldEnum[]
  }

  /**
   * CampaignTask create
   */
  export type CampaignTaskCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignTask
     */
    select?: CampaignTaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignTaskInclude<ExtArgs> | null
    /**
     * The data needed to create a CampaignTask.
     */
    data: XOR<CampaignTaskCreateInput, CampaignTaskUncheckedCreateInput>
  }

  /**
   * CampaignTask createMany
   */
  export type CampaignTaskCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CampaignTasks.
     */
    data: CampaignTaskCreateManyInput | CampaignTaskCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CampaignTask createManyAndReturn
   */
  export type CampaignTaskCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignTask
     */
    select?: CampaignTaskSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CampaignTasks.
     */
    data: CampaignTaskCreateManyInput | CampaignTaskCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignTaskIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CampaignTask update
   */
  export type CampaignTaskUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignTask
     */
    select?: CampaignTaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignTaskInclude<ExtArgs> | null
    /**
     * The data needed to update a CampaignTask.
     */
    data: XOR<CampaignTaskUpdateInput, CampaignTaskUncheckedUpdateInput>
    /**
     * Choose, which CampaignTask to update.
     */
    where: CampaignTaskWhereUniqueInput
  }

  /**
   * CampaignTask updateMany
   */
  export type CampaignTaskUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CampaignTasks.
     */
    data: XOR<CampaignTaskUpdateManyMutationInput, CampaignTaskUncheckedUpdateManyInput>
    /**
     * Filter which CampaignTasks to update
     */
    where?: CampaignTaskWhereInput
  }

  /**
   * CampaignTask upsert
   */
  export type CampaignTaskUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignTask
     */
    select?: CampaignTaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignTaskInclude<ExtArgs> | null
    /**
     * The filter to search for the CampaignTask to update in case it exists.
     */
    where: CampaignTaskWhereUniqueInput
    /**
     * In case the CampaignTask found by the `where` argument doesn't exist, create a new CampaignTask with this data.
     */
    create: XOR<CampaignTaskCreateInput, CampaignTaskUncheckedCreateInput>
    /**
     * In case the CampaignTask was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CampaignTaskUpdateInput, CampaignTaskUncheckedUpdateInput>
  }

  /**
   * CampaignTask delete
   */
  export type CampaignTaskDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignTask
     */
    select?: CampaignTaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignTaskInclude<ExtArgs> | null
    /**
     * Filter which CampaignTask to delete.
     */
    where: CampaignTaskWhereUniqueInput
  }

  /**
   * CampaignTask deleteMany
   */
  export type CampaignTaskDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CampaignTasks to delete
     */
    where?: CampaignTaskWhereInput
  }

  /**
   * CampaignTask.assignment
   */
  export type CampaignTask$assignmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignAssignment
     */
    select?: CampaignAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignAssignmentInclude<ExtArgs> | null
    where?: CampaignAssignmentWhereInput
  }

  /**
   * CampaignTask.completedBy
   */
  export type CampaignTask$completedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * CampaignTask without action
   */
  export type CampaignTaskDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignTask
     */
    select?: CampaignTaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignTaskInclude<ExtArgs> | null
  }


  /**
   * Model CampaignActivity
   */

  export type AggregateCampaignActivity = {
    _count: CampaignActivityCountAggregateOutputType | null
    _min: CampaignActivityMinAggregateOutputType | null
    _max: CampaignActivityMaxAggregateOutputType | null
  }

  export type CampaignActivityMinAggregateOutputType = {
    id: string | null
    campaignId: string | null
    userId: string | null
    action: string | null
    createdAt: Date | null
  }

  export type CampaignActivityMaxAggregateOutputType = {
    id: string | null
    campaignId: string | null
    userId: string | null
    action: string | null
    createdAt: Date | null
  }

  export type CampaignActivityCountAggregateOutputType = {
    id: number
    campaignId: number
    userId: number
    action: number
    metadata: number
    createdAt: number
    _all: number
  }


  export type CampaignActivityMinAggregateInputType = {
    id?: true
    campaignId?: true
    userId?: true
    action?: true
    createdAt?: true
  }

  export type CampaignActivityMaxAggregateInputType = {
    id?: true
    campaignId?: true
    userId?: true
    action?: true
    createdAt?: true
  }

  export type CampaignActivityCountAggregateInputType = {
    id?: true
    campaignId?: true
    userId?: true
    action?: true
    metadata?: true
    createdAt?: true
    _all?: true
  }

  export type CampaignActivityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CampaignActivity to aggregate.
     */
    where?: CampaignActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignActivities to fetch.
     */
    orderBy?: CampaignActivityOrderByWithRelationInput | CampaignActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CampaignActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignActivities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignActivities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CampaignActivities
    **/
    _count?: true | CampaignActivityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CampaignActivityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CampaignActivityMaxAggregateInputType
  }

  export type GetCampaignActivityAggregateType<T extends CampaignActivityAggregateArgs> = {
        [P in keyof T & keyof AggregateCampaignActivity]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCampaignActivity[P]>
      : GetScalarType<T[P], AggregateCampaignActivity[P]>
  }




  export type CampaignActivityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CampaignActivityWhereInput
    orderBy?: CampaignActivityOrderByWithAggregationInput | CampaignActivityOrderByWithAggregationInput[]
    by: CampaignActivityScalarFieldEnum[] | CampaignActivityScalarFieldEnum
    having?: CampaignActivityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CampaignActivityCountAggregateInputType | true
    _min?: CampaignActivityMinAggregateInputType
    _max?: CampaignActivityMaxAggregateInputType
  }

  export type CampaignActivityGroupByOutputType = {
    id: string
    campaignId: string
    userId: string
    action: string
    metadata: JsonValue | null
    createdAt: Date
    _count: CampaignActivityCountAggregateOutputType | null
    _min: CampaignActivityMinAggregateOutputType | null
    _max: CampaignActivityMaxAggregateOutputType | null
  }

  type GetCampaignActivityGroupByPayload<T extends CampaignActivityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CampaignActivityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CampaignActivityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CampaignActivityGroupByOutputType[P]>
            : GetScalarType<T[P], CampaignActivityGroupByOutputType[P]>
        }
      >
    >


  export type CampaignActivitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    campaignId?: boolean
    userId?: boolean
    action?: boolean
    metadata?: boolean
    createdAt?: boolean
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["campaignActivity"]>

  export type CampaignActivitySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    campaignId?: boolean
    userId?: boolean
    action?: boolean
    metadata?: boolean
    createdAt?: boolean
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["campaignActivity"]>

  export type CampaignActivitySelectScalar = {
    id?: boolean
    campaignId?: boolean
    userId?: boolean
    action?: boolean
    metadata?: boolean
    createdAt?: boolean
  }

  export type CampaignActivityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type CampaignActivityIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $CampaignActivityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CampaignActivity"
    objects: {
      campaign: Prisma.$CampaignPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      campaignId: string
      userId: string
      action: string
      metadata: Prisma.JsonValue | null
      createdAt: Date
    }, ExtArgs["result"]["campaignActivity"]>
    composites: {}
  }

  type CampaignActivityGetPayload<S extends boolean | null | undefined | CampaignActivityDefaultArgs> = $Result.GetResult<Prisma.$CampaignActivityPayload, S>

  type CampaignActivityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CampaignActivityFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CampaignActivityCountAggregateInputType | true
    }

  export interface CampaignActivityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CampaignActivity'], meta: { name: 'CampaignActivity' } }
    /**
     * Find zero or one CampaignActivity that matches the filter.
     * @param {CampaignActivityFindUniqueArgs} args - Arguments to find a CampaignActivity
     * @example
     * // Get one CampaignActivity
     * const campaignActivity = await prisma.campaignActivity.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CampaignActivityFindUniqueArgs>(args: SelectSubset<T, CampaignActivityFindUniqueArgs<ExtArgs>>): Prisma__CampaignActivityClient<$Result.GetResult<Prisma.$CampaignActivityPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CampaignActivity that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CampaignActivityFindUniqueOrThrowArgs} args - Arguments to find a CampaignActivity
     * @example
     * // Get one CampaignActivity
     * const campaignActivity = await prisma.campaignActivity.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CampaignActivityFindUniqueOrThrowArgs>(args: SelectSubset<T, CampaignActivityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CampaignActivityClient<$Result.GetResult<Prisma.$CampaignActivityPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CampaignActivity that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignActivityFindFirstArgs} args - Arguments to find a CampaignActivity
     * @example
     * // Get one CampaignActivity
     * const campaignActivity = await prisma.campaignActivity.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CampaignActivityFindFirstArgs>(args?: SelectSubset<T, CampaignActivityFindFirstArgs<ExtArgs>>): Prisma__CampaignActivityClient<$Result.GetResult<Prisma.$CampaignActivityPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CampaignActivity that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignActivityFindFirstOrThrowArgs} args - Arguments to find a CampaignActivity
     * @example
     * // Get one CampaignActivity
     * const campaignActivity = await prisma.campaignActivity.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CampaignActivityFindFirstOrThrowArgs>(args?: SelectSubset<T, CampaignActivityFindFirstOrThrowArgs<ExtArgs>>): Prisma__CampaignActivityClient<$Result.GetResult<Prisma.$CampaignActivityPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CampaignActivities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignActivityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CampaignActivities
     * const campaignActivities = await prisma.campaignActivity.findMany()
     * 
     * // Get first 10 CampaignActivities
     * const campaignActivities = await prisma.campaignActivity.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const campaignActivityWithIdOnly = await prisma.campaignActivity.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CampaignActivityFindManyArgs>(args?: SelectSubset<T, CampaignActivityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignActivityPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CampaignActivity.
     * @param {CampaignActivityCreateArgs} args - Arguments to create a CampaignActivity.
     * @example
     * // Create one CampaignActivity
     * const CampaignActivity = await prisma.campaignActivity.create({
     *   data: {
     *     // ... data to create a CampaignActivity
     *   }
     * })
     * 
     */
    create<T extends CampaignActivityCreateArgs>(args: SelectSubset<T, CampaignActivityCreateArgs<ExtArgs>>): Prisma__CampaignActivityClient<$Result.GetResult<Prisma.$CampaignActivityPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CampaignActivities.
     * @param {CampaignActivityCreateManyArgs} args - Arguments to create many CampaignActivities.
     * @example
     * // Create many CampaignActivities
     * const campaignActivity = await prisma.campaignActivity.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CampaignActivityCreateManyArgs>(args?: SelectSubset<T, CampaignActivityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CampaignActivities and returns the data saved in the database.
     * @param {CampaignActivityCreateManyAndReturnArgs} args - Arguments to create many CampaignActivities.
     * @example
     * // Create many CampaignActivities
     * const campaignActivity = await prisma.campaignActivity.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CampaignActivities and only return the `id`
     * const campaignActivityWithIdOnly = await prisma.campaignActivity.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CampaignActivityCreateManyAndReturnArgs>(args?: SelectSubset<T, CampaignActivityCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignActivityPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CampaignActivity.
     * @param {CampaignActivityDeleteArgs} args - Arguments to delete one CampaignActivity.
     * @example
     * // Delete one CampaignActivity
     * const CampaignActivity = await prisma.campaignActivity.delete({
     *   where: {
     *     // ... filter to delete one CampaignActivity
     *   }
     * })
     * 
     */
    delete<T extends CampaignActivityDeleteArgs>(args: SelectSubset<T, CampaignActivityDeleteArgs<ExtArgs>>): Prisma__CampaignActivityClient<$Result.GetResult<Prisma.$CampaignActivityPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CampaignActivity.
     * @param {CampaignActivityUpdateArgs} args - Arguments to update one CampaignActivity.
     * @example
     * // Update one CampaignActivity
     * const campaignActivity = await prisma.campaignActivity.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CampaignActivityUpdateArgs>(args: SelectSubset<T, CampaignActivityUpdateArgs<ExtArgs>>): Prisma__CampaignActivityClient<$Result.GetResult<Prisma.$CampaignActivityPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CampaignActivities.
     * @param {CampaignActivityDeleteManyArgs} args - Arguments to filter CampaignActivities to delete.
     * @example
     * // Delete a few CampaignActivities
     * const { count } = await prisma.campaignActivity.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CampaignActivityDeleteManyArgs>(args?: SelectSubset<T, CampaignActivityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CampaignActivities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignActivityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CampaignActivities
     * const campaignActivity = await prisma.campaignActivity.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CampaignActivityUpdateManyArgs>(args: SelectSubset<T, CampaignActivityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CampaignActivity.
     * @param {CampaignActivityUpsertArgs} args - Arguments to update or create a CampaignActivity.
     * @example
     * // Update or create a CampaignActivity
     * const campaignActivity = await prisma.campaignActivity.upsert({
     *   create: {
     *     // ... data to create a CampaignActivity
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CampaignActivity we want to update
     *   }
     * })
     */
    upsert<T extends CampaignActivityUpsertArgs>(args: SelectSubset<T, CampaignActivityUpsertArgs<ExtArgs>>): Prisma__CampaignActivityClient<$Result.GetResult<Prisma.$CampaignActivityPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CampaignActivities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignActivityCountArgs} args - Arguments to filter CampaignActivities to count.
     * @example
     * // Count the number of CampaignActivities
     * const count = await prisma.campaignActivity.count({
     *   where: {
     *     // ... the filter for the CampaignActivities we want to count
     *   }
     * })
    **/
    count<T extends CampaignActivityCountArgs>(
      args?: Subset<T, CampaignActivityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CampaignActivityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CampaignActivity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignActivityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CampaignActivityAggregateArgs>(args: Subset<T, CampaignActivityAggregateArgs>): Prisma.PrismaPromise<GetCampaignActivityAggregateType<T>>

    /**
     * Group by CampaignActivity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignActivityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CampaignActivityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CampaignActivityGroupByArgs['orderBy'] }
        : { orderBy?: CampaignActivityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CampaignActivityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCampaignActivityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CampaignActivity model
   */
  readonly fields: CampaignActivityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CampaignActivity.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CampaignActivityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    campaign<T extends CampaignDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CampaignDefaultArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CampaignActivity model
   */ 
  interface CampaignActivityFieldRefs {
    readonly id: FieldRef<"CampaignActivity", 'String'>
    readonly campaignId: FieldRef<"CampaignActivity", 'String'>
    readonly userId: FieldRef<"CampaignActivity", 'String'>
    readonly action: FieldRef<"CampaignActivity", 'String'>
    readonly metadata: FieldRef<"CampaignActivity", 'Json'>
    readonly createdAt: FieldRef<"CampaignActivity", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CampaignActivity findUnique
   */
  export type CampaignActivityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignActivity
     */
    select?: CampaignActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignActivityInclude<ExtArgs> | null
    /**
     * Filter, which CampaignActivity to fetch.
     */
    where: CampaignActivityWhereUniqueInput
  }

  /**
   * CampaignActivity findUniqueOrThrow
   */
  export type CampaignActivityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignActivity
     */
    select?: CampaignActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignActivityInclude<ExtArgs> | null
    /**
     * Filter, which CampaignActivity to fetch.
     */
    where: CampaignActivityWhereUniqueInput
  }

  /**
   * CampaignActivity findFirst
   */
  export type CampaignActivityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignActivity
     */
    select?: CampaignActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignActivityInclude<ExtArgs> | null
    /**
     * Filter, which CampaignActivity to fetch.
     */
    where?: CampaignActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignActivities to fetch.
     */
    orderBy?: CampaignActivityOrderByWithRelationInput | CampaignActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CampaignActivities.
     */
    cursor?: CampaignActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignActivities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignActivities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CampaignActivities.
     */
    distinct?: CampaignActivityScalarFieldEnum | CampaignActivityScalarFieldEnum[]
  }

  /**
   * CampaignActivity findFirstOrThrow
   */
  export type CampaignActivityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignActivity
     */
    select?: CampaignActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignActivityInclude<ExtArgs> | null
    /**
     * Filter, which CampaignActivity to fetch.
     */
    where?: CampaignActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignActivities to fetch.
     */
    orderBy?: CampaignActivityOrderByWithRelationInput | CampaignActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CampaignActivities.
     */
    cursor?: CampaignActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignActivities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignActivities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CampaignActivities.
     */
    distinct?: CampaignActivityScalarFieldEnum | CampaignActivityScalarFieldEnum[]
  }

  /**
   * CampaignActivity findMany
   */
  export type CampaignActivityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignActivity
     */
    select?: CampaignActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignActivityInclude<ExtArgs> | null
    /**
     * Filter, which CampaignActivities to fetch.
     */
    where?: CampaignActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignActivities to fetch.
     */
    orderBy?: CampaignActivityOrderByWithRelationInput | CampaignActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CampaignActivities.
     */
    cursor?: CampaignActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignActivities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignActivities.
     */
    skip?: number
    distinct?: CampaignActivityScalarFieldEnum | CampaignActivityScalarFieldEnum[]
  }

  /**
   * CampaignActivity create
   */
  export type CampaignActivityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignActivity
     */
    select?: CampaignActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignActivityInclude<ExtArgs> | null
    /**
     * The data needed to create a CampaignActivity.
     */
    data: XOR<CampaignActivityCreateInput, CampaignActivityUncheckedCreateInput>
  }

  /**
   * CampaignActivity createMany
   */
  export type CampaignActivityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CampaignActivities.
     */
    data: CampaignActivityCreateManyInput | CampaignActivityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CampaignActivity createManyAndReturn
   */
  export type CampaignActivityCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignActivity
     */
    select?: CampaignActivitySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CampaignActivities.
     */
    data: CampaignActivityCreateManyInput | CampaignActivityCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignActivityIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CampaignActivity update
   */
  export type CampaignActivityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignActivity
     */
    select?: CampaignActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignActivityInclude<ExtArgs> | null
    /**
     * The data needed to update a CampaignActivity.
     */
    data: XOR<CampaignActivityUpdateInput, CampaignActivityUncheckedUpdateInput>
    /**
     * Choose, which CampaignActivity to update.
     */
    where: CampaignActivityWhereUniqueInput
  }

  /**
   * CampaignActivity updateMany
   */
  export type CampaignActivityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CampaignActivities.
     */
    data: XOR<CampaignActivityUpdateManyMutationInput, CampaignActivityUncheckedUpdateManyInput>
    /**
     * Filter which CampaignActivities to update
     */
    where?: CampaignActivityWhereInput
  }

  /**
   * CampaignActivity upsert
   */
  export type CampaignActivityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignActivity
     */
    select?: CampaignActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignActivityInclude<ExtArgs> | null
    /**
     * The filter to search for the CampaignActivity to update in case it exists.
     */
    where: CampaignActivityWhereUniqueInput
    /**
     * In case the CampaignActivity found by the `where` argument doesn't exist, create a new CampaignActivity with this data.
     */
    create: XOR<CampaignActivityCreateInput, CampaignActivityUncheckedCreateInput>
    /**
     * In case the CampaignActivity was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CampaignActivityUpdateInput, CampaignActivityUncheckedUpdateInput>
  }

  /**
   * CampaignActivity delete
   */
  export type CampaignActivityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignActivity
     */
    select?: CampaignActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignActivityInclude<ExtArgs> | null
    /**
     * Filter which CampaignActivity to delete.
     */
    where: CampaignActivityWhereUniqueInput
  }

  /**
   * CampaignActivity deleteMany
   */
  export type CampaignActivityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CampaignActivities to delete
     */
    where?: CampaignActivityWhereInput
  }

  /**
   * CampaignActivity without action
   */
  export type CampaignActivityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignActivity
     */
    select?: CampaignActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignActivityInclude<ExtArgs> | null
  }


  /**
   * Model AuditLog
   */

  export type AggregateAuditLog = {
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  export type AuditLogMinAggregateOutputType = {
    id: string | null
    actorId: string | null
    action: string | null
    entityType: string | null
    entityId: string | null
    createdAt: Date | null
  }

  export type AuditLogMaxAggregateOutputType = {
    id: string | null
    actorId: string | null
    action: string | null
    entityType: string | null
    entityId: string | null
    createdAt: Date | null
  }

  export type AuditLogCountAggregateOutputType = {
    id: number
    actorId: number
    action: number
    entityType: number
    entityId: number
    changes: number
    createdAt: number
    _all: number
  }


  export type AuditLogMinAggregateInputType = {
    id?: true
    actorId?: true
    action?: true
    entityType?: true
    entityId?: true
    createdAt?: true
  }

  export type AuditLogMaxAggregateInputType = {
    id?: true
    actorId?: true
    action?: true
    entityType?: true
    entityId?: true
    createdAt?: true
  }

  export type AuditLogCountAggregateInputType = {
    id?: true
    actorId?: true
    action?: true
    entityType?: true
    entityId?: true
    changes?: true
    createdAt?: true
    _all?: true
  }

  export type AuditLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLog to aggregate.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AuditLogs
    **/
    _count?: true | AuditLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuditLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuditLogMaxAggregateInputType
  }

  export type GetAuditLogAggregateType<T extends AuditLogAggregateArgs> = {
        [P in keyof T & keyof AggregateAuditLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuditLog[P]>
      : GetScalarType<T[P], AggregateAuditLog[P]>
  }




  export type AuditLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithAggregationInput | AuditLogOrderByWithAggregationInput[]
    by: AuditLogScalarFieldEnum[] | AuditLogScalarFieldEnum
    having?: AuditLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuditLogCountAggregateInputType | true
    _min?: AuditLogMinAggregateInputType
    _max?: AuditLogMaxAggregateInputType
  }

  export type AuditLogGroupByOutputType = {
    id: string
    actorId: string
    action: string
    entityType: string
    entityId: string
    changes: JsonValue | null
    createdAt: Date
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  type GetAuditLogGroupByPayload<T extends AuditLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuditLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuditLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
            : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
        }
      >
    >


  export type AuditLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    actorId?: boolean
    action?: boolean
    entityType?: boolean
    entityId?: boolean
    changes?: boolean
    createdAt?: boolean
    actor?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    actorId?: boolean
    action?: boolean
    entityType?: boolean
    entityId?: boolean
    changes?: boolean
    createdAt?: boolean
    actor?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectScalar = {
    id?: boolean
    actorId?: boolean
    action?: boolean
    entityType?: boolean
    entityId?: boolean
    changes?: boolean
    createdAt?: boolean
  }

  export type AuditLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    actor?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AuditLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    actor?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AuditLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AuditLog"
    objects: {
      actor: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      actorId: string
      action: string
      entityType: string
      entityId: string
      changes: Prisma.JsonValue | null
      createdAt: Date
    }, ExtArgs["result"]["auditLog"]>
    composites: {}
  }

  type AuditLogGetPayload<S extends boolean | null | undefined | AuditLogDefaultArgs> = $Result.GetResult<Prisma.$AuditLogPayload, S>

  type AuditLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AuditLogFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AuditLogCountAggregateInputType | true
    }

  export interface AuditLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AuditLog'], meta: { name: 'AuditLog' } }
    /**
     * Find zero or one AuditLog that matches the filter.
     * @param {AuditLogFindUniqueArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuditLogFindUniqueArgs>(args: SelectSubset<T, AuditLogFindUniqueArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AuditLog that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AuditLogFindUniqueOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuditLogFindUniqueOrThrowArgs>(args: SelectSubset<T, AuditLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AuditLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuditLogFindFirstArgs>(args?: SelectSubset<T, AuditLogFindFirstArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AuditLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuditLogFindFirstOrThrowArgs>(args?: SelectSubset<T, AuditLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AuditLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuditLogs
     * const auditLogs = await prisma.auditLog.findMany()
     * 
     * // Get first 10 AuditLogs
     * const auditLogs = await prisma.auditLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuditLogFindManyArgs>(args?: SelectSubset<T, AuditLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AuditLog.
     * @param {AuditLogCreateArgs} args - Arguments to create a AuditLog.
     * @example
     * // Create one AuditLog
     * const AuditLog = await prisma.auditLog.create({
     *   data: {
     *     // ... data to create a AuditLog
     *   }
     * })
     * 
     */
    create<T extends AuditLogCreateArgs>(args: SelectSubset<T, AuditLogCreateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AuditLogs.
     * @param {AuditLogCreateManyArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuditLogCreateManyArgs>(args?: SelectSubset<T, AuditLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AuditLogs and returns the data saved in the database.
     * @param {AuditLogCreateManyAndReturnArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AuditLogCreateManyAndReturnArgs>(args?: SelectSubset<T, AuditLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AuditLog.
     * @param {AuditLogDeleteArgs} args - Arguments to delete one AuditLog.
     * @example
     * // Delete one AuditLog
     * const AuditLog = await prisma.auditLog.delete({
     *   where: {
     *     // ... filter to delete one AuditLog
     *   }
     * })
     * 
     */
    delete<T extends AuditLogDeleteArgs>(args: SelectSubset<T, AuditLogDeleteArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AuditLog.
     * @param {AuditLogUpdateArgs} args - Arguments to update one AuditLog.
     * @example
     * // Update one AuditLog
     * const auditLog = await prisma.auditLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuditLogUpdateArgs>(args: SelectSubset<T, AuditLogUpdateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AuditLogs.
     * @param {AuditLogDeleteManyArgs} args - Arguments to filter AuditLogs to delete.
     * @example
     * // Delete a few AuditLogs
     * const { count } = await prisma.auditLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuditLogDeleteManyArgs>(args?: SelectSubset<T, AuditLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuditLogUpdateManyArgs>(args: SelectSubset<T, AuditLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AuditLog.
     * @param {AuditLogUpsertArgs} args - Arguments to update or create a AuditLog.
     * @example
     * // Update or create a AuditLog
     * const auditLog = await prisma.auditLog.upsert({
     *   create: {
     *     // ... data to create a AuditLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuditLog we want to update
     *   }
     * })
     */
    upsert<T extends AuditLogUpsertArgs>(args: SelectSubset<T, AuditLogUpsertArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogCountArgs} args - Arguments to filter AuditLogs to count.
     * @example
     * // Count the number of AuditLogs
     * const count = await prisma.auditLog.count({
     *   where: {
     *     // ... the filter for the AuditLogs we want to count
     *   }
     * })
    **/
    count<T extends AuditLogCountArgs>(
      args?: Subset<T, AuditLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuditLogAggregateArgs>(args: Subset<T, AuditLogAggregateArgs>): Prisma.PrismaPromise<GetAuditLogAggregateType<T>>

    /**
     * Group by AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuditLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuditLogGroupByArgs['orderBy'] }
        : { orderBy?: AuditLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuditLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuditLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AuditLog model
   */
  readonly fields: AuditLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AuditLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuditLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    actor<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AuditLog model
   */ 
  interface AuditLogFieldRefs {
    readonly id: FieldRef<"AuditLog", 'String'>
    readonly actorId: FieldRef<"AuditLog", 'String'>
    readonly action: FieldRef<"AuditLog", 'String'>
    readonly entityType: FieldRef<"AuditLog", 'String'>
    readonly entityId: FieldRef<"AuditLog", 'String'>
    readonly changes: FieldRef<"AuditLog", 'Json'>
    readonly createdAt: FieldRef<"AuditLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AuditLog findUnique
   */
  export type AuditLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findUniqueOrThrow
   */
  export type AuditLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findFirst
   */
  export type AuditLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findFirstOrThrow
   */
  export type AuditLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findMany
   */
  export type AuditLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLogs to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog create
   */
  export type AuditLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to create a AuditLog.
     */
    data: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
  }

  /**
   * AuditLog createMany
   */
  export type AuditLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AuditLog createManyAndReturn
   */
  export type AuditLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditLog update
   */
  export type AuditLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to update a AuditLog.
     */
    data: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
    /**
     * Choose, which AuditLog to update.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog updateMany
   */
  export type AuditLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
  }

  /**
   * AuditLog upsert
   */
  export type AuditLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The filter to search for the AuditLog to update in case it exists.
     */
    where: AuditLogWhereUniqueInput
    /**
     * In case the AuditLog found by the `where` argument doesn't exist, create a new AuditLog with this data.
     */
    create: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
    /**
     * In case the AuditLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
  }

  /**
   * AuditLog delete
   */
  export type AuditLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter which AuditLog to delete.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog deleteMany
   */
  export type AuditLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLogs to delete
     */
    where?: AuditLogWhereInput
  }

  /**
   * AuditLog without action
   */
  export type AuditLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const TeamScalarFieldEnum: {
    id: 'id',
    name: 'name',
    color: 'color',
    yearlyTarget: 'yearlyTarget',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TeamScalarFieldEnum = (typeof TeamScalarFieldEnum)[keyof typeof TeamScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    passwordHash: 'passwordHash',
    name: 'name',
    role: 'role',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const EmployeeProfileScalarFieldEnum: {
    id: 'id',
    teamId: 'teamId',
    managerId: 'managerId',
    level: 'level',
    yearlyTarget: 'yearlyTarget',
    isActive: 'isActive',
    deletedAt: 'deletedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EmployeeProfileScalarFieldEnum = (typeof EmployeeProfileScalarFieldEnum)[keyof typeof EmployeeProfileScalarFieldEnum]


  export const DailyEntryScalarFieldEnum: {
    id: 'id',
    employeeId: 'employeeId',
    date: 'date',
    clientName: 'clientName',
    placementType: 'placementType',
    revenue: 'revenue',
    marginPercent: 'marginPercent',
    billingStatus: 'billingStatus',
    doi: 'doi',
    doj: 'doj',
    remarks: 'remarks',
    createdAt: 'createdAt'
  };

  export type DailyEntryScalarFieldEnum = (typeof DailyEntryScalarFieldEnum)[keyof typeof DailyEntryScalarFieldEnum]


  export const PlacementScalarFieldEnum: {
    id: 'id',
    employeeId: 'employeeId',
    candidateName: 'candidateName',
    clientName: 'clientName',
    doi: 'doi',
    doj: 'doj',
    daysCompleted: 'daysCompleted',
    placementType: 'placementType',
    billedHours: 'billedHours',
    marginPercent: 'marginPercent',
    revenue: 'revenue',
    billingStatus: 'billingStatus',
    incentivePayoutEta: 'incentivePayoutEta',
    incentiveAmountInr: 'incentiveAmountInr',
    incentivePaid: 'incentivePaid',
    qualifier: 'qualifier',
    createdAt: 'createdAt'
  };

  export type PlacementScalarFieldEnum = (typeof PlacementScalarFieldEnum)[keyof typeof PlacementScalarFieldEnum]


  export const MonthlyBillingScalarFieldEnum: {
    id: 'id',
    placementId: 'placementId',
    month: 'month',
    hours: 'hours',
    status: 'status'
  };

  export type MonthlyBillingScalarFieldEnum = (typeof MonthlyBillingScalarFieldEnum)[keyof typeof MonthlyBillingScalarFieldEnum]


  export const IncentiveScalarFieldEnum: {
    id: 'id',
    employeeId: 'employeeId',
    periodStart: 'periodStart',
    periodEnd: 'periodEnd',
    revenueTotal: 'revenueTotal',
    slabName: 'slabName',
    amountUsd: 'amountUsd',
    amountInr: 'amountInr',
    createdAt: 'createdAt'
  };

  export type IncentiveScalarFieldEnum = (typeof IncentiveScalarFieldEnum)[keyof typeof IncentiveScalarFieldEnum]


  export const RefreshTokenScalarFieldEnum: {
    id: 'id',
    token: 'token',
    userId: 'userId',
    isRevoked: 'isRevoked',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt'
  };

  export type RefreshTokenScalarFieldEnum = (typeof RefreshTokenScalarFieldEnum)[keyof typeof RefreshTokenScalarFieldEnum]


  export const CampaignScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    objective: 'objective',
    status: 'status',
    targetAmount: 'targetAmount',
    startDate: 'startDate',
    endDate: 'endDate',
    createdById: 'createdById',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CampaignScalarFieldEnum = (typeof CampaignScalarFieldEnum)[keyof typeof CampaignScalarFieldEnum]


  export const CampaignImageScalarFieldEnum: {
    id: 'id',
    campaignId: 'campaignId',
    url: 'url',
    title: 'title',
    description: 'description',
    uploadedById: 'uploadedById',
    createdAt: 'createdAt'
  };

  export type CampaignImageScalarFieldEnum = (typeof CampaignImageScalarFieldEnum)[keyof typeof CampaignImageScalarFieldEnum]


  export const CampaignTeamLeadScalarFieldEnum: {
    id: 'id',
    campaignId: 'campaignId',
    userId: 'userId',
    createdAt: 'createdAt'
  };

  export type CampaignTeamLeadScalarFieldEnum = (typeof CampaignTeamLeadScalarFieldEnum)[keyof typeof CampaignTeamLeadScalarFieldEnum]


  export const CampaignAssignmentScalarFieldEnum: {
    id: 'id',
    campaignId: 'campaignId',
    userId: 'userId',
    role: 'role',
    targetAmount: 'targetAmount',
    progressPercent: 'progressPercent',
    isCompleted: 'isCompleted',
    completedAt: 'completedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CampaignAssignmentScalarFieldEnum = (typeof CampaignAssignmentScalarFieldEnum)[keyof typeof CampaignAssignmentScalarFieldEnum]


  export const CampaignTaskScalarFieldEnum: {
    id: 'id',
    campaignId: 'campaignId',
    assignmentId: 'assignmentId',
    title: 'title',
    description: 'description',
    isCompleted: 'isCompleted',
    completedById: 'completedById',
    dueDate: 'dueDate',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CampaignTaskScalarFieldEnum = (typeof CampaignTaskScalarFieldEnum)[keyof typeof CampaignTaskScalarFieldEnum]


  export const CampaignActivityScalarFieldEnum: {
    id: 'id',
    campaignId: 'campaignId',
    userId: 'userId',
    action: 'action',
    metadata: 'metadata',
    createdAt: 'createdAt'
  };

  export type CampaignActivityScalarFieldEnum = (typeof CampaignActivityScalarFieldEnum)[keyof typeof CampaignActivityScalarFieldEnum]


  export const AuditLogScalarFieldEnum: {
    id: 'id',
    actorId: 'actorId',
    action: 'action',
    entityType: 'entityType',
    entityId: 'entityId',
    changes: 'changes',
    createdAt: 'createdAt'
  };

  export type AuditLogScalarFieldEnum = (typeof AuditLogScalarFieldEnum)[keyof typeof AuditLogScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Role'
   */
  export type EnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role'>
    


  /**
   * Reference to a field of type 'Role[]'
   */
  export type ListEnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role[]'>
    


  /**
   * Reference to a field of type 'PlacementType'
   */
  export type EnumPlacementTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PlacementType'>
    


  /**
   * Reference to a field of type 'PlacementType[]'
   */
  export type ListEnumPlacementTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PlacementType[]'>
    


  /**
   * Reference to a field of type 'BillingStatus'
   */
  export type EnumBillingStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BillingStatus'>
    


  /**
   * Reference to a field of type 'BillingStatus[]'
   */
  export type ListEnumBillingStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BillingStatus[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'CampaignStatus'
   */
  export type EnumCampaignStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CampaignStatus'>
    


  /**
   * Reference to a field of type 'CampaignStatus[]'
   */
  export type ListEnumCampaignStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CampaignStatus[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type TeamWhereInput = {
    AND?: TeamWhereInput | TeamWhereInput[]
    OR?: TeamWhereInput[]
    NOT?: TeamWhereInput | TeamWhereInput[]
    id?: StringFilter<"Team"> | string
    name?: StringFilter<"Team"> | string
    color?: StringNullableFilter<"Team"> | string | null
    yearlyTarget?: DecimalFilter<"Team"> | Decimal | DecimalJsLike | number | string
    isActive?: BoolFilter<"Team"> | boolean
    createdAt?: DateTimeFilter<"Team"> | Date | string
    updatedAt?: DateTimeFilter<"Team"> | Date | string
    employees?: EmployeeProfileListRelationFilter
  }

  export type TeamOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    color?: SortOrderInput | SortOrder
    yearlyTarget?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    employees?: EmployeeProfileOrderByRelationAggregateInput
  }

  export type TeamWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: TeamWhereInput | TeamWhereInput[]
    OR?: TeamWhereInput[]
    NOT?: TeamWhereInput | TeamWhereInput[]
    color?: StringNullableFilter<"Team"> | string | null
    yearlyTarget?: DecimalFilter<"Team"> | Decimal | DecimalJsLike | number | string
    isActive?: BoolFilter<"Team"> | boolean
    createdAt?: DateTimeFilter<"Team"> | Date | string
    updatedAt?: DateTimeFilter<"Team"> | Date | string
    employees?: EmployeeProfileListRelationFilter
  }, "id" | "name">

  export type TeamOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    color?: SortOrderInput | SortOrder
    yearlyTarget?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TeamCountOrderByAggregateInput
    _avg?: TeamAvgOrderByAggregateInput
    _max?: TeamMaxOrderByAggregateInput
    _min?: TeamMinOrderByAggregateInput
    _sum?: TeamSumOrderByAggregateInput
  }

  export type TeamScalarWhereWithAggregatesInput = {
    AND?: TeamScalarWhereWithAggregatesInput | TeamScalarWhereWithAggregatesInput[]
    OR?: TeamScalarWhereWithAggregatesInput[]
    NOT?: TeamScalarWhereWithAggregatesInput | TeamScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Team"> | string
    name?: StringWithAggregatesFilter<"Team"> | string
    color?: StringNullableWithAggregatesFilter<"Team"> | string | null
    yearlyTarget?: DecimalWithAggregatesFilter<"Team"> | Decimal | DecimalJsLike | number | string
    isActive?: BoolWithAggregatesFilter<"Team"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Team"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Team"> | Date | string
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    passwordHash?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    role?: EnumRoleFilter<"User"> | $Enums.Role
    isActive?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    employeeProfile?: XOR<EmployeeProfileNullableRelationFilter, EmployeeProfileWhereInput> | null
    refreshTokens?: RefreshTokenListRelationFilter
    dailyEntries?: DailyEntryListRelationFilter
    placements?: PlacementListRelationFilter
    incentives?: IncentiveListRelationFilter
    campaignAssignments?: CampaignAssignmentListRelationFilter
    campaignTeamLeads?: CampaignTeamLeadListRelationFilter
    campaignActivities?: CampaignActivityListRelationFilter
    createdCampaigns?: CampaignListRelationFilter
    uploadedCampaignImages?: CampaignImageListRelationFilter
    completedCampaignTasks?: CampaignTaskListRelationFilter
    leadEmployees?: EmployeeProfileListRelationFilter
    auditLogs?: AuditLogListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    name?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    employeeProfile?: EmployeeProfileOrderByWithRelationInput
    refreshTokens?: RefreshTokenOrderByRelationAggregateInput
    dailyEntries?: DailyEntryOrderByRelationAggregateInput
    placements?: PlacementOrderByRelationAggregateInput
    incentives?: IncentiveOrderByRelationAggregateInput
    campaignAssignments?: CampaignAssignmentOrderByRelationAggregateInput
    campaignTeamLeads?: CampaignTeamLeadOrderByRelationAggregateInput
    campaignActivities?: CampaignActivityOrderByRelationAggregateInput
    createdCampaigns?: CampaignOrderByRelationAggregateInput
    uploadedCampaignImages?: CampaignImageOrderByRelationAggregateInput
    completedCampaignTasks?: CampaignTaskOrderByRelationAggregateInput
    leadEmployees?: EmployeeProfileOrderByRelationAggregateInput
    auditLogs?: AuditLogOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    passwordHash?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    role?: EnumRoleFilter<"User"> | $Enums.Role
    isActive?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    employeeProfile?: XOR<EmployeeProfileNullableRelationFilter, EmployeeProfileWhereInput> | null
    refreshTokens?: RefreshTokenListRelationFilter
    dailyEntries?: DailyEntryListRelationFilter
    placements?: PlacementListRelationFilter
    incentives?: IncentiveListRelationFilter
    campaignAssignments?: CampaignAssignmentListRelationFilter
    campaignTeamLeads?: CampaignTeamLeadListRelationFilter
    campaignActivities?: CampaignActivityListRelationFilter
    createdCampaigns?: CampaignListRelationFilter
    uploadedCampaignImages?: CampaignImageListRelationFilter
    completedCampaignTasks?: CampaignTaskListRelationFilter
    leadEmployees?: EmployeeProfileListRelationFilter
    auditLogs?: AuditLogListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    name?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    passwordHash?: StringWithAggregatesFilter<"User"> | string
    name?: StringWithAggregatesFilter<"User"> | string
    role?: EnumRoleWithAggregatesFilter<"User"> | $Enums.Role
    isActive?: BoolWithAggregatesFilter<"User"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type EmployeeProfileWhereInput = {
    AND?: EmployeeProfileWhereInput | EmployeeProfileWhereInput[]
    OR?: EmployeeProfileWhereInput[]
    NOT?: EmployeeProfileWhereInput | EmployeeProfileWhereInput[]
    id?: StringFilter<"EmployeeProfile"> | string
    teamId?: StringNullableFilter<"EmployeeProfile"> | string | null
    managerId?: StringNullableFilter<"EmployeeProfile"> | string | null
    level?: StringNullableFilter<"EmployeeProfile"> | string | null
    yearlyTarget?: DecimalFilter<"EmployeeProfile"> | Decimal | DecimalJsLike | number | string
    isActive?: BoolFilter<"EmployeeProfile"> | boolean
    deletedAt?: DateTimeNullableFilter<"EmployeeProfile"> | Date | string | null
    createdAt?: DateTimeFilter<"EmployeeProfile"> | Date | string
    updatedAt?: DateTimeFilter<"EmployeeProfile"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    team?: XOR<TeamNullableRelationFilter, TeamWhereInput> | null
    manager?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }

  export type EmployeeProfileOrderByWithRelationInput = {
    id?: SortOrder
    teamId?: SortOrderInput | SortOrder
    managerId?: SortOrderInput | SortOrder
    level?: SortOrderInput | SortOrder
    yearlyTarget?: SortOrder
    isActive?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    team?: TeamOrderByWithRelationInput
    manager?: UserOrderByWithRelationInput
  }

  export type EmployeeProfileWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: EmployeeProfileWhereInput | EmployeeProfileWhereInput[]
    OR?: EmployeeProfileWhereInput[]
    NOT?: EmployeeProfileWhereInput | EmployeeProfileWhereInput[]
    teamId?: StringNullableFilter<"EmployeeProfile"> | string | null
    managerId?: StringNullableFilter<"EmployeeProfile"> | string | null
    level?: StringNullableFilter<"EmployeeProfile"> | string | null
    yearlyTarget?: DecimalFilter<"EmployeeProfile"> | Decimal | DecimalJsLike | number | string
    isActive?: BoolFilter<"EmployeeProfile"> | boolean
    deletedAt?: DateTimeNullableFilter<"EmployeeProfile"> | Date | string | null
    createdAt?: DateTimeFilter<"EmployeeProfile"> | Date | string
    updatedAt?: DateTimeFilter<"EmployeeProfile"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    team?: XOR<TeamNullableRelationFilter, TeamWhereInput> | null
    manager?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }, "id">

  export type EmployeeProfileOrderByWithAggregationInput = {
    id?: SortOrder
    teamId?: SortOrderInput | SortOrder
    managerId?: SortOrderInput | SortOrder
    level?: SortOrderInput | SortOrder
    yearlyTarget?: SortOrder
    isActive?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EmployeeProfileCountOrderByAggregateInput
    _avg?: EmployeeProfileAvgOrderByAggregateInput
    _max?: EmployeeProfileMaxOrderByAggregateInput
    _min?: EmployeeProfileMinOrderByAggregateInput
    _sum?: EmployeeProfileSumOrderByAggregateInput
  }

  export type EmployeeProfileScalarWhereWithAggregatesInput = {
    AND?: EmployeeProfileScalarWhereWithAggregatesInput | EmployeeProfileScalarWhereWithAggregatesInput[]
    OR?: EmployeeProfileScalarWhereWithAggregatesInput[]
    NOT?: EmployeeProfileScalarWhereWithAggregatesInput | EmployeeProfileScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EmployeeProfile"> | string
    teamId?: StringNullableWithAggregatesFilter<"EmployeeProfile"> | string | null
    managerId?: StringNullableWithAggregatesFilter<"EmployeeProfile"> | string | null
    level?: StringNullableWithAggregatesFilter<"EmployeeProfile"> | string | null
    yearlyTarget?: DecimalWithAggregatesFilter<"EmployeeProfile"> | Decimal | DecimalJsLike | number | string
    isActive?: BoolWithAggregatesFilter<"EmployeeProfile"> | boolean
    deletedAt?: DateTimeNullableWithAggregatesFilter<"EmployeeProfile"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"EmployeeProfile"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"EmployeeProfile"> | Date | string
  }

  export type DailyEntryWhereInput = {
    AND?: DailyEntryWhereInput | DailyEntryWhereInput[]
    OR?: DailyEntryWhereInput[]
    NOT?: DailyEntryWhereInput | DailyEntryWhereInput[]
    id?: StringFilter<"DailyEntry"> | string
    employeeId?: StringFilter<"DailyEntry"> | string
    date?: DateTimeFilter<"DailyEntry"> | Date | string
    clientName?: StringFilter<"DailyEntry"> | string
    placementType?: EnumPlacementTypeFilter<"DailyEntry"> | $Enums.PlacementType
    revenue?: DecimalFilter<"DailyEntry"> | Decimal | DecimalJsLike | number | string
    marginPercent?: DecimalFilter<"DailyEntry"> | Decimal | DecimalJsLike | number | string
    billingStatus?: EnumBillingStatusFilter<"DailyEntry"> | $Enums.BillingStatus
    doi?: DateTimeFilter<"DailyEntry"> | Date | string
    doj?: DateTimeFilter<"DailyEntry"> | Date | string
    remarks?: StringNullableFilter<"DailyEntry"> | string | null
    createdAt?: DateTimeFilter<"DailyEntry"> | Date | string
    employee?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type DailyEntryOrderByWithRelationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    date?: SortOrder
    clientName?: SortOrder
    placementType?: SortOrder
    revenue?: SortOrder
    marginPercent?: SortOrder
    billingStatus?: SortOrder
    doi?: SortOrder
    doj?: SortOrder
    remarks?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    employee?: UserOrderByWithRelationInput
  }

  export type DailyEntryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DailyEntryWhereInput | DailyEntryWhereInput[]
    OR?: DailyEntryWhereInput[]
    NOT?: DailyEntryWhereInput | DailyEntryWhereInput[]
    employeeId?: StringFilter<"DailyEntry"> | string
    date?: DateTimeFilter<"DailyEntry"> | Date | string
    clientName?: StringFilter<"DailyEntry"> | string
    placementType?: EnumPlacementTypeFilter<"DailyEntry"> | $Enums.PlacementType
    revenue?: DecimalFilter<"DailyEntry"> | Decimal | DecimalJsLike | number | string
    marginPercent?: DecimalFilter<"DailyEntry"> | Decimal | DecimalJsLike | number | string
    billingStatus?: EnumBillingStatusFilter<"DailyEntry"> | $Enums.BillingStatus
    doi?: DateTimeFilter<"DailyEntry"> | Date | string
    doj?: DateTimeFilter<"DailyEntry"> | Date | string
    remarks?: StringNullableFilter<"DailyEntry"> | string | null
    createdAt?: DateTimeFilter<"DailyEntry"> | Date | string
    employee?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type DailyEntryOrderByWithAggregationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    date?: SortOrder
    clientName?: SortOrder
    placementType?: SortOrder
    revenue?: SortOrder
    marginPercent?: SortOrder
    billingStatus?: SortOrder
    doi?: SortOrder
    doj?: SortOrder
    remarks?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: DailyEntryCountOrderByAggregateInput
    _avg?: DailyEntryAvgOrderByAggregateInput
    _max?: DailyEntryMaxOrderByAggregateInput
    _min?: DailyEntryMinOrderByAggregateInput
    _sum?: DailyEntrySumOrderByAggregateInput
  }

  export type DailyEntryScalarWhereWithAggregatesInput = {
    AND?: DailyEntryScalarWhereWithAggregatesInput | DailyEntryScalarWhereWithAggregatesInput[]
    OR?: DailyEntryScalarWhereWithAggregatesInput[]
    NOT?: DailyEntryScalarWhereWithAggregatesInput | DailyEntryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DailyEntry"> | string
    employeeId?: StringWithAggregatesFilter<"DailyEntry"> | string
    date?: DateTimeWithAggregatesFilter<"DailyEntry"> | Date | string
    clientName?: StringWithAggregatesFilter<"DailyEntry"> | string
    placementType?: EnumPlacementTypeWithAggregatesFilter<"DailyEntry"> | $Enums.PlacementType
    revenue?: DecimalWithAggregatesFilter<"DailyEntry"> | Decimal | DecimalJsLike | number | string
    marginPercent?: DecimalWithAggregatesFilter<"DailyEntry"> | Decimal | DecimalJsLike | number | string
    billingStatus?: EnumBillingStatusWithAggregatesFilter<"DailyEntry"> | $Enums.BillingStatus
    doi?: DateTimeWithAggregatesFilter<"DailyEntry"> | Date | string
    doj?: DateTimeWithAggregatesFilter<"DailyEntry"> | Date | string
    remarks?: StringNullableWithAggregatesFilter<"DailyEntry"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"DailyEntry"> | Date | string
  }

  export type PlacementWhereInput = {
    AND?: PlacementWhereInput | PlacementWhereInput[]
    OR?: PlacementWhereInput[]
    NOT?: PlacementWhereInput | PlacementWhereInput[]
    id?: StringFilter<"Placement"> | string
    employeeId?: StringFilter<"Placement"> | string
    candidateName?: StringFilter<"Placement"> | string
    clientName?: StringFilter<"Placement"> | string
    doi?: DateTimeFilter<"Placement"> | Date | string
    doj?: DateTimeFilter<"Placement"> | Date | string
    daysCompleted?: IntFilter<"Placement"> | number
    placementType?: EnumPlacementTypeFilter<"Placement"> | $Enums.PlacementType
    billedHours?: IntNullableFilter<"Placement"> | number | null
    marginPercent?: DecimalFilter<"Placement"> | Decimal | DecimalJsLike | number | string
    revenue?: DecimalFilter<"Placement"> | Decimal | DecimalJsLike | number | string
    billingStatus?: EnumBillingStatusFilter<"Placement"> | $Enums.BillingStatus
    incentivePayoutEta?: DateTimeNullableFilter<"Placement"> | Date | string | null
    incentiveAmountInr?: DecimalFilter<"Placement"> | Decimal | DecimalJsLike | number | string
    incentivePaid?: BoolFilter<"Placement"> | boolean
    qualifier?: BoolFilter<"Placement"> | boolean
    createdAt?: DateTimeFilter<"Placement"> | Date | string
    employee?: XOR<UserRelationFilter, UserWhereInput>
    monthlyBillings?: MonthlyBillingListRelationFilter
  }

  export type PlacementOrderByWithRelationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    candidateName?: SortOrder
    clientName?: SortOrder
    doi?: SortOrder
    doj?: SortOrder
    daysCompleted?: SortOrder
    placementType?: SortOrder
    billedHours?: SortOrderInput | SortOrder
    marginPercent?: SortOrder
    revenue?: SortOrder
    billingStatus?: SortOrder
    incentivePayoutEta?: SortOrderInput | SortOrder
    incentiveAmountInr?: SortOrder
    incentivePaid?: SortOrder
    qualifier?: SortOrder
    createdAt?: SortOrder
    employee?: UserOrderByWithRelationInput
    monthlyBillings?: MonthlyBillingOrderByRelationAggregateInput
  }

  export type PlacementWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PlacementWhereInput | PlacementWhereInput[]
    OR?: PlacementWhereInput[]
    NOT?: PlacementWhereInput | PlacementWhereInput[]
    employeeId?: StringFilter<"Placement"> | string
    candidateName?: StringFilter<"Placement"> | string
    clientName?: StringFilter<"Placement"> | string
    doi?: DateTimeFilter<"Placement"> | Date | string
    doj?: DateTimeFilter<"Placement"> | Date | string
    daysCompleted?: IntFilter<"Placement"> | number
    placementType?: EnumPlacementTypeFilter<"Placement"> | $Enums.PlacementType
    billedHours?: IntNullableFilter<"Placement"> | number | null
    marginPercent?: DecimalFilter<"Placement"> | Decimal | DecimalJsLike | number | string
    revenue?: DecimalFilter<"Placement"> | Decimal | DecimalJsLike | number | string
    billingStatus?: EnumBillingStatusFilter<"Placement"> | $Enums.BillingStatus
    incentivePayoutEta?: DateTimeNullableFilter<"Placement"> | Date | string | null
    incentiveAmountInr?: DecimalFilter<"Placement"> | Decimal | DecimalJsLike | number | string
    incentivePaid?: BoolFilter<"Placement"> | boolean
    qualifier?: BoolFilter<"Placement"> | boolean
    createdAt?: DateTimeFilter<"Placement"> | Date | string
    employee?: XOR<UserRelationFilter, UserWhereInput>
    monthlyBillings?: MonthlyBillingListRelationFilter
  }, "id">

  export type PlacementOrderByWithAggregationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    candidateName?: SortOrder
    clientName?: SortOrder
    doi?: SortOrder
    doj?: SortOrder
    daysCompleted?: SortOrder
    placementType?: SortOrder
    billedHours?: SortOrderInput | SortOrder
    marginPercent?: SortOrder
    revenue?: SortOrder
    billingStatus?: SortOrder
    incentivePayoutEta?: SortOrderInput | SortOrder
    incentiveAmountInr?: SortOrder
    incentivePaid?: SortOrder
    qualifier?: SortOrder
    createdAt?: SortOrder
    _count?: PlacementCountOrderByAggregateInput
    _avg?: PlacementAvgOrderByAggregateInput
    _max?: PlacementMaxOrderByAggregateInput
    _min?: PlacementMinOrderByAggregateInput
    _sum?: PlacementSumOrderByAggregateInput
  }

  export type PlacementScalarWhereWithAggregatesInput = {
    AND?: PlacementScalarWhereWithAggregatesInput | PlacementScalarWhereWithAggregatesInput[]
    OR?: PlacementScalarWhereWithAggregatesInput[]
    NOT?: PlacementScalarWhereWithAggregatesInput | PlacementScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Placement"> | string
    employeeId?: StringWithAggregatesFilter<"Placement"> | string
    candidateName?: StringWithAggregatesFilter<"Placement"> | string
    clientName?: StringWithAggregatesFilter<"Placement"> | string
    doi?: DateTimeWithAggregatesFilter<"Placement"> | Date | string
    doj?: DateTimeWithAggregatesFilter<"Placement"> | Date | string
    daysCompleted?: IntWithAggregatesFilter<"Placement"> | number
    placementType?: EnumPlacementTypeWithAggregatesFilter<"Placement"> | $Enums.PlacementType
    billedHours?: IntNullableWithAggregatesFilter<"Placement"> | number | null
    marginPercent?: DecimalWithAggregatesFilter<"Placement"> | Decimal | DecimalJsLike | number | string
    revenue?: DecimalWithAggregatesFilter<"Placement"> | Decimal | DecimalJsLike | number | string
    billingStatus?: EnumBillingStatusWithAggregatesFilter<"Placement"> | $Enums.BillingStatus
    incentivePayoutEta?: DateTimeNullableWithAggregatesFilter<"Placement"> | Date | string | null
    incentiveAmountInr?: DecimalWithAggregatesFilter<"Placement"> | Decimal | DecimalJsLike | number | string
    incentivePaid?: BoolWithAggregatesFilter<"Placement"> | boolean
    qualifier?: BoolWithAggregatesFilter<"Placement"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Placement"> | Date | string
  }

  export type MonthlyBillingWhereInput = {
    AND?: MonthlyBillingWhereInput | MonthlyBillingWhereInput[]
    OR?: MonthlyBillingWhereInput[]
    NOT?: MonthlyBillingWhereInput | MonthlyBillingWhereInput[]
    id?: StringFilter<"MonthlyBilling"> | string
    placementId?: StringFilter<"MonthlyBilling"> | string
    month?: StringFilter<"MonthlyBilling"> | string
    hours?: IntNullableFilter<"MonthlyBilling"> | number | null
    status?: EnumBillingStatusFilter<"MonthlyBilling"> | $Enums.BillingStatus
    placement?: XOR<PlacementRelationFilter, PlacementWhereInput>
  }

  export type MonthlyBillingOrderByWithRelationInput = {
    id?: SortOrder
    placementId?: SortOrder
    month?: SortOrder
    hours?: SortOrderInput | SortOrder
    status?: SortOrder
    placement?: PlacementOrderByWithRelationInput
  }

  export type MonthlyBillingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MonthlyBillingWhereInput | MonthlyBillingWhereInput[]
    OR?: MonthlyBillingWhereInput[]
    NOT?: MonthlyBillingWhereInput | MonthlyBillingWhereInput[]
    placementId?: StringFilter<"MonthlyBilling"> | string
    month?: StringFilter<"MonthlyBilling"> | string
    hours?: IntNullableFilter<"MonthlyBilling"> | number | null
    status?: EnumBillingStatusFilter<"MonthlyBilling"> | $Enums.BillingStatus
    placement?: XOR<PlacementRelationFilter, PlacementWhereInput>
  }, "id">

  export type MonthlyBillingOrderByWithAggregationInput = {
    id?: SortOrder
    placementId?: SortOrder
    month?: SortOrder
    hours?: SortOrderInput | SortOrder
    status?: SortOrder
    _count?: MonthlyBillingCountOrderByAggregateInput
    _avg?: MonthlyBillingAvgOrderByAggregateInput
    _max?: MonthlyBillingMaxOrderByAggregateInput
    _min?: MonthlyBillingMinOrderByAggregateInput
    _sum?: MonthlyBillingSumOrderByAggregateInput
  }

  export type MonthlyBillingScalarWhereWithAggregatesInput = {
    AND?: MonthlyBillingScalarWhereWithAggregatesInput | MonthlyBillingScalarWhereWithAggregatesInput[]
    OR?: MonthlyBillingScalarWhereWithAggregatesInput[]
    NOT?: MonthlyBillingScalarWhereWithAggregatesInput | MonthlyBillingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MonthlyBilling"> | string
    placementId?: StringWithAggregatesFilter<"MonthlyBilling"> | string
    month?: StringWithAggregatesFilter<"MonthlyBilling"> | string
    hours?: IntNullableWithAggregatesFilter<"MonthlyBilling"> | number | null
    status?: EnumBillingStatusWithAggregatesFilter<"MonthlyBilling"> | $Enums.BillingStatus
  }

  export type IncentiveWhereInput = {
    AND?: IncentiveWhereInput | IncentiveWhereInput[]
    OR?: IncentiveWhereInput[]
    NOT?: IncentiveWhereInput | IncentiveWhereInput[]
    id?: StringFilter<"Incentive"> | string
    employeeId?: StringFilter<"Incentive"> | string
    periodStart?: DateTimeFilter<"Incentive"> | Date | string
    periodEnd?: DateTimeFilter<"Incentive"> | Date | string
    revenueTotal?: DecimalFilter<"Incentive"> | Decimal | DecimalJsLike | number | string
    slabName?: StringFilter<"Incentive"> | string
    amountUsd?: DecimalFilter<"Incentive"> | Decimal | DecimalJsLike | number | string
    amountInr?: DecimalFilter<"Incentive"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"Incentive"> | Date | string
    employee?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type IncentiveOrderByWithRelationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    revenueTotal?: SortOrder
    slabName?: SortOrder
    amountUsd?: SortOrder
    amountInr?: SortOrder
    createdAt?: SortOrder
    employee?: UserOrderByWithRelationInput
  }

  export type IncentiveWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: IncentiveWhereInput | IncentiveWhereInput[]
    OR?: IncentiveWhereInput[]
    NOT?: IncentiveWhereInput | IncentiveWhereInput[]
    employeeId?: StringFilter<"Incentive"> | string
    periodStart?: DateTimeFilter<"Incentive"> | Date | string
    periodEnd?: DateTimeFilter<"Incentive"> | Date | string
    revenueTotal?: DecimalFilter<"Incentive"> | Decimal | DecimalJsLike | number | string
    slabName?: StringFilter<"Incentive"> | string
    amountUsd?: DecimalFilter<"Incentive"> | Decimal | DecimalJsLike | number | string
    amountInr?: DecimalFilter<"Incentive"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"Incentive"> | Date | string
    employee?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type IncentiveOrderByWithAggregationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    revenueTotal?: SortOrder
    slabName?: SortOrder
    amountUsd?: SortOrder
    amountInr?: SortOrder
    createdAt?: SortOrder
    _count?: IncentiveCountOrderByAggregateInput
    _avg?: IncentiveAvgOrderByAggregateInput
    _max?: IncentiveMaxOrderByAggregateInput
    _min?: IncentiveMinOrderByAggregateInput
    _sum?: IncentiveSumOrderByAggregateInput
  }

  export type IncentiveScalarWhereWithAggregatesInput = {
    AND?: IncentiveScalarWhereWithAggregatesInput | IncentiveScalarWhereWithAggregatesInput[]
    OR?: IncentiveScalarWhereWithAggregatesInput[]
    NOT?: IncentiveScalarWhereWithAggregatesInput | IncentiveScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Incentive"> | string
    employeeId?: StringWithAggregatesFilter<"Incentive"> | string
    periodStart?: DateTimeWithAggregatesFilter<"Incentive"> | Date | string
    periodEnd?: DateTimeWithAggregatesFilter<"Incentive"> | Date | string
    revenueTotal?: DecimalWithAggregatesFilter<"Incentive"> | Decimal | DecimalJsLike | number | string
    slabName?: StringWithAggregatesFilter<"Incentive"> | string
    amountUsd?: DecimalWithAggregatesFilter<"Incentive"> | Decimal | DecimalJsLike | number | string
    amountInr?: DecimalWithAggregatesFilter<"Incentive"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeWithAggregatesFilter<"Incentive"> | Date | string
  }

  export type RefreshTokenWhereInput = {
    AND?: RefreshTokenWhereInput | RefreshTokenWhereInput[]
    OR?: RefreshTokenWhereInput[]
    NOT?: RefreshTokenWhereInput | RefreshTokenWhereInput[]
    id?: StringFilter<"RefreshToken"> | string
    token?: StringFilter<"RefreshToken"> | string
    userId?: StringFilter<"RefreshToken"> | string
    isRevoked?: BoolFilter<"RefreshToken"> | boolean
    expiresAt?: DateTimeFilter<"RefreshToken"> | Date | string
    createdAt?: DateTimeFilter<"RefreshToken"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type RefreshTokenOrderByWithRelationInput = {
    id?: SortOrder
    token?: SortOrder
    userId?: SortOrder
    isRevoked?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type RefreshTokenWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    token?: string
    AND?: RefreshTokenWhereInput | RefreshTokenWhereInput[]
    OR?: RefreshTokenWhereInput[]
    NOT?: RefreshTokenWhereInput | RefreshTokenWhereInput[]
    userId?: StringFilter<"RefreshToken"> | string
    isRevoked?: BoolFilter<"RefreshToken"> | boolean
    expiresAt?: DateTimeFilter<"RefreshToken"> | Date | string
    createdAt?: DateTimeFilter<"RefreshToken"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "token">

  export type RefreshTokenOrderByWithAggregationInput = {
    id?: SortOrder
    token?: SortOrder
    userId?: SortOrder
    isRevoked?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    _count?: RefreshTokenCountOrderByAggregateInput
    _max?: RefreshTokenMaxOrderByAggregateInput
    _min?: RefreshTokenMinOrderByAggregateInput
  }

  export type RefreshTokenScalarWhereWithAggregatesInput = {
    AND?: RefreshTokenScalarWhereWithAggregatesInput | RefreshTokenScalarWhereWithAggregatesInput[]
    OR?: RefreshTokenScalarWhereWithAggregatesInput[]
    NOT?: RefreshTokenScalarWhereWithAggregatesInput | RefreshTokenScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RefreshToken"> | string
    token?: StringWithAggregatesFilter<"RefreshToken"> | string
    userId?: StringWithAggregatesFilter<"RefreshToken"> | string
    isRevoked?: BoolWithAggregatesFilter<"RefreshToken"> | boolean
    expiresAt?: DateTimeWithAggregatesFilter<"RefreshToken"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"RefreshToken"> | Date | string
  }

  export type CampaignWhereInput = {
    AND?: CampaignWhereInput | CampaignWhereInput[]
    OR?: CampaignWhereInput[]
    NOT?: CampaignWhereInput | CampaignWhereInput[]
    id?: StringFilter<"Campaign"> | string
    name?: StringFilter<"Campaign"> | string
    description?: StringNullableFilter<"Campaign"> | string | null
    objective?: StringNullableFilter<"Campaign"> | string | null
    status?: EnumCampaignStatusFilter<"Campaign"> | $Enums.CampaignStatus
    targetAmount?: DecimalFilter<"Campaign"> | Decimal | DecimalJsLike | number | string
    startDate?: DateTimeFilter<"Campaign"> | Date | string
    endDate?: DateTimeFilter<"Campaign"> | Date | string
    createdById?: StringFilter<"Campaign"> | string
    createdAt?: DateTimeFilter<"Campaign"> | Date | string
    updatedAt?: DateTimeFilter<"Campaign"> | Date | string
    createdBy?: XOR<UserRelationFilter, UserWhereInput>
    images?: CampaignImageListRelationFilter
    teamLeads?: CampaignTeamLeadListRelationFilter
    assignments?: CampaignAssignmentListRelationFilter
    tasks?: CampaignTaskListRelationFilter
    activities?: CampaignActivityListRelationFilter
  }

  export type CampaignOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    objective?: SortOrderInput | SortOrder
    status?: SortOrder
    targetAmount?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: UserOrderByWithRelationInput
    images?: CampaignImageOrderByRelationAggregateInput
    teamLeads?: CampaignTeamLeadOrderByRelationAggregateInput
    assignments?: CampaignAssignmentOrderByRelationAggregateInput
    tasks?: CampaignTaskOrderByRelationAggregateInput
    activities?: CampaignActivityOrderByRelationAggregateInput
  }

  export type CampaignWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CampaignWhereInput | CampaignWhereInput[]
    OR?: CampaignWhereInput[]
    NOT?: CampaignWhereInput | CampaignWhereInput[]
    name?: StringFilter<"Campaign"> | string
    description?: StringNullableFilter<"Campaign"> | string | null
    objective?: StringNullableFilter<"Campaign"> | string | null
    status?: EnumCampaignStatusFilter<"Campaign"> | $Enums.CampaignStatus
    targetAmount?: DecimalFilter<"Campaign"> | Decimal | DecimalJsLike | number | string
    startDate?: DateTimeFilter<"Campaign"> | Date | string
    endDate?: DateTimeFilter<"Campaign"> | Date | string
    createdById?: StringFilter<"Campaign"> | string
    createdAt?: DateTimeFilter<"Campaign"> | Date | string
    updatedAt?: DateTimeFilter<"Campaign"> | Date | string
    createdBy?: XOR<UserRelationFilter, UserWhereInput>
    images?: CampaignImageListRelationFilter
    teamLeads?: CampaignTeamLeadListRelationFilter
    assignments?: CampaignAssignmentListRelationFilter
    tasks?: CampaignTaskListRelationFilter
    activities?: CampaignActivityListRelationFilter
  }, "id">

  export type CampaignOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    objective?: SortOrderInput | SortOrder
    status?: SortOrder
    targetAmount?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CampaignCountOrderByAggregateInput
    _avg?: CampaignAvgOrderByAggregateInput
    _max?: CampaignMaxOrderByAggregateInput
    _min?: CampaignMinOrderByAggregateInput
    _sum?: CampaignSumOrderByAggregateInput
  }

  export type CampaignScalarWhereWithAggregatesInput = {
    AND?: CampaignScalarWhereWithAggregatesInput | CampaignScalarWhereWithAggregatesInput[]
    OR?: CampaignScalarWhereWithAggregatesInput[]
    NOT?: CampaignScalarWhereWithAggregatesInput | CampaignScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Campaign"> | string
    name?: StringWithAggregatesFilter<"Campaign"> | string
    description?: StringNullableWithAggregatesFilter<"Campaign"> | string | null
    objective?: StringNullableWithAggregatesFilter<"Campaign"> | string | null
    status?: EnumCampaignStatusWithAggregatesFilter<"Campaign"> | $Enums.CampaignStatus
    targetAmount?: DecimalWithAggregatesFilter<"Campaign"> | Decimal | DecimalJsLike | number | string
    startDate?: DateTimeWithAggregatesFilter<"Campaign"> | Date | string
    endDate?: DateTimeWithAggregatesFilter<"Campaign"> | Date | string
    createdById?: StringWithAggregatesFilter<"Campaign"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Campaign"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Campaign"> | Date | string
  }

  export type CampaignImageWhereInput = {
    AND?: CampaignImageWhereInput | CampaignImageWhereInput[]
    OR?: CampaignImageWhereInput[]
    NOT?: CampaignImageWhereInput | CampaignImageWhereInput[]
    id?: StringFilter<"CampaignImage"> | string
    campaignId?: StringFilter<"CampaignImage"> | string
    url?: StringFilter<"CampaignImage"> | string
    title?: StringNullableFilter<"CampaignImage"> | string | null
    description?: StringNullableFilter<"CampaignImage"> | string | null
    uploadedById?: StringFilter<"CampaignImage"> | string
    createdAt?: DateTimeFilter<"CampaignImage"> | Date | string
    campaign?: XOR<CampaignRelationFilter, CampaignWhereInput>
    uploadedBy?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type CampaignImageOrderByWithRelationInput = {
    id?: SortOrder
    campaignId?: SortOrder
    url?: SortOrder
    title?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    uploadedById?: SortOrder
    createdAt?: SortOrder
    campaign?: CampaignOrderByWithRelationInput
    uploadedBy?: UserOrderByWithRelationInput
  }

  export type CampaignImageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CampaignImageWhereInput | CampaignImageWhereInput[]
    OR?: CampaignImageWhereInput[]
    NOT?: CampaignImageWhereInput | CampaignImageWhereInput[]
    campaignId?: StringFilter<"CampaignImage"> | string
    url?: StringFilter<"CampaignImage"> | string
    title?: StringNullableFilter<"CampaignImage"> | string | null
    description?: StringNullableFilter<"CampaignImage"> | string | null
    uploadedById?: StringFilter<"CampaignImage"> | string
    createdAt?: DateTimeFilter<"CampaignImage"> | Date | string
    campaign?: XOR<CampaignRelationFilter, CampaignWhereInput>
    uploadedBy?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type CampaignImageOrderByWithAggregationInput = {
    id?: SortOrder
    campaignId?: SortOrder
    url?: SortOrder
    title?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    uploadedById?: SortOrder
    createdAt?: SortOrder
    _count?: CampaignImageCountOrderByAggregateInput
    _max?: CampaignImageMaxOrderByAggregateInput
    _min?: CampaignImageMinOrderByAggregateInput
  }

  export type CampaignImageScalarWhereWithAggregatesInput = {
    AND?: CampaignImageScalarWhereWithAggregatesInput | CampaignImageScalarWhereWithAggregatesInput[]
    OR?: CampaignImageScalarWhereWithAggregatesInput[]
    NOT?: CampaignImageScalarWhereWithAggregatesInput | CampaignImageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CampaignImage"> | string
    campaignId?: StringWithAggregatesFilter<"CampaignImage"> | string
    url?: StringWithAggregatesFilter<"CampaignImage"> | string
    title?: StringNullableWithAggregatesFilter<"CampaignImage"> | string | null
    description?: StringNullableWithAggregatesFilter<"CampaignImage"> | string | null
    uploadedById?: StringWithAggregatesFilter<"CampaignImage"> | string
    createdAt?: DateTimeWithAggregatesFilter<"CampaignImage"> | Date | string
  }

  export type CampaignTeamLeadWhereInput = {
    AND?: CampaignTeamLeadWhereInput | CampaignTeamLeadWhereInput[]
    OR?: CampaignTeamLeadWhereInput[]
    NOT?: CampaignTeamLeadWhereInput | CampaignTeamLeadWhereInput[]
    id?: StringFilter<"CampaignTeamLead"> | string
    campaignId?: StringFilter<"CampaignTeamLead"> | string
    userId?: StringFilter<"CampaignTeamLead"> | string
    createdAt?: DateTimeFilter<"CampaignTeamLead"> | Date | string
    campaign?: XOR<CampaignRelationFilter, CampaignWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type CampaignTeamLeadOrderByWithRelationInput = {
    id?: SortOrder
    campaignId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    campaign?: CampaignOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type CampaignTeamLeadWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    campaignId_userId?: CampaignTeamLeadCampaignIdUserIdCompoundUniqueInput
    AND?: CampaignTeamLeadWhereInput | CampaignTeamLeadWhereInput[]
    OR?: CampaignTeamLeadWhereInput[]
    NOT?: CampaignTeamLeadWhereInput | CampaignTeamLeadWhereInput[]
    campaignId?: StringFilter<"CampaignTeamLead"> | string
    userId?: StringFilter<"CampaignTeamLead"> | string
    createdAt?: DateTimeFilter<"CampaignTeamLead"> | Date | string
    campaign?: XOR<CampaignRelationFilter, CampaignWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "campaignId_userId">

  export type CampaignTeamLeadOrderByWithAggregationInput = {
    id?: SortOrder
    campaignId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    _count?: CampaignTeamLeadCountOrderByAggregateInput
    _max?: CampaignTeamLeadMaxOrderByAggregateInput
    _min?: CampaignTeamLeadMinOrderByAggregateInput
  }

  export type CampaignTeamLeadScalarWhereWithAggregatesInput = {
    AND?: CampaignTeamLeadScalarWhereWithAggregatesInput | CampaignTeamLeadScalarWhereWithAggregatesInput[]
    OR?: CampaignTeamLeadScalarWhereWithAggregatesInput[]
    NOT?: CampaignTeamLeadScalarWhereWithAggregatesInput | CampaignTeamLeadScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CampaignTeamLead"> | string
    campaignId?: StringWithAggregatesFilter<"CampaignTeamLead"> | string
    userId?: StringWithAggregatesFilter<"CampaignTeamLead"> | string
    createdAt?: DateTimeWithAggregatesFilter<"CampaignTeamLead"> | Date | string
  }

  export type CampaignAssignmentWhereInput = {
    AND?: CampaignAssignmentWhereInput | CampaignAssignmentWhereInput[]
    OR?: CampaignAssignmentWhereInput[]
    NOT?: CampaignAssignmentWhereInput | CampaignAssignmentWhereInput[]
    id?: StringFilter<"CampaignAssignment"> | string
    campaignId?: StringFilter<"CampaignAssignment"> | string
    userId?: StringFilter<"CampaignAssignment"> | string
    role?: EnumRoleFilter<"CampaignAssignment"> | $Enums.Role
    targetAmount?: DecimalFilter<"CampaignAssignment"> | Decimal | DecimalJsLike | number | string
    progressPercent?: IntFilter<"CampaignAssignment"> | number
    isCompleted?: BoolFilter<"CampaignAssignment"> | boolean
    completedAt?: DateTimeNullableFilter<"CampaignAssignment"> | Date | string | null
    createdAt?: DateTimeFilter<"CampaignAssignment"> | Date | string
    updatedAt?: DateTimeFilter<"CampaignAssignment"> | Date | string
    campaign?: XOR<CampaignRelationFilter, CampaignWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
    tasks?: CampaignTaskListRelationFilter
  }

  export type CampaignAssignmentOrderByWithRelationInput = {
    id?: SortOrder
    campaignId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    targetAmount?: SortOrder
    progressPercent?: SortOrder
    isCompleted?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    campaign?: CampaignOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    tasks?: CampaignTaskOrderByRelationAggregateInput
  }

  export type CampaignAssignmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CampaignAssignmentWhereInput | CampaignAssignmentWhereInput[]
    OR?: CampaignAssignmentWhereInput[]
    NOT?: CampaignAssignmentWhereInput | CampaignAssignmentWhereInput[]
    campaignId?: StringFilter<"CampaignAssignment"> | string
    userId?: StringFilter<"CampaignAssignment"> | string
    role?: EnumRoleFilter<"CampaignAssignment"> | $Enums.Role
    targetAmount?: DecimalFilter<"CampaignAssignment"> | Decimal | DecimalJsLike | number | string
    progressPercent?: IntFilter<"CampaignAssignment"> | number
    isCompleted?: BoolFilter<"CampaignAssignment"> | boolean
    completedAt?: DateTimeNullableFilter<"CampaignAssignment"> | Date | string | null
    createdAt?: DateTimeFilter<"CampaignAssignment"> | Date | string
    updatedAt?: DateTimeFilter<"CampaignAssignment"> | Date | string
    campaign?: XOR<CampaignRelationFilter, CampaignWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
    tasks?: CampaignTaskListRelationFilter
  }, "id">

  export type CampaignAssignmentOrderByWithAggregationInput = {
    id?: SortOrder
    campaignId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    targetAmount?: SortOrder
    progressPercent?: SortOrder
    isCompleted?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CampaignAssignmentCountOrderByAggregateInput
    _avg?: CampaignAssignmentAvgOrderByAggregateInput
    _max?: CampaignAssignmentMaxOrderByAggregateInput
    _min?: CampaignAssignmentMinOrderByAggregateInput
    _sum?: CampaignAssignmentSumOrderByAggregateInput
  }

  export type CampaignAssignmentScalarWhereWithAggregatesInput = {
    AND?: CampaignAssignmentScalarWhereWithAggregatesInput | CampaignAssignmentScalarWhereWithAggregatesInput[]
    OR?: CampaignAssignmentScalarWhereWithAggregatesInput[]
    NOT?: CampaignAssignmentScalarWhereWithAggregatesInput | CampaignAssignmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CampaignAssignment"> | string
    campaignId?: StringWithAggregatesFilter<"CampaignAssignment"> | string
    userId?: StringWithAggregatesFilter<"CampaignAssignment"> | string
    role?: EnumRoleWithAggregatesFilter<"CampaignAssignment"> | $Enums.Role
    targetAmount?: DecimalWithAggregatesFilter<"CampaignAssignment"> | Decimal | DecimalJsLike | number | string
    progressPercent?: IntWithAggregatesFilter<"CampaignAssignment"> | number
    isCompleted?: BoolWithAggregatesFilter<"CampaignAssignment"> | boolean
    completedAt?: DateTimeNullableWithAggregatesFilter<"CampaignAssignment"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"CampaignAssignment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CampaignAssignment"> | Date | string
  }

  export type CampaignTaskWhereInput = {
    AND?: CampaignTaskWhereInput | CampaignTaskWhereInput[]
    OR?: CampaignTaskWhereInput[]
    NOT?: CampaignTaskWhereInput | CampaignTaskWhereInput[]
    id?: StringFilter<"CampaignTask"> | string
    campaignId?: StringFilter<"CampaignTask"> | string
    assignmentId?: StringNullableFilter<"CampaignTask"> | string | null
    title?: StringFilter<"CampaignTask"> | string
    description?: StringNullableFilter<"CampaignTask"> | string | null
    isCompleted?: BoolFilter<"CampaignTask"> | boolean
    completedById?: StringNullableFilter<"CampaignTask"> | string | null
    dueDate?: DateTimeNullableFilter<"CampaignTask"> | Date | string | null
    createdAt?: DateTimeFilter<"CampaignTask"> | Date | string
    updatedAt?: DateTimeFilter<"CampaignTask"> | Date | string
    campaign?: XOR<CampaignRelationFilter, CampaignWhereInput>
    assignment?: XOR<CampaignAssignmentNullableRelationFilter, CampaignAssignmentWhereInput> | null
    completedBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }

  export type CampaignTaskOrderByWithRelationInput = {
    id?: SortOrder
    campaignId?: SortOrder
    assignmentId?: SortOrderInput | SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    isCompleted?: SortOrder
    completedById?: SortOrderInput | SortOrder
    dueDate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    campaign?: CampaignOrderByWithRelationInput
    assignment?: CampaignAssignmentOrderByWithRelationInput
    completedBy?: UserOrderByWithRelationInput
  }

  export type CampaignTaskWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CampaignTaskWhereInput | CampaignTaskWhereInput[]
    OR?: CampaignTaskWhereInput[]
    NOT?: CampaignTaskWhereInput | CampaignTaskWhereInput[]
    campaignId?: StringFilter<"CampaignTask"> | string
    assignmentId?: StringNullableFilter<"CampaignTask"> | string | null
    title?: StringFilter<"CampaignTask"> | string
    description?: StringNullableFilter<"CampaignTask"> | string | null
    isCompleted?: BoolFilter<"CampaignTask"> | boolean
    completedById?: StringNullableFilter<"CampaignTask"> | string | null
    dueDate?: DateTimeNullableFilter<"CampaignTask"> | Date | string | null
    createdAt?: DateTimeFilter<"CampaignTask"> | Date | string
    updatedAt?: DateTimeFilter<"CampaignTask"> | Date | string
    campaign?: XOR<CampaignRelationFilter, CampaignWhereInput>
    assignment?: XOR<CampaignAssignmentNullableRelationFilter, CampaignAssignmentWhereInput> | null
    completedBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }, "id">

  export type CampaignTaskOrderByWithAggregationInput = {
    id?: SortOrder
    campaignId?: SortOrder
    assignmentId?: SortOrderInput | SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    isCompleted?: SortOrder
    completedById?: SortOrderInput | SortOrder
    dueDate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CampaignTaskCountOrderByAggregateInput
    _max?: CampaignTaskMaxOrderByAggregateInput
    _min?: CampaignTaskMinOrderByAggregateInput
  }

  export type CampaignTaskScalarWhereWithAggregatesInput = {
    AND?: CampaignTaskScalarWhereWithAggregatesInput | CampaignTaskScalarWhereWithAggregatesInput[]
    OR?: CampaignTaskScalarWhereWithAggregatesInput[]
    NOT?: CampaignTaskScalarWhereWithAggregatesInput | CampaignTaskScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CampaignTask"> | string
    campaignId?: StringWithAggregatesFilter<"CampaignTask"> | string
    assignmentId?: StringNullableWithAggregatesFilter<"CampaignTask"> | string | null
    title?: StringWithAggregatesFilter<"CampaignTask"> | string
    description?: StringNullableWithAggregatesFilter<"CampaignTask"> | string | null
    isCompleted?: BoolWithAggregatesFilter<"CampaignTask"> | boolean
    completedById?: StringNullableWithAggregatesFilter<"CampaignTask"> | string | null
    dueDate?: DateTimeNullableWithAggregatesFilter<"CampaignTask"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"CampaignTask"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CampaignTask"> | Date | string
  }

  export type CampaignActivityWhereInput = {
    AND?: CampaignActivityWhereInput | CampaignActivityWhereInput[]
    OR?: CampaignActivityWhereInput[]
    NOT?: CampaignActivityWhereInput | CampaignActivityWhereInput[]
    id?: StringFilter<"CampaignActivity"> | string
    campaignId?: StringFilter<"CampaignActivity"> | string
    userId?: StringFilter<"CampaignActivity"> | string
    action?: StringFilter<"CampaignActivity"> | string
    metadata?: JsonNullableFilter<"CampaignActivity">
    createdAt?: DateTimeFilter<"CampaignActivity"> | Date | string
    campaign?: XOR<CampaignRelationFilter, CampaignWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type CampaignActivityOrderByWithRelationInput = {
    id?: SortOrder
    campaignId?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    campaign?: CampaignOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type CampaignActivityWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CampaignActivityWhereInput | CampaignActivityWhereInput[]
    OR?: CampaignActivityWhereInput[]
    NOT?: CampaignActivityWhereInput | CampaignActivityWhereInput[]
    campaignId?: StringFilter<"CampaignActivity"> | string
    userId?: StringFilter<"CampaignActivity"> | string
    action?: StringFilter<"CampaignActivity"> | string
    metadata?: JsonNullableFilter<"CampaignActivity">
    createdAt?: DateTimeFilter<"CampaignActivity"> | Date | string
    campaign?: XOR<CampaignRelationFilter, CampaignWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type CampaignActivityOrderByWithAggregationInput = {
    id?: SortOrder
    campaignId?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: CampaignActivityCountOrderByAggregateInput
    _max?: CampaignActivityMaxOrderByAggregateInput
    _min?: CampaignActivityMinOrderByAggregateInput
  }

  export type CampaignActivityScalarWhereWithAggregatesInput = {
    AND?: CampaignActivityScalarWhereWithAggregatesInput | CampaignActivityScalarWhereWithAggregatesInput[]
    OR?: CampaignActivityScalarWhereWithAggregatesInput[]
    NOT?: CampaignActivityScalarWhereWithAggregatesInput | CampaignActivityScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CampaignActivity"> | string
    campaignId?: StringWithAggregatesFilter<"CampaignActivity"> | string
    userId?: StringWithAggregatesFilter<"CampaignActivity"> | string
    action?: StringWithAggregatesFilter<"CampaignActivity"> | string
    metadata?: JsonNullableWithAggregatesFilter<"CampaignActivity">
    createdAt?: DateTimeWithAggregatesFilter<"CampaignActivity"> | Date | string
  }

  export type AuditLogWhereInput = {
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    id?: StringFilter<"AuditLog"> | string
    actorId?: StringFilter<"AuditLog"> | string
    action?: StringFilter<"AuditLog"> | string
    entityType?: StringFilter<"AuditLog"> | string
    entityId?: StringFilter<"AuditLog"> | string
    changes?: JsonNullableFilter<"AuditLog">
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
    actor?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type AuditLogOrderByWithRelationInput = {
    id?: SortOrder
    actorId?: SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    changes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    actor?: UserOrderByWithRelationInput
  }

  export type AuditLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    actorId?: StringFilter<"AuditLog"> | string
    action?: StringFilter<"AuditLog"> | string
    entityType?: StringFilter<"AuditLog"> | string
    entityId?: StringFilter<"AuditLog"> | string
    changes?: JsonNullableFilter<"AuditLog">
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
    actor?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type AuditLogOrderByWithAggregationInput = {
    id?: SortOrder
    actorId?: SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    changes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: AuditLogCountOrderByAggregateInput
    _max?: AuditLogMaxOrderByAggregateInput
    _min?: AuditLogMinOrderByAggregateInput
  }

  export type AuditLogScalarWhereWithAggregatesInput = {
    AND?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    OR?: AuditLogScalarWhereWithAggregatesInput[]
    NOT?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AuditLog"> | string
    actorId?: StringWithAggregatesFilter<"AuditLog"> | string
    action?: StringWithAggregatesFilter<"AuditLog"> | string
    entityType?: StringWithAggregatesFilter<"AuditLog"> | string
    entityId?: StringWithAggregatesFilter<"AuditLog"> | string
    changes?: JsonNullableWithAggregatesFilter<"AuditLog">
    createdAt?: DateTimeWithAggregatesFilter<"AuditLog"> | Date | string
  }

  export type TeamCreateInput = {
    id?: string
    name: string
    color?: string | null
    yearlyTarget: Decimal | DecimalJsLike | number | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    employees?: EmployeeProfileCreateNestedManyWithoutTeamInput
  }

  export type TeamUncheckedCreateInput = {
    id?: string
    name: string
    color?: string | null
    yearlyTarget: Decimal | DecimalJsLike | number | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    employees?: EmployeeProfileUncheckedCreateNestedManyWithoutTeamInput
  }

  export type TeamUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    yearlyTarget?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employees?: EmployeeProfileUpdateManyWithoutTeamNestedInput
  }

  export type TeamUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    yearlyTarget?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employees?: EmployeeProfileUncheckedUpdateManyWithoutTeamNestedInput
  }

  export type TeamCreateManyInput = {
    id?: string
    name: string
    color?: string | null
    yearlyTarget: Decimal | DecimalJsLike | number | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TeamUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    yearlyTarget?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    yearlyTarget?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    passwordHash: string
    name: string
    role: $Enums.Role
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    employeeProfile?: EmployeeProfileCreateNestedOneWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    dailyEntries?: DailyEntryCreateNestedManyWithoutEmployeeInput
    placements?: PlacementCreateNestedManyWithoutEmployeeInput
    incentives?: IncentiveCreateNestedManyWithoutEmployeeInput
    campaignAssignments?: CampaignAssignmentCreateNestedManyWithoutUserInput
    campaignTeamLeads?: CampaignTeamLeadCreateNestedManyWithoutUserInput
    campaignActivities?: CampaignActivityCreateNestedManyWithoutUserInput
    createdCampaigns?: CampaignCreateNestedManyWithoutCreatedByInput
    uploadedCampaignImages?: CampaignImageCreateNestedManyWithoutUploadedByInput
    completedCampaignTasks?: CampaignTaskCreateNestedManyWithoutCompletedByInput
    leadEmployees?: EmployeeProfileCreateNestedManyWithoutManagerInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    passwordHash: string
    name: string
    role: $Enums.Role
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    employeeProfile?: EmployeeProfileUncheckedCreateNestedOneWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    dailyEntries?: DailyEntryUncheckedCreateNestedManyWithoutEmployeeInput
    placements?: PlacementUncheckedCreateNestedManyWithoutEmployeeInput
    incentives?: IncentiveUncheckedCreateNestedManyWithoutEmployeeInput
    campaignAssignments?: CampaignAssignmentUncheckedCreateNestedManyWithoutUserInput
    campaignTeamLeads?: CampaignTeamLeadUncheckedCreateNestedManyWithoutUserInput
    campaignActivities?: CampaignActivityUncheckedCreateNestedManyWithoutUserInput
    createdCampaigns?: CampaignUncheckedCreateNestedManyWithoutCreatedByInput
    uploadedCampaignImages?: CampaignImageUncheckedCreateNestedManyWithoutUploadedByInput
    completedCampaignTasks?: CampaignTaskUncheckedCreateNestedManyWithoutCompletedByInput
    leadEmployees?: EmployeeProfileUncheckedCreateNestedManyWithoutManagerInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employeeProfile?: EmployeeProfileUpdateOneWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    dailyEntries?: DailyEntryUpdateManyWithoutEmployeeNestedInput
    placements?: PlacementUpdateManyWithoutEmployeeNestedInput
    incentives?: IncentiveUpdateManyWithoutEmployeeNestedInput
    campaignAssignments?: CampaignAssignmentUpdateManyWithoutUserNestedInput
    campaignTeamLeads?: CampaignTeamLeadUpdateManyWithoutUserNestedInput
    campaignActivities?: CampaignActivityUpdateManyWithoutUserNestedInput
    createdCampaigns?: CampaignUpdateManyWithoutCreatedByNestedInput
    uploadedCampaignImages?: CampaignImageUpdateManyWithoutUploadedByNestedInput
    completedCampaignTasks?: CampaignTaskUpdateManyWithoutCompletedByNestedInput
    leadEmployees?: EmployeeProfileUpdateManyWithoutManagerNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employeeProfile?: EmployeeProfileUncheckedUpdateOneWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    dailyEntries?: DailyEntryUncheckedUpdateManyWithoutEmployeeNestedInput
    placements?: PlacementUncheckedUpdateManyWithoutEmployeeNestedInput
    incentives?: IncentiveUncheckedUpdateManyWithoutEmployeeNestedInput
    campaignAssignments?: CampaignAssignmentUncheckedUpdateManyWithoutUserNestedInput
    campaignTeamLeads?: CampaignTeamLeadUncheckedUpdateManyWithoutUserNestedInput
    campaignActivities?: CampaignActivityUncheckedUpdateManyWithoutUserNestedInput
    createdCampaigns?: CampaignUncheckedUpdateManyWithoutCreatedByNestedInput
    uploadedCampaignImages?: CampaignImageUncheckedUpdateManyWithoutUploadedByNestedInput
    completedCampaignTasks?: CampaignTaskUncheckedUpdateManyWithoutCompletedByNestedInput
    leadEmployees?: EmployeeProfileUncheckedUpdateManyWithoutManagerNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    passwordHash: string
    name: string
    role: $Enums.Role
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeProfileCreateInput = {
    level?: string | null
    yearlyTarget: Decimal | DecimalJsLike | number | string
    isActive?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutEmployeeProfileInput
    team?: TeamCreateNestedOneWithoutEmployeesInput
    manager?: UserCreateNestedOneWithoutLeadEmployeesInput
  }

  export type EmployeeProfileUncheckedCreateInput = {
    id: string
    teamId?: string | null
    managerId?: string | null
    level?: string | null
    yearlyTarget: Decimal | DecimalJsLike | number | string
    isActive?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmployeeProfileUpdateInput = {
    level?: NullableStringFieldUpdateOperationsInput | string | null
    yearlyTarget?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutEmployeeProfileNestedInput
    team?: TeamUpdateOneWithoutEmployeesNestedInput
    manager?: UserUpdateOneWithoutLeadEmployeesNestedInput
  }

  export type EmployeeProfileUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    yearlyTarget?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeProfileCreateManyInput = {
    id: string
    teamId?: string | null
    managerId?: string | null
    level?: string | null
    yearlyTarget: Decimal | DecimalJsLike | number | string
    isActive?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmployeeProfileUpdateManyMutationInput = {
    level?: NullableStringFieldUpdateOperationsInput | string | null
    yearlyTarget?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeProfileUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    yearlyTarget?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DailyEntryCreateInput = {
    id?: string
    date: Date | string
    clientName: string
    placementType: $Enums.PlacementType
    revenue: Decimal | DecimalJsLike | number | string
    marginPercent: Decimal | DecimalJsLike | number | string
    billingStatus: $Enums.BillingStatus
    doi: Date | string
    doj: Date | string
    remarks?: string | null
    createdAt?: Date | string
    employee: UserCreateNestedOneWithoutDailyEntriesInput
  }

  export type DailyEntryUncheckedCreateInput = {
    id?: string
    employeeId: string
    date: Date | string
    clientName: string
    placementType: $Enums.PlacementType
    revenue: Decimal | DecimalJsLike | number | string
    marginPercent: Decimal | DecimalJsLike | number | string
    billingStatus: $Enums.BillingStatus
    doi: Date | string
    doj: Date | string
    remarks?: string | null
    createdAt?: Date | string
  }

  export type DailyEntryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    clientName?: StringFieldUpdateOperationsInput | string
    placementType?: EnumPlacementTypeFieldUpdateOperationsInput | $Enums.PlacementType
    revenue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    marginPercent?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    billingStatus?: EnumBillingStatusFieldUpdateOperationsInput | $Enums.BillingStatus
    doi?: DateTimeFieldUpdateOperationsInput | Date | string
    doj?: DateTimeFieldUpdateOperationsInput | Date | string
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: UserUpdateOneRequiredWithoutDailyEntriesNestedInput
  }

  export type DailyEntryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    clientName?: StringFieldUpdateOperationsInput | string
    placementType?: EnumPlacementTypeFieldUpdateOperationsInput | $Enums.PlacementType
    revenue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    marginPercent?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    billingStatus?: EnumBillingStatusFieldUpdateOperationsInput | $Enums.BillingStatus
    doi?: DateTimeFieldUpdateOperationsInput | Date | string
    doj?: DateTimeFieldUpdateOperationsInput | Date | string
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DailyEntryCreateManyInput = {
    id?: string
    employeeId: string
    date: Date | string
    clientName: string
    placementType: $Enums.PlacementType
    revenue: Decimal | DecimalJsLike | number | string
    marginPercent: Decimal | DecimalJsLike | number | string
    billingStatus: $Enums.BillingStatus
    doi: Date | string
    doj: Date | string
    remarks?: string | null
    createdAt?: Date | string
  }

  export type DailyEntryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    clientName?: StringFieldUpdateOperationsInput | string
    placementType?: EnumPlacementTypeFieldUpdateOperationsInput | $Enums.PlacementType
    revenue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    marginPercent?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    billingStatus?: EnumBillingStatusFieldUpdateOperationsInput | $Enums.BillingStatus
    doi?: DateTimeFieldUpdateOperationsInput | Date | string
    doj?: DateTimeFieldUpdateOperationsInput | Date | string
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DailyEntryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    clientName?: StringFieldUpdateOperationsInput | string
    placementType?: EnumPlacementTypeFieldUpdateOperationsInput | $Enums.PlacementType
    revenue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    marginPercent?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    billingStatus?: EnumBillingStatusFieldUpdateOperationsInput | $Enums.BillingStatus
    doi?: DateTimeFieldUpdateOperationsInput | Date | string
    doj?: DateTimeFieldUpdateOperationsInput | Date | string
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlacementCreateInput = {
    id?: string
    candidateName: string
    clientName: string
    doi: Date | string
    doj: Date | string
    daysCompleted: number
    placementType: $Enums.PlacementType
    billedHours?: number | null
    marginPercent: Decimal | DecimalJsLike | number | string
    revenue: Decimal | DecimalJsLike | number | string
    billingStatus: $Enums.BillingStatus
    incentivePayoutEta?: Date | string | null
    incentiveAmountInr: Decimal | DecimalJsLike | number | string
    incentivePaid: boolean
    qualifier: boolean
    createdAt?: Date | string
    employee: UserCreateNestedOneWithoutPlacementsInput
    monthlyBillings?: MonthlyBillingCreateNestedManyWithoutPlacementInput
  }

  export type PlacementUncheckedCreateInput = {
    id?: string
    employeeId: string
    candidateName: string
    clientName: string
    doi: Date | string
    doj: Date | string
    daysCompleted: number
    placementType: $Enums.PlacementType
    billedHours?: number | null
    marginPercent: Decimal | DecimalJsLike | number | string
    revenue: Decimal | DecimalJsLike | number | string
    billingStatus: $Enums.BillingStatus
    incentivePayoutEta?: Date | string | null
    incentiveAmountInr: Decimal | DecimalJsLike | number | string
    incentivePaid: boolean
    qualifier: boolean
    createdAt?: Date | string
    monthlyBillings?: MonthlyBillingUncheckedCreateNestedManyWithoutPlacementInput
  }

  export type PlacementUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    candidateName?: StringFieldUpdateOperationsInput | string
    clientName?: StringFieldUpdateOperationsInput | string
    doi?: DateTimeFieldUpdateOperationsInput | Date | string
    doj?: DateTimeFieldUpdateOperationsInput | Date | string
    daysCompleted?: IntFieldUpdateOperationsInput | number
    placementType?: EnumPlacementTypeFieldUpdateOperationsInput | $Enums.PlacementType
    billedHours?: NullableIntFieldUpdateOperationsInput | number | null
    marginPercent?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    revenue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    billingStatus?: EnumBillingStatusFieldUpdateOperationsInput | $Enums.BillingStatus
    incentivePayoutEta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    incentiveAmountInr?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    incentivePaid?: BoolFieldUpdateOperationsInput | boolean
    qualifier?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: UserUpdateOneRequiredWithoutPlacementsNestedInput
    monthlyBillings?: MonthlyBillingUpdateManyWithoutPlacementNestedInput
  }

  export type PlacementUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    candidateName?: StringFieldUpdateOperationsInput | string
    clientName?: StringFieldUpdateOperationsInput | string
    doi?: DateTimeFieldUpdateOperationsInput | Date | string
    doj?: DateTimeFieldUpdateOperationsInput | Date | string
    daysCompleted?: IntFieldUpdateOperationsInput | number
    placementType?: EnumPlacementTypeFieldUpdateOperationsInput | $Enums.PlacementType
    billedHours?: NullableIntFieldUpdateOperationsInput | number | null
    marginPercent?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    revenue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    billingStatus?: EnumBillingStatusFieldUpdateOperationsInput | $Enums.BillingStatus
    incentivePayoutEta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    incentiveAmountInr?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    incentivePaid?: BoolFieldUpdateOperationsInput | boolean
    qualifier?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    monthlyBillings?: MonthlyBillingUncheckedUpdateManyWithoutPlacementNestedInput
  }

  export type PlacementCreateManyInput = {
    id?: string
    employeeId: string
    candidateName: string
    clientName: string
    doi: Date | string
    doj: Date | string
    daysCompleted: number
    placementType: $Enums.PlacementType
    billedHours?: number | null
    marginPercent: Decimal | DecimalJsLike | number | string
    revenue: Decimal | DecimalJsLike | number | string
    billingStatus: $Enums.BillingStatus
    incentivePayoutEta?: Date | string | null
    incentiveAmountInr: Decimal | DecimalJsLike | number | string
    incentivePaid: boolean
    qualifier: boolean
    createdAt?: Date | string
  }

  export type PlacementUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    candidateName?: StringFieldUpdateOperationsInput | string
    clientName?: StringFieldUpdateOperationsInput | string
    doi?: DateTimeFieldUpdateOperationsInput | Date | string
    doj?: DateTimeFieldUpdateOperationsInput | Date | string
    daysCompleted?: IntFieldUpdateOperationsInput | number
    placementType?: EnumPlacementTypeFieldUpdateOperationsInput | $Enums.PlacementType
    billedHours?: NullableIntFieldUpdateOperationsInput | number | null
    marginPercent?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    revenue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    billingStatus?: EnumBillingStatusFieldUpdateOperationsInput | $Enums.BillingStatus
    incentivePayoutEta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    incentiveAmountInr?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    incentivePaid?: BoolFieldUpdateOperationsInput | boolean
    qualifier?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlacementUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    candidateName?: StringFieldUpdateOperationsInput | string
    clientName?: StringFieldUpdateOperationsInput | string
    doi?: DateTimeFieldUpdateOperationsInput | Date | string
    doj?: DateTimeFieldUpdateOperationsInput | Date | string
    daysCompleted?: IntFieldUpdateOperationsInput | number
    placementType?: EnumPlacementTypeFieldUpdateOperationsInput | $Enums.PlacementType
    billedHours?: NullableIntFieldUpdateOperationsInput | number | null
    marginPercent?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    revenue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    billingStatus?: EnumBillingStatusFieldUpdateOperationsInput | $Enums.BillingStatus
    incentivePayoutEta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    incentiveAmountInr?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    incentivePaid?: BoolFieldUpdateOperationsInput | boolean
    qualifier?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MonthlyBillingCreateInput = {
    id?: string
    month: string
    hours?: number | null
    status: $Enums.BillingStatus
    placement: PlacementCreateNestedOneWithoutMonthlyBillingsInput
  }

  export type MonthlyBillingUncheckedCreateInput = {
    id?: string
    placementId: string
    month: string
    hours?: number | null
    status: $Enums.BillingStatus
  }

  export type MonthlyBillingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    month?: StringFieldUpdateOperationsInput | string
    hours?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumBillingStatusFieldUpdateOperationsInput | $Enums.BillingStatus
    placement?: PlacementUpdateOneRequiredWithoutMonthlyBillingsNestedInput
  }

  export type MonthlyBillingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    placementId?: StringFieldUpdateOperationsInput | string
    month?: StringFieldUpdateOperationsInput | string
    hours?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumBillingStatusFieldUpdateOperationsInput | $Enums.BillingStatus
  }

  export type MonthlyBillingCreateManyInput = {
    id?: string
    placementId: string
    month: string
    hours?: number | null
    status: $Enums.BillingStatus
  }

  export type MonthlyBillingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    month?: StringFieldUpdateOperationsInput | string
    hours?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumBillingStatusFieldUpdateOperationsInput | $Enums.BillingStatus
  }

  export type MonthlyBillingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    placementId?: StringFieldUpdateOperationsInput | string
    month?: StringFieldUpdateOperationsInput | string
    hours?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumBillingStatusFieldUpdateOperationsInput | $Enums.BillingStatus
  }

  export type IncentiveCreateInput = {
    id?: string
    periodStart: Date | string
    periodEnd: Date | string
    revenueTotal: Decimal | DecimalJsLike | number | string
    slabName: string
    amountUsd: Decimal | DecimalJsLike | number | string
    amountInr: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    employee: UserCreateNestedOneWithoutIncentivesInput
  }

  export type IncentiveUncheckedCreateInput = {
    id?: string
    employeeId: string
    periodStart: Date | string
    periodEnd: Date | string
    revenueTotal: Decimal | DecimalJsLike | number | string
    slabName: string
    amountUsd: Decimal | DecimalJsLike | number | string
    amountInr: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
  }

  export type IncentiveUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    revenueTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    slabName?: StringFieldUpdateOperationsInput | string
    amountUsd?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amountInr?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: UserUpdateOneRequiredWithoutIncentivesNestedInput
  }

  export type IncentiveUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    revenueTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    slabName?: StringFieldUpdateOperationsInput | string
    amountUsd?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amountInr?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IncentiveCreateManyInput = {
    id?: string
    employeeId: string
    periodStart: Date | string
    periodEnd: Date | string
    revenueTotal: Decimal | DecimalJsLike | number | string
    slabName: string
    amountUsd: Decimal | DecimalJsLike | number | string
    amountInr: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
  }

  export type IncentiveUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    revenueTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    slabName?: StringFieldUpdateOperationsInput | string
    amountUsd?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amountInr?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IncentiveUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    revenueTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    slabName?: StringFieldUpdateOperationsInput | string
    amountUsd?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amountInr?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefreshTokenCreateInput = {
    id?: string
    token: string
    isRevoked?: boolean
    expiresAt: Date | string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutRefreshTokensInput
  }

  export type RefreshTokenUncheckedCreateInput = {
    id?: string
    token: string
    userId: string
    isRevoked?: boolean
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type RefreshTokenUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    isRevoked?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutRefreshTokensNestedInput
  }

  export type RefreshTokenUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    isRevoked?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefreshTokenCreateManyInput = {
    id?: string
    token: string
    userId: string
    isRevoked?: boolean
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type RefreshTokenUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    isRevoked?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefreshTokenUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    isRevoked?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignCreateInput = {
    id?: string
    name: string
    description?: string | null
    objective?: string | null
    status?: $Enums.CampaignStatus
    targetAmount: Decimal | DecimalJsLike | number | string
    startDate: Date | string
    endDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: UserCreateNestedOneWithoutCreatedCampaignsInput
    images?: CampaignImageCreateNestedManyWithoutCampaignInput
    teamLeads?: CampaignTeamLeadCreateNestedManyWithoutCampaignInput
    assignments?: CampaignAssignmentCreateNestedManyWithoutCampaignInput
    tasks?: CampaignTaskCreateNestedManyWithoutCampaignInput
    activities?: CampaignActivityCreateNestedManyWithoutCampaignInput
  }

  export type CampaignUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    objective?: string | null
    status?: $Enums.CampaignStatus
    targetAmount: Decimal | DecimalJsLike | number | string
    startDate: Date | string
    endDate: Date | string
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    images?: CampaignImageUncheckedCreateNestedManyWithoutCampaignInput
    teamLeads?: CampaignTeamLeadUncheckedCreateNestedManyWithoutCampaignInput
    assignments?: CampaignAssignmentUncheckedCreateNestedManyWithoutCampaignInput
    tasks?: CampaignTaskUncheckedCreateNestedManyWithoutCampaignInput
    activities?: CampaignActivityUncheckedCreateNestedManyWithoutCampaignInput
  }

  export type CampaignUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    objective?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    targetAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutCreatedCampaignsNestedInput
    images?: CampaignImageUpdateManyWithoutCampaignNestedInput
    teamLeads?: CampaignTeamLeadUpdateManyWithoutCampaignNestedInput
    assignments?: CampaignAssignmentUpdateManyWithoutCampaignNestedInput
    tasks?: CampaignTaskUpdateManyWithoutCampaignNestedInput
    activities?: CampaignActivityUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    objective?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    targetAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    images?: CampaignImageUncheckedUpdateManyWithoutCampaignNestedInput
    teamLeads?: CampaignTeamLeadUncheckedUpdateManyWithoutCampaignNestedInput
    assignments?: CampaignAssignmentUncheckedUpdateManyWithoutCampaignNestedInput
    tasks?: CampaignTaskUncheckedUpdateManyWithoutCampaignNestedInput
    activities?: CampaignActivityUncheckedUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    objective?: string | null
    status?: $Enums.CampaignStatus
    targetAmount: Decimal | DecimalJsLike | number | string
    startDate: Date | string
    endDate: Date | string
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CampaignUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    objective?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    targetAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    objective?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    targetAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignImageCreateInput = {
    id?: string
    url: string
    title?: string | null
    description?: string | null
    createdAt?: Date | string
    campaign: CampaignCreateNestedOneWithoutImagesInput
    uploadedBy: UserCreateNestedOneWithoutUploadedCampaignImagesInput
  }

  export type CampaignImageUncheckedCreateInput = {
    id?: string
    campaignId: string
    url: string
    title?: string | null
    description?: string | null
    uploadedById: string
    createdAt?: Date | string
  }

  export type CampaignImageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaign?: CampaignUpdateOneRequiredWithoutImagesNestedInput
    uploadedBy?: UserUpdateOneRequiredWithoutUploadedCampaignImagesNestedInput
  }

  export type CampaignImageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignImageCreateManyInput = {
    id?: string
    campaignId: string
    url: string
    title?: string | null
    description?: string | null
    uploadedById: string
    createdAt?: Date | string
  }

  export type CampaignImageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignImageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignTeamLeadCreateInput = {
    id?: string
    createdAt?: Date | string
    campaign: CampaignCreateNestedOneWithoutTeamLeadsInput
    user: UserCreateNestedOneWithoutCampaignTeamLeadsInput
  }

  export type CampaignTeamLeadUncheckedCreateInput = {
    id?: string
    campaignId: string
    userId: string
    createdAt?: Date | string
  }

  export type CampaignTeamLeadUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaign?: CampaignUpdateOneRequiredWithoutTeamLeadsNestedInput
    user?: UserUpdateOneRequiredWithoutCampaignTeamLeadsNestedInput
  }

  export type CampaignTeamLeadUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignTeamLeadCreateManyInput = {
    id?: string
    campaignId: string
    userId: string
    createdAt?: Date | string
  }

  export type CampaignTeamLeadUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignTeamLeadUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignAssignmentCreateInput = {
    id?: string
    role: $Enums.Role
    targetAmount: Decimal | DecimalJsLike | number | string
    progressPercent?: number
    isCompleted?: boolean
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    campaign: CampaignCreateNestedOneWithoutAssignmentsInput
    user: UserCreateNestedOneWithoutCampaignAssignmentsInput
    tasks?: CampaignTaskCreateNestedManyWithoutAssignmentInput
  }

  export type CampaignAssignmentUncheckedCreateInput = {
    id?: string
    campaignId: string
    userId: string
    role: $Enums.Role
    targetAmount: Decimal | DecimalJsLike | number | string
    progressPercent?: number
    isCompleted?: boolean
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tasks?: CampaignTaskUncheckedCreateNestedManyWithoutAssignmentInput
  }

  export type CampaignAssignmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    targetAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    progressPercent?: IntFieldUpdateOperationsInput | number
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaign?: CampaignUpdateOneRequiredWithoutAssignmentsNestedInput
    user?: UserUpdateOneRequiredWithoutCampaignAssignmentsNestedInput
    tasks?: CampaignTaskUpdateManyWithoutAssignmentNestedInput
  }

  export type CampaignAssignmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    targetAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    progressPercent?: IntFieldUpdateOperationsInput | number
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tasks?: CampaignTaskUncheckedUpdateManyWithoutAssignmentNestedInput
  }

  export type CampaignAssignmentCreateManyInput = {
    id?: string
    campaignId: string
    userId: string
    role: $Enums.Role
    targetAmount: Decimal | DecimalJsLike | number | string
    progressPercent?: number
    isCompleted?: boolean
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CampaignAssignmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    targetAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    progressPercent?: IntFieldUpdateOperationsInput | number
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignAssignmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    targetAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    progressPercent?: IntFieldUpdateOperationsInput | number
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignTaskCreateInput = {
    id?: string
    title: string
    description?: string | null
    isCompleted?: boolean
    dueDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    campaign: CampaignCreateNestedOneWithoutTasksInput
    assignment?: CampaignAssignmentCreateNestedOneWithoutTasksInput
    completedBy?: UserCreateNestedOneWithoutCompletedCampaignTasksInput
  }

  export type CampaignTaskUncheckedCreateInput = {
    id?: string
    campaignId: string
    assignmentId?: string | null
    title: string
    description?: string | null
    isCompleted?: boolean
    completedById?: string | null
    dueDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CampaignTaskUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaign?: CampaignUpdateOneRequiredWithoutTasksNestedInput
    assignment?: CampaignAssignmentUpdateOneWithoutTasksNestedInput
    completedBy?: UserUpdateOneWithoutCompletedCampaignTasksNestedInput
  }

  export type CampaignTaskUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    assignmentId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    completedById?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignTaskCreateManyInput = {
    id?: string
    campaignId: string
    assignmentId?: string | null
    title: string
    description?: string | null
    isCompleted?: boolean
    completedById?: string | null
    dueDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CampaignTaskUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignTaskUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    assignmentId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    completedById?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignActivityCreateInput = {
    id?: string
    action: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    campaign: CampaignCreateNestedOneWithoutActivitiesInput
    user: UserCreateNestedOneWithoutCampaignActivitiesInput
  }

  export type CampaignActivityUncheckedCreateInput = {
    id?: string
    campaignId: string
    userId: string
    action: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type CampaignActivityUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaign?: CampaignUpdateOneRequiredWithoutActivitiesNestedInput
    user?: UserUpdateOneRequiredWithoutCampaignActivitiesNestedInput
  }

  export type CampaignActivityUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignActivityCreateManyInput = {
    id?: string
    campaignId: string
    userId: string
    action: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type CampaignActivityUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignActivityUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateInput = {
    id?: string
    action: string
    entityType: string
    entityId: string
    changes?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    actor: UserCreateNestedOneWithoutAuditLogsInput
  }

  export type AuditLogUncheckedCreateInput = {
    id?: string
    actorId: string
    action: string
    entityType: string
    entityId: string
    changes?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AuditLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    changes?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    actor?: UserUpdateOneRequiredWithoutAuditLogsNestedInput
  }

  export type AuditLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    actorId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    changes?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateManyInput = {
    id?: string
    actorId: string
    action: string
    entityType: string
    entityId: string
    changes?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AuditLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    changes?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    actorId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    changes?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type EmployeeProfileListRelationFilter = {
    every?: EmployeeProfileWhereInput
    some?: EmployeeProfileWhereInput
    none?: EmployeeProfileWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type EmployeeProfileOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TeamCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    color?: SortOrder
    yearlyTarget?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TeamAvgOrderByAggregateInput = {
    yearlyTarget?: SortOrder
  }

  export type TeamMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    color?: SortOrder
    yearlyTarget?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TeamMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    color?: SortOrder
    yearlyTarget?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TeamSumOrderByAggregateInput = {
    yearlyTarget?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type EnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type EmployeeProfileNullableRelationFilter = {
    is?: EmployeeProfileWhereInput | null
    isNot?: EmployeeProfileWhereInput | null
  }

  export type RefreshTokenListRelationFilter = {
    every?: RefreshTokenWhereInput
    some?: RefreshTokenWhereInput
    none?: RefreshTokenWhereInput
  }

  export type DailyEntryListRelationFilter = {
    every?: DailyEntryWhereInput
    some?: DailyEntryWhereInput
    none?: DailyEntryWhereInput
  }

  export type PlacementListRelationFilter = {
    every?: PlacementWhereInput
    some?: PlacementWhereInput
    none?: PlacementWhereInput
  }

  export type IncentiveListRelationFilter = {
    every?: IncentiveWhereInput
    some?: IncentiveWhereInput
    none?: IncentiveWhereInput
  }

  export type CampaignAssignmentListRelationFilter = {
    every?: CampaignAssignmentWhereInput
    some?: CampaignAssignmentWhereInput
    none?: CampaignAssignmentWhereInput
  }

  export type CampaignTeamLeadListRelationFilter = {
    every?: CampaignTeamLeadWhereInput
    some?: CampaignTeamLeadWhereInput
    none?: CampaignTeamLeadWhereInput
  }

  export type CampaignActivityListRelationFilter = {
    every?: CampaignActivityWhereInput
    some?: CampaignActivityWhereInput
    none?: CampaignActivityWhereInput
  }

  export type CampaignListRelationFilter = {
    every?: CampaignWhereInput
    some?: CampaignWhereInput
    none?: CampaignWhereInput
  }

  export type CampaignImageListRelationFilter = {
    every?: CampaignImageWhereInput
    some?: CampaignImageWhereInput
    none?: CampaignImageWhereInput
  }

  export type CampaignTaskListRelationFilter = {
    every?: CampaignTaskWhereInput
    some?: CampaignTaskWhereInput
    none?: CampaignTaskWhereInput
  }

  export type AuditLogListRelationFilter = {
    every?: AuditLogWhereInput
    some?: AuditLogWhereInput
    none?: AuditLogWhereInput
  }

  export type RefreshTokenOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DailyEntryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PlacementOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type IncentiveOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CampaignAssignmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CampaignTeamLeadOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CampaignActivityOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CampaignOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CampaignImageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CampaignTaskOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AuditLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    name?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    name?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    name?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type TeamNullableRelationFilter = {
    is?: TeamWhereInput | null
    isNot?: TeamWhereInput | null
  }

  export type UserNullableRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type EmployeeProfileCountOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    managerId?: SortOrder
    level?: SortOrder
    yearlyTarget?: SortOrder
    isActive?: SortOrder
    deletedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmployeeProfileAvgOrderByAggregateInput = {
    yearlyTarget?: SortOrder
  }

  export type EmployeeProfileMaxOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    managerId?: SortOrder
    level?: SortOrder
    yearlyTarget?: SortOrder
    isActive?: SortOrder
    deletedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmployeeProfileMinOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    managerId?: SortOrder
    level?: SortOrder
    yearlyTarget?: SortOrder
    isActive?: SortOrder
    deletedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmployeeProfileSumOrderByAggregateInput = {
    yearlyTarget?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type EnumPlacementTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PlacementType | EnumPlacementTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PlacementType[] | ListEnumPlacementTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PlacementType[] | ListEnumPlacementTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPlacementTypeFilter<$PrismaModel> | $Enums.PlacementType
  }

  export type EnumBillingStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.BillingStatus | EnumBillingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BillingStatus[] | ListEnumBillingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BillingStatus[] | ListEnumBillingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBillingStatusFilter<$PrismaModel> | $Enums.BillingStatus
  }

  export type DailyEntryCountOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    date?: SortOrder
    clientName?: SortOrder
    placementType?: SortOrder
    revenue?: SortOrder
    marginPercent?: SortOrder
    billingStatus?: SortOrder
    doi?: SortOrder
    doj?: SortOrder
    remarks?: SortOrder
    createdAt?: SortOrder
  }

  export type DailyEntryAvgOrderByAggregateInput = {
    revenue?: SortOrder
    marginPercent?: SortOrder
  }

  export type DailyEntryMaxOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    date?: SortOrder
    clientName?: SortOrder
    placementType?: SortOrder
    revenue?: SortOrder
    marginPercent?: SortOrder
    billingStatus?: SortOrder
    doi?: SortOrder
    doj?: SortOrder
    remarks?: SortOrder
    createdAt?: SortOrder
  }

  export type DailyEntryMinOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    date?: SortOrder
    clientName?: SortOrder
    placementType?: SortOrder
    revenue?: SortOrder
    marginPercent?: SortOrder
    billingStatus?: SortOrder
    doi?: SortOrder
    doj?: SortOrder
    remarks?: SortOrder
    createdAt?: SortOrder
  }

  export type DailyEntrySumOrderByAggregateInput = {
    revenue?: SortOrder
    marginPercent?: SortOrder
  }

  export type EnumPlacementTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PlacementType | EnumPlacementTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PlacementType[] | ListEnumPlacementTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PlacementType[] | ListEnumPlacementTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPlacementTypeWithAggregatesFilter<$PrismaModel> | $Enums.PlacementType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPlacementTypeFilter<$PrismaModel>
    _max?: NestedEnumPlacementTypeFilter<$PrismaModel>
  }

  export type EnumBillingStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BillingStatus | EnumBillingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BillingStatus[] | ListEnumBillingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BillingStatus[] | ListEnumBillingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBillingStatusWithAggregatesFilter<$PrismaModel> | $Enums.BillingStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBillingStatusFilter<$PrismaModel>
    _max?: NestedEnumBillingStatusFilter<$PrismaModel>
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type MonthlyBillingListRelationFilter = {
    every?: MonthlyBillingWhereInput
    some?: MonthlyBillingWhereInput
    none?: MonthlyBillingWhereInput
  }

  export type MonthlyBillingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PlacementCountOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    candidateName?: SortOrder
    clientName?: SortOrder
    doi?: SortOrder
    doj?: SortOrder
    daysCompleted?: SortOrder
    placementType?: SortOrder
    billedHours?: SortOrder
    marginPercent?: SortOrder
    revenue?: SortOrder
    billingStatus?: SortOrder
    incentivePayoutEta?: SortOrder
    incentiveAmountInr?: SortOrder
    incentivePaid?: SortOrder
    qualifier?: SortOrder
    createdAt?: SortOrder
  }

  export type PlacementAvgOrderByAggregateInput = {
    daysCompleted?: SortOrder
    billedHours?: SortOrder
    marginPercent?: SortOrder
    revenue?: SortOrder
    incentiveAmountInr?: SortOrder
  }

  export type PlacementMaxOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    candidateName?: SortOrder
    clientName?: SortOrder
    doi?: SortOrder
    doj?: SortOrder
    daysCompleted?: SortOrder
    placementType?: SortOrder
    billedHours?: SortOrder
    marginPercent?: SortOrder
    revenue?: SortOrder
    billingStatus?: SortOrder
    incentivePayoutEta?: SortOrder
    incentiveAmountInr?: SortOrder
    incentivePaid?: SortOrder
    qualifier?: SortOrder
    createdAt?: SortOrder
  }

  export type PlacementMinOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    candidateName?: SortOrder
    clientName?: SortOrder
    doi?: SortOrder
    doj?: SortOrder
    daysCompleted?: SortOrder
    placementType?: SortOrder
    billedHours?: SortOrder
    marginPercent?: SortOrder
    revenue?: SortOrder
    billingStatus?: SortOrder
    incentivePayoutEta?: SortOrder
    incentiveAmountInr?: SortOrder
    incentivePaid?: SortOrder
    qualifier?: SortOrder
    createdAt?: SortOrder
  }

  export type PlacementSumOrderByAggregateInput = {
    daysCompleted?: SortOrder
    billedHours?: SortOrder
    marginPercent?: SortOrder
    revenue?: SortOrder
    incentiveAmountInr?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type PlacementRelationFilter = {
    is?: PlacementWhereInput
    isNot?: PlacementWhereInput
  }

  export type MonthlyBillingCountOrderByAggregateInput = {
    id?: SortOrder
    placementId?: SortOrder
    month?: SortOrder
    hours?: SortOrder
    status?: SortOrder
  }

  export type MonthlyBillingAvgOrderByAggregateInput = {
    hours?: SortOrder
  }

  export type MonthlyBillingMaxOrderByAggregateInput = {
    id?: SortOrder
    placementId?: SortOrder
    month?: SortOrder
    hours?: SortOrder
    status?: SortOrder
  }

  export type MonthlyBillingMinOrderByAggregateInput = {
    id?: SortOrder
    placementId?: SortOrder
    month?: SortOrder
    hours?: SortOrder
    status?: SortOrder
  }

  export type MonthlyBillingSumOrderByAggregateInput = {
    hours?: SortOrder
  }

  export type IncentiveCountOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    revenueTotal?: SortOrder
    slabName?: SortOrder
    amountUsd?: SortOrder
    amountInr?: SortOrder
    createdAt?: SortOrder
  }

  export type IncentiveAvgOrderByAggregateInput = {
    revenueTotal?: SortOrder
    amountUsd?: SortOrder
    amountInr?: SortOrder
  }

  export type IncentiveMaxOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    revenueTotal?: SortOrder
    slabName?: SortOrder
    amountUsd?: SortOrder
    amountInr?: SortOrder
    createdAt?: SortOrder
  }

  export type IncentiveMinOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    revenueTotal?: SortOrder
    slabName?: SortOrder
    amountUsd?: SortOrder
    amountInr?: SortOrder
    createdAt?: SortOrder
  }

  export type IncentiveSumOrderByAggregateInput = {
    revenueTotal?: SortOrder
    amountUsd?: SortOrder
    amountInr?: SortOrder
  }

  export type RefreshTokenCountOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    userId?: SortOrder
    isRevoked?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type RefreshTokenMaxOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    userId?: SortOrder
    isRevoked?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type RefreshTokenMinOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    userId?: SortOrder
    isRevoked?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumCampaignStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.CampaignStatus | EnumCampaignStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CampaignStatus[] | ListEnumCampaignStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CampaignStatus[] | ListEnumCampaignStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCampaignStatusFilter<$PrismaModel> | $Enums.CampaignStatus
  }

  export type CampaignCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    objective?: SortOrder
    status?: SortOrder
    targetAmount?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CampaignAvgOrderByAggregateInput = {
    targetAmount?: SortOrder
  }

  export type CampaignMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    objective?: SortOrder
    status?: SortOrder
    targetAmount?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CampaignMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    objective?: SortOrder
    status?: SortOrder
    targetAmount?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CampaignSumOrderByAggregateInput = {
    targetAmount?: SortOrder
  }

  export type EnumCampaignStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CampaignStatus | EnumCampaignStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CampaignStatus[] | ListEnumCampaignStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CampaignStatus[] | ListEnumCampaignStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCampaignStatusWithAggregatesFilter<$PrismaModel> | $Enums.CampaignStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCampaignStatusFilter<$PrismaModel>
    _max?: NestedEnumCampaignStatusFilter<$PrismaModel>
  }

  export type CampaignRelationFilter = {
    is?: CampaignWhereInput
    isNot?: CampaignWhereInput
  }

  export type CampaignImageCountOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    url?: SortOrder
    title?: SortOrder
    description?: SortOrder
    uploadedById?: SortOrder
    createdAt?: SortOrder
  }

  export type CampaignImageMaxOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    url?: SortOrder
    title?: SortOrder
    description?: SortOrder
    uploadedById?: SortOrder
    createdAt?: SortOrder
  }

  export type CampaignImageMinOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    url?: SortOrder
    title?: SortOrder
    description?: SortOrder
    uploadedById?: SortOrder
    createdAt?: SortOrder
  }

  export type CampaignTeamLeadCampaignIdUserIdCompoundUniqueInput = {
    campaignId: string
    userId: string
  }

  export type CampaignTeamLeadCountOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type CampaignTeamLeadMaxOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type CampaignTeamLeadMinOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type CampaignAssignmentCountOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    targetAmount?: SortOrder
    progressPercent?: SortOrder
    isCompleted?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CampaignAssignmentAvgOrderByAggregateInput = {
    targetAmount?: SortOrder
    progressPercent?: SortOrder
  }

  export type CampaignAssignmentMaxOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    targetAmount?: SortOrder
    progressPercent?: SortOrder
    isCompleted?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CampaignAssignmentMinOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    targetAmount?: SortOrder
    progressPercent?: SortOrder
    isCompleted?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CampaignAssignmentSumOrderByAggregateInput = {
    targetAmount?: SortOrder
    progressPercent?: SortOrder
  }

  export type CampaignAssignmentNullableRelationFilter = {
    is?: CampaignAssignmentWhereInput | null
    isNot?: CampaignAssignmentWhereInput | null
  }

  export type CampaignTaskCountOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    assignmentId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    isCompleted?: SortOrder
    completedById?: SortOrder
    dueDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CampaignTaskMaxOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    assignmentId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    isCompleted?: SortOrder
    completedById?: SortOrder
    dueDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CampaignTaskMinOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    assignmentId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    isCompleted?: SortOrder
    completedById?: SortOrder
    dueDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }
  export type JsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type CampaignActivityCountOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
  }

  export type CampaignActivityMaxOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    createdAt?: SortOrder
  }

  export type CampaignActivityMinOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    createdAt?: SortOrder
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type AuditLogCountOrderByAggregateInput = {
    id?: SortOrder
    actorId?: SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    changes?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogMaxOrderByAggregateInput = {
    id?: SortOrder
    actorId?: SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogMinOrderByAggregateInput = {
    id?: SortOrder
    actorId?: SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    createdAt?: SortOrder
  }

  export type EmployeeProfileCreateNestedManyWithoutTeamInput = {
    create?: XOR<EmployeeProfileCreateWithoutTeamInput, EmployeeProfileUncheckedCreateWithoutTeamInput> | EmployeeProfileCreateWithoutTeamInput[] | EmployeeProfileUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: EmployeeProfileCreateOrConnectWithoutTeamInput | EmployeeProfileCreateOrConnectWithoutTeamInput[]
    createMany?: EmployeeProfileCreateManyTeamInputEnvelope
    connect?: EmployeeProfileWhereUniqueInput | EmployeeProfileWhereUniqueInput[]
  }

  export type EmployeeProfileUncheckedCreateNestedManyWithoutTeamInput = {
    create?: XOR<EmployeeProfileCreateWithoutTeamInput, EmployeeProfileUncheckedCreateWithoutTeamInput> | EmployeeProfileCreateWithoutTeamInput[] | EmployeeProfileUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: EmployeeProfileCreateOrConnectWithoutTeamInput | EmployeeProfileCreateOrConnectWithoutTeamInput[]
    createMany?: EmployeeProfileCreateManyTeamInputEnvelope
    connect?: EmployeeProfileWhereUniqueInput | EmployeeProfileWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type EmployeeProfileUpdateManyWithoutTeamNestedInput = {
    create?: XOR<EmployeeProfileCreateWithoutTeamInput, EmployeeProfileUncheckedCreateWithoutTeamInput> | EmployeeProfileCreateWithoutTeamInput[] | EmployeeProfileUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: EmployeeProfileCreateOrConnectWithoutTeamInput | EmployeeProfileCreateOrConnectWithoutTeamInput[]
    upsert?: EmployeeProfileUpsertWithWhereUniqueWithoutTeamInput | EmployeeProfileUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: EmployeeProfileCreateManyTeamInputEnvelope
    set?: EmployeeProfileWhereUniqueInput | EmployeeProfileWhereUniqueInput[]
    disconnect?: EmployeeProfileWhereUniqueInput | EmployeeProfileWhereUniqueInput[]
    delete?: EmployeeProfileWhereUniqueInput | EmployeeProfileWhereUniqueInput[]
    connect?: EmployeeProfileWhereUniqueInput | EmployeeProfileWhereUniqueInput[]
    update?: EmployeeProfileUpdateWithWhereUniqueWithoutTeamInput | EmployeeProfileUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: EmployeeProfileUpdateManyWithWhereWithoutTeamInput | EmployeeProfileUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: EmployeeProfileScalarWhereInput | EmployeeProfileScalarWhereInput[]
  }

  export type EmployeeProfileUncheckedUpdateManyWithoutTeamNestedInput = {
    create?: XOR<EmployeeProfileCreateWithoutTeamInput, EmployeeProfileUncheckedCreateWithoutTeamInput> | EmployeeProfileCreateWithoutTeamInput[] | EmployeeProfileUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: EmployeeProfileCreateOrConnectWithoutTeamInput | EmployeeProfileCreateOrConnectWithoutTeamInput[]
    upsert?: EmployeeProfileUpsertWithWhereUniqueWithoutTeamInput | EmployeeProfileUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: EmployeeProfileCreateManyTeamInputEnvelope
    set?: EmployeeProfileWhereUniqueInput | EmployeeProfileWhereUniqueInput[]
    disconnect?: EmployeeProfileWhereUniqueInput | EmployeeProfileWhereUniqueInput[]
    delete?: EmployeeProfileWhereUniqueInput | EmployeeProfileWhereUniqueInput[]
    connect?: EmployeeProfileWhereUniqueInput | EmployeeProfileWhereUniqueInput[]
    update?: EmployeeProfileUpdateWithWhereUniqueWithoutTeamInput | EmployeeProfileUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: EmployeeProfileUpdateManyWithWhereWithoutTeamInput | EmployeeProfileUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: EmployeeProfileScalarWhereInput | EmployeeProfileScalarWhereInput[]
  }

  export type EmployeeProfileCreateNestedOneWithoutUserInput = {
    create?: XOR<EmployeeProfileCreateWithoutUserInput, EmployeeProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: EmployeeProfileCreateOrConnectWithoutUserInput
    connect?: EmployeeProfileWhereUniqueInput
  }

  export type RefreshTokenCreateNestedManyWithoutUserInput = {
    create?: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput> | RefreshTokenCreateWithoutUserInput[] | RefreshTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RefreshTokenCreateOrConnectWithoutUserInput | RefreshTokenCreateOrConnectWithoutUserInput[]
    createMany?: RefreshTokenCreateManyUserInputEnvelope
    connect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
  }

  export type DailyEntryCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<DailyEntryCreateWithoutEmployeeInput, DailyEntryUncheckedCreateWithoutEmployeeInput> | DailyEntryCreateWithoutEmployeeInput[] | DailyEntryUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: DailyEntryCreateOrConnectWithoutEmployeeInput | DailyEntryCreateOrConnectWithoutEmployeeInput[]
    createMany?: DailyEntryCreateManyEmployeeInputEnvelope
    connect?: DailyEntryWhereUniqueInput | DailyEntryWhereUniqueInput[]
  }

  export type PlacementCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<PlacementCreateWithoutEmployeeInput, PlacementUncheckedCreateWithoutEmployeeInput> | PlacementCreateWithoutEmployeeInput[] | PlacementUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: PlacementCreateOrConnectWithoutEmployeeInput | PlacementCreateOrConnectWithoutEmployeeInput[]
    createMany?: PlacementCreateManyEmployeeInputEnvelope
    connect?: PlacementWhereUniqueInput | PlacementWhereUniqueInput[]
  }

  export type IncentiveCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<IncentiveCreateWithoutEmployeeInput, IncentiveUncheckedCreateWithoutEmployeeInput> | IncentiveCreateWithoutEmployeeInput[] | IncentiveUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: IncentiveCreateOrConnectWithoutEmployeeInput | IncentiveCreateOrConnectWithoutEmployeeInput[]
    createMany?: IncentiveCreateManyEmployeeInputEnvelope
    connect?: IncentiveWhereUniqueInput | IncentiveWhereUniqueInput[]
  }

  export type CampaignAssignmentCreateNestedManyWithoutUserInput = {
    create?: XOR<CampaignAssignmentCreateWithoutUserInput, CampaignAssignmentUncheckedCreateWithoutUserInput> | CampaignAssignmentCreateWithoutUserInput[] | CampaignAssignmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CampaignAssignmentCreateOrConnectWithoutUserInput | CampaignAssignmentCreateOrConnectWithoutUserInput[]
    createMany?: CampaignAssignmentCreateManyUserInputEnvelope
    connect?: CampaignAssignmentWhereUniqueInput | CampaignAssignmentWhereUniqueInput[]
  }

  export type CampaignTeamLeadCreateNestedManyWithoutUserInput = {
    create?: XOR<CampaignTeamLeadCreateWithoutUserInput, CampaignTeamLeadUncheckedCreateWithoutUserInput> | CampaignTeamLeadCreateWithoutUserInput[] | CampaignTeamLeadUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CampaignTeamLeadCreateOrConnectWithoutUserInput | CampaignTeamLeadCreateOrConnectWithoutUserInput[]
    createMany?: CampaignTeamLeadCreateManyUserInputEnvelope
    connect?: CampaignTeamLeadWhereUniqueInput | CampaignTeamLeadWhereUniqueInput[]
  }

  export type CampaignActivityCreateNestedManyWithoutUserInput = {
    create?: XOR<CampaignActivityCreateWithoutUserInput, CampaignActivityUncheckedCreateWithoutUserInput> | CampaignActivityCreateWithoutUserInput[] | CampaignActivityUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CampaignActivityCreateOrConnectWithoutUserInput | CampaignActivityCreateOrConnectWithoutUserInput[]
    createMany?: CampaignActivityCreateManyUserInputEnvelope
    connect?: CampaignActivityWhereUniqueInput | CampaignActivityWhereUniqueInput[]
  }

  export type CampaignCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<CampaignCreateWithoutCreatedByInput, CampaignUncheckedCreateWithoutCreatedByInput> | CampaignCreateWithoutCreatedByInput[] | CampaignUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: CampaignCreateOrConnectWithoutCreatedByInput | CampaignCreateOrConnectWithoutCreatedByInput[]
    createMany?: CampaignCreateManyCreatedByInputEnvelope
    connect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
  }

  export type CampaignImageCreateNestedManyWithoutUploadedByInput = {
    create?: XOR<CampaignImageCreateWithoutUploadedByInput, CampaignImageUncheckedCreateWithoutUploadedByInput> | CampaignImageCreateWithoutUploadedByInput[] | CampaignImageUncheckedCreateWithoutUploadedByInput[]
    connectOrCreate?: CampaignImageCreateOrConnectWithoutUploadedByInput | CampaignImageCreateOrConnectWithoutUploadedByInput[]
    createMany?: CampaignImageCreateManyUploadedByInputEnvelope
    connect?: CampaignImageWhereUniqueInput | CampaignImageWhereUniqueInput[]
  }

  export type CampaignTaskCreateNestedManyWithoutCompletedByInput = {
    create?: XOR<CampaignTaskCreateWithoutCompletedByInput, CampaignTaskUncheckedCreateWithoutCompletedByInput> | CampaignTaskCreateWithoutCompletedByInput[] | CampaignTaskUncheckedCreateWithoutCompletedByInput[]
    connectOrCreate?: CampaignTaskCreateOrConnectWithoutCompletedByInput | CampaignTaskCreateOrConnectWithoutCompletedByInput[]
    createMany?: CampaignTaskCreateManyCompletedByInputEnvelope
    connect?: CampaignTaskWhereUniqueInput | CampaignTaskWhereUniqueInput[]
  }

  export type EmployeeProfileCreateNestedManyWithoutManagerInput = {
    create?: XOR<EmployeeProfileCreateWithoutManagerInput, EmployeeProfileUncheckedCreateWithoutManagerInput> | EmployeeProfileCreateWithoutManagerInput[] | EmployeeProfileUncheckedCreateWithoutManagerInput[]
    connectOrCreate?: EmployeeProfileCreateOrConnectWithoutManagerInput | EmployeeProfileCreateOrConnectWithoutManagerInput[]
    createMany?: EmployeeProfileCreateManyManagerInputEnvelope
    connect?: EmployeeProfileWhereUniqueInput | EmployeeProfileWhereUniqueInput[]
  }

  export type AuditLogCreateNestedManyWithoutActorInput = {
    create?: XOR<AuditLogCreateWithoutActorInput, AuditLogUncheckedCreateWithoutActorInput> | AuditLogCreateWithoutActorInput[] | AuditLogUncheckedCreateWithoutActorInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutActorInput | AuditLogCreateOrConnectWithoutActorInput[]
    createMany?: AuditLogCreateManyActorInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type EmployeeProfileUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<EmployeeProfileCreateWithoutUserInput, EmployeeProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: EmployeeProfileCreateOrConnectWithoutUserInput
    connect?: EmployeeProfileWhereUniqueInput
  }

  export type RefreshTokenUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput> | RefreshTokenCreateWithoutUserInput[] | RefreshTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RefreshTokenCreateOrConnectWithoutUserInput | RefreshTokenCreateOrConnectWithoutUserInput[]
    createMany?: RefreshTokenCreateManyUserInputEnvelope
    connect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
  }

  export type DailyEntryUncheckedCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<DailyEntryCreateWithoutEmployeeInput, DailyEntryUncheckedCreateWithoutEmployeeInput> | DailyEntryCreateWithoutEmployeeInput[] | DailyEntryUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: DailyEntryCreateOrConnectWithoutEmployeeInput | DailyEntryCreateOrConnectWithoutEmployeeInput[]
    createMany?: DailyEntryCreateManyEmployeeInputEnvelope
    connect?: DailyEntryWhereUniqueInput | DailyEntryWhereUniqueInput[]
  }

  export type PlacementUncheckedCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<PlacementCreateWithoutEmployeeInput, PlacementUncheckedCreateWithoutEmployeeInput> | PlacementCreateWithoutEmployeeInput[] | PlacementUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: PlacementCreateOrConnectWithoutEmployeeInput | PlacementCreateOrConnectWithoutEmployeeInput[]
    createMany?: PlacementCreateManyEmployeeInputEnvelope
    connect?: PlacementWhereUniqueInput | PlacementWhereUniqueInput[]
  }

  export type IncentiveUncheckedCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<IncentiveCreateWithoutEmployeeInput, IncentiveUncheckedCreateWithoutEmployeeInput> | IncentiveCreateWithoutEmployeeInput[] | IncentiveUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: IncentiveCreateOrConnectWithoutEmployeeInput | IncentiveCreateOrConnectWithoutEmployeeInput[]
    createMany?: IncentiveCreateManyEmployeeInputEnvelope
    connect?: IncentiveWhereUniqueInput | IncentiveWhereUniqueInput[]
  }

  export type CampaignAssignmentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<CampaignAssignmentCreateWithoutUserInput, CampaignAssignmentUncheckedCreateWithoutUserInput> | CampaignAssignmentCreateWithoutUserInput[] | CampaignAssignmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CampaignAssignmentCreateOrConnectWithoutUserInput | CampaignAssignmentCreateOrConnectWithoutUserInput[]
    createMany?: CampaignAssignmentCreateManyUserInputEnvelope
    connect?: CampaignAssignmentWhereUniqueInput | CampaignAssignmentWhereUniqueInput[]
  }

  export type CampaignTeamLeadUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<CampaignTeamLeadCreateWithoutUserInput, CampaignTeamLeadUncheckedCreateWithoutUserInput> | CampaignTeamLeadCreateWithoutUserInput[] | CampaignTeamLeadUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CampaignTeamLeadCreateOrConnectWithoutUserInput | CampaignTeamLeadCreateOrConnectWithoutUserInput[]
    createMany?: CampaignTeamLeadCreateManyUserInputEnvelope
    connect?: CampaignTeamLeadWhereUniqueInput | CampaignTeamLeadWhereUniqueInput[]
  }

  export type CampaignActivityUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<CampaignActivityCreateWithoutUserInput, CampaignActivityUncheckedCreateWithoutUserInput> | CampaignActivityCreateWithoutUserInput[] | CampaignActivityUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CampaignActivityCreateOrConnectWithoutUserInput | CampaignActivityCreateOrConnectWithoutUserInput[]
    createMany?: CampaignActivityCreateManyUserInputEnvelope
    connect?: CampaignActivityWhereUniqueInput | CampaignActivityWhereUniqueInput[]
  }

  export type CampaignUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<CampaignCreateWithoutCreatedByInput, CampaignUncheckedCreateWithoutCreatedByInput> | CampaignCreateWithoutCreatedByInput[] | CampaignUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: CampaignCreateOrConnectWithoutCreatedByInput | CampaignCreateOrConnectWithoutCreatedByInput[]
    createMany?: CampaignCreateManyCreatedByInputEnvelope
    connect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
  }

  export type CampaignImageUncheckedCreateNestedManyWithoutUploadedByInput = {
    create?: XOR<CampaignImageCreateWithoutUploadedByInput, CampaignImageUncheckedCreateWithoutUploadedByInput> | CampaignImageCreateWithoutUploadedByInput[] | CampaignImageUncheckedCreateWithoutUploadedByInput[]
    connectOrCreate?: CampaignImageCreateOrConnectWithoutUploadedByInput | CampaignImageCreateOrConnectWithoutUploadedByInput[]
    createMany?: CampaignImageCreateManyUploadedByInputEnvelope
    connect?: CampaignImageWhereUniqueInput | CampaignImageWhereUniqueInput[]
  }

  export type CampaignTaskUncheckedCreateNestedManyWithoutCompletedByInput = {
    create?: XOR<CampaignTaskCreateWithoutCompletedByInput, CampaignTaskUncheckedCreateWithoutCompletedByInput> | CampaignTaskCreateWithoutCompletedByInput[] | CampaignTaskUncheckedCreateWithoutCompletedByInput[]
    connectOrCreate?: CampaignTaskCreateOrConnectWithoutCompletedByInput | CampaignTaskCreateOrConnectWithoutCompletedByInput[]
    createMany?: CampaignTaskCreateManyCompletedByInputEnvelope
    connect?: CampaignTaskWhereUniqueInput | CampaignTaskWhereUniqueInput[]
  }

  export type EmployeeProfileUncheckedCreateNestedManyWithoutManagerInput = {
    create?: XOR<EmployeeProfileCreateWithoutManagerInput, EmployeeProfileUncheckedCreateWithoutManagerInput> | EmployeeProfileCreateWithoutManagerInput[] | EmployeeProfileUncheckedCreateWithoutManagerInput[]
    connectOrCreate?: EmployeeProfileCreateOrConnectWithoutManagerInput | EmployeeProfileCreateOrConnectWithoutManagerInput[]
    createMany?: EmployeeProfileCreateManyManagerInputEnvelope
    connect?: EmployeeProfileWhereUniqueInput | EmployeeProfileWhereUniqueInput[]
  }

  export type AuditLogUncheckedCreateNestedManyWithoutActorInput = {
    create?: XOR<AuditLogCreateWithoutActorInput, AuditLogUncheckedCreateWithoutActorInput> | AuditLogCreateWithoutActorInput[] | AuditLogUncheckedCreateWithoutActorInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutActorInput | AuditLogCreateOrConnectWithoutActorInput[]
    createMany?: AuditLogCreateManyActorInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type EnumRoleFieldUpdateOperationsInput = {
    set?: $Enums.Role
  }

  export type EmployeeProfileUpdateOneWithoutUserNestedInput = {
    create?: XOR<EmployeeProfileCreateWithoutUserInput, EmployeeProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: EmployeeProfileCreateOrConnectWithoutUserInput
    upsert?: EmployeeProfileUpsertWithoutUserInput
    disconnect?: EmployeeProfileWhereInput | boolean
    delete?: EmployeeProfileWhereInput | boolean
    connect?: EmployeeProfileWhereUniqueInput
    update?: XOR<XOR<EmployeeProfileUpdateToOneWithWhereWithoutUserInput, EmployeeProfileUpdateWithoutUserInput>, EmployeeProfileUncheckedUpdateWithoutUserInput>
  }

  export type RefreshTokenUpdateManyWithoutUserNestedInput = {
    create?: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput> | RefreshTokenCreateWithoutUserInput[] | RefreshTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RefreshTokenCreateOrConnectWithoutUserInput | RefreshTokenCreateOrConnectWithoutUserInput[]
    upsert?: RefreshTokenUpsertWithWhereUniqueWithoutUserInput | RefreshTokenUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RefreshTokenCreateManyUserInputEnvelope
    set?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    disconnect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    delete?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    connect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    update?: RefreshTokenUpdateWithWhereUniqueWithoutUserInput | RefreshTokenUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RefreshTokenUpdateManyWithWhereWithoutUserInput | RefreshTokenUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RefreshTokenScalarWhereInput | RefreshTokenScalarWhereInput[]
  }

  export type DailyEntryUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<DailyEntryCreateWithoutEmployeeInput, DailyEntryUncheckedCreateWithoutEmployeeInput> | DailyEntryCreateWithoutEmployeeInput[] | DailyEntryUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: DailyEntryCreateOrConnectWithoutEmployeeInput | DailyEntryCreateOrConnectWithoutEmployeeInput[]
    upsert?: DailyEntryUpsertWithWhereUniqueWithoutEmployeeInput | DailyEntryUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: DailyEntryCreateManyEmployeeInputEnvelope
    set?: DailyEntryWhereUniqueInput | DailyEntryWhereUniqueInput[]
    disconnect?: DailyEntryWhereUniqueInput | DailyEntryWhereUniqueInput[]
    delete?: DailyEntryWhereUniqueInput | DailyEntryWhereUniqueInput[]
    connect?: DailyEntryWhereUniqueInput | DailyEntryWhereUniqueInput[]
    update?: DailyEntryUpdateWithWhereUniqueWithoutEmployeeInput | DailyEntryUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: DailyEntryUpdateManyWithWhereWithoutEmployeeInput | DailyEntryUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: DailyEntryScalarWhereInput | DailyEntryScalarWhereInput[]
  }

  export type PlacementUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<PlacementCreateWithoutEmployeeInput, PlacementUncheckedCreateWithoutEmployeeInput> | PlacementCreateWithoutEmployeeInput[] | PlacementUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: PlacementCreateOrConnectWithoutEmployeeInput | PlacementCreateOrConnectWithoutEmployeeInput[]
    upsert?: PlacementUpsertWithWhereUniqueWithoutEmployeeInput | PlacementUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: PlacementCreateManyEmployeeInputEnvelope
    set?: PlacementWhereUniqueInput | PlacementWhereUniqueInput[]
    disconnect?: PlacementWhereUniqueInput | PlacementWhereUniqueInput[]
    delete?: PlacementWhereUniqueInput | PlacementWhereUniqueInput[]
    connect?: PlacementWhereUniqueInput | PlacementWhereUniqueInput[]
    update?: PlacementUpdateWithWhereUniqueWithoutEmployeeInput | PlacementUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: PlacementUpdateManyWithWhereWithoutEmployeeInput | PlacementUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: PlacementScalarWhereInput | PlacementScalarWhereInput[]
  }

  export type IncentiveUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<IncentiveCreateWithoutEmployeeInput, IncentiveUncheckedCreateWithoutEmployeeInput> | IncentiveCreateWithoutEmployeeInput[] | IncentiveUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: IncentiveCreateOrConnectWithoutEmployeeInput | IncentiveCreateOrConnectWithoutEmployeeInput[]
    upsert?: IncentiveUpsertWithWhereUniqueWithoutEmployeeInput | IncentiveUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: IncentiveCreateManyEmployeeInputEnvelope
    set?: IncentiveWhereUniqueInput | IncentiveWhereUniqueInput[]
    disconnect?: IncentiveWhereUniqueInput | IncentiveWhereUniqueInput[]
    delete?: IncentiveWhereUniqueInput | IncentiveWhereUniqueInput[]
    connect?: IncentiveWhereUniqueInput | IncentiveWhereUniqueInput[]
    update?: IncentiveUpdateWithWhereUniqueWithoutEmployeeInput | IncentiveUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: IncentiveUpdateManyWithWhereWithoutEmployeeInput | IncentiveUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: IncentiveScalarWhereInput | IncentiveScalarWhereInput[]
  }

  export type CampaignAssignmentUpdateManyWithoutUserNestedInput = {
    create?: XOR<CampaignAssignmentCreateWithoutUserInput, CampaignAssignmentUncheckedCreateWithoutUserInput> | CampaignAssignmentCreateWithoutUserInput[] | CampaignAssignmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CampaignAssignmentCreateOrConnectWithoutUserInput | CampaignAssignmentCreateOrConnectWithoutUserInput[]
    upsert?: CampaignAssignmentUpsertWithWhereUniqueWithoutUserInput | CampaignAssignmentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CampaignAssignmentCreateManyUserInputEnvelope
    set?: CampaignAssignmentWhereUniqueInput | CampaignAssignmentWhereUniqueInput[]
    disconnect?: CampaignAssignmentWhereUniqueInput | CampaignAssignmentWhereUniqueInput[]
    delete?: CampaignAssignmentWhereUniqueInput | CampaignAssignmentWhereUniqueInput[]
    connect?: CampaignAssignmentWhereUniqueInput | CampaignAssignmentWhereUniqueInput[]
    update?: CampaignAssignmentUpdateWithWhereUniqueWithoutUserInput | CampaignAssignmentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CampaignAssignmentUpdateManyWithWhereWithoutUserInput | CampaignAssignmentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CampaignAssignmentScalarWhereInput | CampaignAssignmentScalarWhereInput[]
  }

  export type CampaignTeamLeadUpdateManyWithoutUserNestedInput = {
    create?: XOR<CampaignTeamLeadCreateWithoutUserInput, CampaignTeamLeadUncheckedCreateWithoutUserInput> | CampaignTeamLeadCreateWithoutUserInput[] | CampaignTeamLeadUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CampaignTeamLeadCreateOrConnectWithoutUserInput | CampaignTeamLeadCreateOrConnectWithoutUserInput[]
    upsert?: CampaignTeamLeadUpsertWithWhereUniqueWithoutUserInput | CampaignTeamLeadUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CampaignTeamLeadCreateManyUserInputEnvelope
    set?: CampaignTeamLeadWhereUniqueInput | CampaignTeamLeadWhereUniqueInput[]
    disconnect?: CampaignTeamLeadWhereUniqueInput | CampaignTeamLeadWhereUniqueInput[]
    delete?: CampaignTeamLeadWhereUniqueInput | CampaignTeamLeadWhereUniqueInput[]
    connect?: CampaignTeamLeadWhereUniqueInput | CampaignTeamLeadWhereUniqueInput[]
    update?: CampaignTeamLeadUpdateWithWhereUniqueWithoutUserInput | CampaignTeamLeadUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CampaignTeamLeadUpdateManyWithWhereWithoutUserInput | CampaignTeamLeadUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CampaignTeamLeadScalarWhereInput | CampaignTeamLeadScalarWhereInput[]
  }

  export type CampaignActivityUpdateManyWithoutUserNestedInput = {
    create?: XOR<CampaignActivityCreateWithoutUserInput, CampaignActivityUncheckedCreateWithoutUserInput> | CampaignActivityCreateWithoutUserInput[] | CampaignActivityUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CampaignActivityCreateOrConnectWithoutUserInput | CampaignActivityCreateOrConnectWithoutUserInput[]
    upsert?: CampaignActivityUpsertWithWhereUniqueWithoutUserInput | CampaignActivityUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CampaignActivityCreateManyUserInputEnvelope
    set?: CampaignActivityWhereUniqueInput | CampaignActivityWhereUniqueInput[]
    disconnect?: CampaignActivityWhereUniqueInput | CampaignActivityWhereUniqueInput[]
    delete?: CampaignActivityWhereUniqueInput | CampaignActivityWhereUniqueInput[]
    connect?: CampaignActivityWhereUniqueInput | CampaignActivityWhereUniqueInput[]
    update?: CampaignActivityUpdateWithWhereUniqueWithoutUserInput | CampaignActivityUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CampaignActivityUpdateManyWithWhereWithoutUserInput | CampaignActivityUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CampaignActivityScalarWhereInput | CampaignActivityScalarWhereInput[]
  }

  export type CampaignUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<CampaignCreateWithoutCreatedByInput, CampaignUncheckedCreateWithoutCreatedByInput> | CampaignCreateWithoutCreatedByInput[] | CampaignUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: CampaignCreateOrConnectWithoutCreatedByInput | CampaignCreateOrConnectWithoutCreatedByInput[]
    upsert?: CampaignUpsertWithWhereUniqueWithoutCreatedByInput | CampaignUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: CampaignCreateManyCreatedByInputEnvelope
    set?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    disconnect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    delete?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    connect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    update?: CampaignUpdateWithWhereUniqueWithoutCreatedByInput | CampaignUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: CampaignUpdateManyWithWhereWithoutCreatedByInput | CampaignUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: CampaignScalarWhereInput | CampaignScalarWhereInput[]
  }

  export type CampaignImageUpdateManyWithoutUploadedByNestedInput = {
    create?: XOR<CampaignImageCreateWithoutUploadedByInput, CampaignImageUncheckedCreateWithoutUploadedByInput> | CampaignImageCreateWithoutUploadedByInput[] | CampaignImageUncheckedCreateWithoutUploadedByInput[]
    connectOrCreate?: CampaignImageCreateOrConnectWithoutUploadedByInput | CampaignImageCreateOrConnectWithoutUploadedByInput[]
    upsert?: CampaignImageUpsertWithWhereUniqueWithoutUploadedByInput | CampaignImageUpsertWithWhereUniqueWithoutUploadedByInput[]
    createMany?: CampaignImageCreateManyUploadedByInputEnvelope
    set?: CampaignImageWhereUniqueInput | CampaignImageWhereUniqueInput[]
    disconnect?: CampaignImageWhereUniqueInput | CampaignImageWhereUniqueInput[]
    delete?: CampaignImageWhereUniqueInput | CampaignImageWhereUniqueInput[]
    connect?: CampaignImageWhereUniqueInput | CampaignImageWhereUniqueInput[]
    update?: CampaignImageUpdateWithWhereUniqueWithoutUploadedByInput | CampaignImageUpdateWithWhereUniqueWithoutUploadedByInput[]
    updateMany?: CampaignImageUpdateManyWithWhereWithoutUploadedByInput | CampaignImageUpdateManyWithWhereWithoutUploadedByInput[]
    deleteMany?: CampaignImageScalarWhereInput | CampaignImageScalarWhereInput[]
  }

  export type CampaignTaskUpdateManyWithoutCompletedByNestedInput = {
    create?: XOR<CampaignTaskCreateWithoutCompletedByInput, CampaignTaskUncheckedCreateWithoutCompletedByInput> | CampaignTaskCreateWithoutCompletedByInput[] | CampaignTaskUncheckedCreateWithoutCompletedByInput[]
    connectOrCreate?: CampaignTaskCreateOrConnectWithoutCompletedByInput | CampaignTaskCreateOrConnectWithoutCompletedByInput[]
    upsert?: CampaignTaskUpsertWithWhereUniqueWithoutCompletedByInput | CampaignTaskUpsertWithWhereUniqueWithoutCompletedByInput[]
    createMany?: CampaignTaskCreateManyCompletedByInputEnvelope
    set?: CampaignTaskWhereUniqueInput | CampaignTaskWhereUniqueInput[]
    disconnect?: CampaignTaskWhereUniqueInput | CampaignTaskWhereUniqueInput[]
    delete?: CampaignTaskWhereUniqueInput | CampaignTaskWhereUniqueInput[]
    connect?: CampaignTaskWhereUniqueInput | CampaignTaskWhereUniqueInput[]
    update?: CampaignTaskUpdateWithWhereUniqueWithoutCompletedByInput | CampaignTaskUpdateWithWhereUniqueWithoutCompletedByInput[]
    updateMany?: CampaignTaskUpdateManyWithWhereWithoutCompletedByInput | CampaignTaskUpdateManyWithWhereWithoutCompletedByInput[]
    deleteMany?: CampaignTaskScalarWhereInput | CampaignTaskScalarWhereInput[]
  }

  export type EmployeeProfileUpdateManyWithoutManagerNestedInput = {
    create?: XOR<EmployeeProfileCreateWithoutManagerInput, EmployeeProfileUncheckedCreateWithoutManagerInput> | EmployeeProfileCreateWithoutManagerInput[] | EmployeeProfileUncheckedCreateWithoutManagerInput[]
    connectOrCreate?: EmployeeProfileCreateOrConnectWithoutManagerInput | EmployeeProfileCreateOrConnectWithoutManagerInput[]
    upsert?: EmployeeProfileUpsertWithWhereUniqueWithoutManagerInput | EmployeeProfileUpsertWithWhereUniqueWithoutManagerInput[]
    createMany?: EmployeeProfileCreateManyManagerInputEnvelope
    set?: EmployeeProfileWhereUniqueInput | EmployeeProfileWhereUniqueInput[]
    disconnect?: EmployeeProfileWhereUniqueInput | EmployeeProfileWhereUniqueInput[]
    delete?: EmployeeProfileWhereUniqueInput | EmployeeProfileWhereUniqueInput[]
    connect?: EmployeeProfileWhereUniqueInput | EmployeeProfileWhereUniqueInput[]
    update?: EmployeeProfileUpdateWithWhereUniqueWithoutManagerInput | EmployeeProfileUpdateWithWhereUniqueWithoutManagerInput[]
    updateMany?: EmployeeProfileUpdateManyWithWhereWithoutManagerInput | EmployeeProfileUpdateManyWithWhereWithoutManagerInput[]
    deleteMany?: EmployeeProfileScalarWhereInput | EmployeeProfileScalarWhereInput[]
  }

  export type AuditLogUpdateManyWithoutActorNestedInput = {
    create?: XOR<AuditLogCreateWithoutActorInput, AuditLogUncheckedCreateWithoutActorInput> | AuditLogCreateWithoutActorInput[] | AuditLogUncheckedCreateWithoutActorInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutActorInput | AuditLogCreateOrConnectWithoutActorInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutActorInput | AuditLogUpsertWithWhereUniqueWithoutActorInput[]
    createMany?: AuditLogCreateManyActorInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutActorInput | AuditLogUpdateWithWhereUniqueWithoutActorInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutActorInput | AuditLogUpdateManyWithWhereWithoutActorInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type EmployeeProfileUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<EmployeeProfileCreateWithoutUserInput, EmployeeProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: EmployeeProfileCreateOrConnectWithoutUserInput
    upsert?: EmployeeProfileUpsertWithoutUserInput
    disconnect?: EmployeeProfileWhereInput | boolean
    delete?: EmployeeProfileWhereInput | boolean
    connect?: EmployeeProfileWhereUniqueInput
    update?: XOR<XOR<EmployeeProfileUpdateToOneWithWhereWithoutUserInput, EmployeeProfileUpdateWithoutUserInput>, EmployeeProfileUncheckedUpdateWithoutUserInput>
  }

  export type RefreshTokenUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput> | RefreshTokenCreateWithoutUserInput[] | RefreshTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RefreshTokenCreateOrConnectWithoutUserInput | RefreshTokenCreateOrConnectWithoutUserInput[]
    upsert?: RefreshTokenUpsertWithWhereUniqueWithoutUserInput | RefreshTokenUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RefreshTokenCreateManyUserInputEnvelope
    set?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    disconnect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    delete?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    connect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    update?: RefreshTokenUpdateWithWhereUniqueWithoutUserInput | RefreshTokenUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RefreshTokenUpdateManyWithWhereWithoutUserInput | RefreshTokenUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RefreshTokenScalarWhereInput | RefreshTokenScalarWhereInput[]
  }

  export type DailyEntryUncheckedUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<DailyEntryCreateWithoutEmployeeInput, DailyEntryUncheckedCreateWithoutEmployeeInput> | DailyEntryCreateWithoutEmployeeInput[] | DailyEntryUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: DailyEntryCreateOrConnectWithoutEmployeeInput | DailyEntryCreateOrConnectWithoutEmployeeInput[]
    upsert?: DailyEntryUpsertWithWhereUniqueWithoutEmployeeInput | DailyEntryUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: DailyEntryCreateManyEmployeeInputEnvelope
    set?: DailyEntryWhereUniqueInput | DailyEntryWhereUniqueInput[]
    disconnect?: DailyEntryWhereUniqueInput | DailyEntryWhereUniqueInput[]
    delete?: DailyEntryWhereUniqueInput | DailyEntryWhereUniqueInput[]
    connect?: DailyEntryWhereUniqueInput | DailyEntryWhereUniqueInput[]
    update?: DailyEntryUpdateWithWhereUniqueWithoutEmployeeInput | DailyEntryUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: DailyEntryUpdateManyWithWhereWithoutEmployeeInput | DailyEntryUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: DailyEntryScalarWhereInput | DailyEntryScalarWhereInput[]
  }

  export type PlacementUncheckedUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<PlacementCreateWithoutEmployeeInput, PlacementUncheckedCreateWithoutEmployeeInput> | PlacementCreateWithoutEmployeeInput[] | PlacementUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: PlacementCreateOrConnectWithoutEmployeeInput | PlacementCreateOrConnectWithoutEmployeeInput[]
    upsert?: PlacementUpsertWithWhereUniqueWithoutEmployeeInput | PlacementUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: PlacementCreateManyEmployeeInputEnvelope
    set?: PlacementWhereUniqueInput | PlacementWhereUniqueInput[]
    disconnect?: PlacementWhereUniqueInput | PlacementWhereUniqueInput[]
    delete?: PlacementWhereUniqueInput | PlacementWhereUniqueInput[]
    connect?: PlacementWhereUniqueInput | PlacementWhereUniqueInput[]
    update?: PlacementUpdateWithWhereUniqueWithoutEmployeeInput | PlacementUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: PlacementUpdateManyWithWhereWithoutEmployeeInput | PlacementUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: PlacementScalarWhereInput | PlacementScalarWhereInput[]
  }

  export type IncentiveUncheckedUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<IncentiveCreateWithoutEmployeeInput, IncentiveUncheckedCreateWithoutEmployeeInput> | IncentiveCreateWithoutEmployeeInput[] | IncentiveUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: IncentiveCreateOrConnectWithoutEmployeeInput | IncentiveCreateOrConnectWithoutEmployeeInput[]
    upsert?: IncentiveUpsertWithWhereUniqueWithoutEmployeeInput | IncentiveUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: IncentiveCreateManyEmployeeInputEnvelope
    set?: IncentiveWhereUniqueInput | IncentiveWhereUniqueInput[]
    disconnect?: IncentiveWhereUniqueInput | IncentiveWhereUniqueInput[]
    delete?: IncentiveWhereUniqueInput | IncentiveWhereUniqueInput[]
    connect?: IncentiveWhereUniqueInput | IncentiveWhereUniqueInput[]
    update?: IncentiveUpdateWithWhereUniqueWithoutEmployeeInput | IncentiveUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: IncentiveUpdateManyWithWhereWithoutEmployeeInput | IncentiveUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: IncentiveScalarWhereInput | IncentiveScalarWhereInput[]
  }

  export type CampaignAssignmentUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<CampaignAssignmentCreateWithoutUserInput, CampaignAssignmentUncheckedCreateWithoutUserInput> | CampaignAssignmentCreateWithoutUserInput[] | CampaignAssignmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CampaignAssignmentCreateOrConnectWithoutUserInput | CampaignAssignmentCreateOrConnectWithoutUserInput[]
    upsert?: CampaignAssignmentUpsertWithWhereUniqueWithoutUserInput | CampaignAssignmentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CampaignAssignmentCreateManyUserInputEnvelope
    set?: CampaignAssignmentWhereUniqueInput | CampaignAssignmentWhereUniqueInput[]
    disconnect?: CampaignAssignmentWhereUniqueInput | CampaignAssignmentWhereUniqueInput[]
    delete?: CampaignAssignmentWhereUniqueInput | CampaignAssignmentWhereUniqueInput[]
    connect?: CampaignAssignmentWhereUniqueInput | CampaignAssignmentWhereUniqueInput[]
    update?: CampaignAssignmentUpdateWithWhereUniqueWithoutUserInput | CampaignAssignmentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CampaignAssignmentUpdateManyWithWhereWithoutUserInput | CampaignAssignmentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CampaignAssignmentScalarWhereInput | CampaignAssignmentScalarWhereInput[]
  }

  export type CampaignTeamLeadUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<CampaignTeamLeadCreateWithoutUserInput, CampaignTeamLeadUncheckedCreateWithoutUserInput> | CampaignTeamLeadCreateWithoutUserInput[] | CampaignTeamLeadUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CampaignTeamLeadCreateOrConnectWithoutUserInput | CampaignTeamLeadCreateOrConnectWithoutUserInput[]
    upsert?: CampaignTeamLeadUpsertWithWhereUniqueWithoutUserInput | CampaignTeamLeadUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CampaignTeamLeadCreateManyUserInputEnvelope
    set?: CampaignTeamLeadWhereUniqueInput | CampaignTeamLeadWhereUniqueInput[]
    disconnect?: CampaignTeamLeadWhereUniqueInput | CampaignTeamLeadWhereUniqueInput[]
    delete?: CampaignTeamLeadWhereUniqueInput | CampaignTeamLeadWhereUniqueInput[]
    connect?: CampaignTeamLeadWhereUniqueInput | CampaignTeamLeadWhereUniqueInput[]
    update?: CampaignTeamLeadUpdateWithWhereUniqueWithoutUserInput | CampaignTeamLeadUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CampaignTeamLeadUpdateManyWithWhereWithoutUserInput | CampaignTeamLeadUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CampaignTeamLeadScalarWhereInput | CampaignTeamLeadScalarWhereInput[]
  }

  export type CampaignActivityUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<CampaignActivityCreateWithoutUserInput, CampaignActivityUncheckedCreateWithoutUserInput> | CampaignActivityCreateWithoutUserInput[] | CampaignActivityUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CampaignActivityCreateOrConnectWithoutUserInput | CampaignActivityCreateOrConnectWithoutUserInput[]
    upsert?: CampaignActivityUpsertWithWhereUniqueWithoutUserInput | CampaignActivityUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CampaignActivityCreateManyUserInputEnvelope
    set?: CampaignActivityWhereUniqueInput | CampaignActivityWhereUniqueInput[]
    disconnect?: CampaignActivityWhereUniqueInput | CampaignActivityWhereUniqueInput[]
    delete?: CampaignActivityWhereUniqueInput | CampaignActivityWhereUniqueInput[]
    connect?: CampaignActivityWhereUniqueInput | CampaignActivityWhereUniqueInput[]
    update?: CampaignActivityUpdateWithWhereUniqueWithoutUserInput | CampaignActivityUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CampaignActivityUpdateManyWithWhereWithoutUserInput | CampaignActivityUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CampaignActivityScalarWhereInput | CampaignActivityScalarWhereInput[]
  }

  export type CampaignUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<CampaignCreateWithoutCreatedByInput, CampaignUncheckedCreateWithoutCreatedByInput> | CampaignCreateWithoutCreatedByInput[] | CampaignUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: CampaignCreateOrConnectWithoutCreatedByInput | CampaignCreateOrConnectWithoutCreatedByInput[]
    upsert?: CampaignUpsertWithWhereUniqueWithoutCreatedByInput | CampaignUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: CampaignCreateManyCreatedByInputEnvelope
    set?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    disconnect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    delete?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    connect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    update?: CampaignUpdateWithWhereUniqueWithoutCreatedByInput | CampaignUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: CampaignUpdateManyWithWhereWithoutCreatedByInput | CampaignUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: CampaignScalarWhereInput | CampaignScalarWhereInput[]
  }

  export type CampaignImageUncheckedUpdateManyWithoutUploadedByNestedInput = {
    create?: XOR<CampaignImageCreateWithoutUploadedByInput, CampaignImageUncheckedCreateWithoutUploadedByInput> | CampaignImageCreateWithoutUploadedByInput[] | CampaignImageUncheckedCreateWithoutUploadedByInput[]
    connectOrCreate?: CampaignImageCreateOrConnectWithoutUploadedByInput | CampaignImageCreateOrConnectWithoutUploadedByInput[]
    upsert?: CampaignImageUpsertWithWhereUniqueWithoutUploadedByInput | CampaignImageUpsertWithWhereUniqueWithoutUploadedByInput[]
    createMany?: CampaignImageCreateManyUploadedByInputEnvelope
    set?: CampaignImageWhereUniqueInput | CampaignImageWhereUniqueInput[]
    disconnect?: CampaignImageWhereUniqueInput | CampaignImageWhereUniqueInput[]
    delete?: CampaignImageWhereUniqueInput | CampaignImageWhereUniqueInput[]
    connect?: CampaignImageWhereUniqueInput | CampaignImageWhereUniqueInput[]
    update?: CampaignImageUpdateWithWhereUniqueWithoutUploadedByInput | CampaignImageUpdateWithWhereUniqueWithoutUploadedByInput[]
    updateMany?: CampaignImageUpdateManyWithWhereWithoutUploadedByInput | CampaignImageUpdateManyWithWhereWithoutUploadedByInput[]
    deleteMany?: CampaignImageScalarWhereInput | CampaignImageScalarWhereInput[]
  }

  export type CampaignTaskUncheckedUpdateManyWithoutCompletedByNestedInput = {
    create?: XOR<CampaignTaskCreateWithoutCompletedByInput, CampaignTaskUncheckedCreateWithoutCompletedByInput> | CampaignTaskCreateWithoutCompletedByInput[] | CampaignTaskUncheckedCreateWithoutCompletedByInput[]
    connectOrCreate?: CampaignTaskCreateOrConnectWithoutCompletedByInput | CampaignTaskCreateOrConnectWithoutCompletedByInput[]
    upsert?: CampaignTaskUpsertWithWhereUniqueWithoutCompletedByInput | CampaignTaskUpsertWithWhereUniqueWithoutCompletedByInput[]
    createMany?: CampaignTaskCreateManyCompletedByInputEnvelope
    set?: CampaignTaskWhereUniqueInput | CampaignTaskWhereUniqueInput[]
    disconnect?: CampaignTaskWhereUniqueInput | CampaignTaskWhereUniqueInput[]
    delete?: CampaignTaskWhereUniqueInput | CampaignTaskWhereUniqueInput[]
    connect?: CampaignTaskWhereUniqueInput | CampaignTaskWhereUniqueInput[]
    update?: CampaignTaskUpdateWithWhereUniqueWithoutCompletedByInput | CampaignTaskUpdateWithWhereUniqueWithoutCompletedByInput[]
    updateMany?: CampaignTaskUpdateManyWithWhereWithoutCompletedByInput | CampaignTaskUpdateManyWithWhereWithoutCompletedByInput[]
    deleteMany?: CampaignTaskScalarWhereInput | CampaignTaskScalarWhereInput[]
  }

  export type EmployeeProfileUncheckedUpdateManyWithoutManagerNestedInput = {
    create?: XOR<EmployeeProfileCreateWithoutManagerInput, EmployeeProfileUncheckedCreateWithoutManagerInput> | EmployeeProfileCreateWithoutManagerInput[] | EmployeeProfileUncheckedCreateWithoutManagerInput[]
    connectOrCreate?: EmployeeProfileCreateOrConnectWithoutManagerInput | EmployeeProfileCreateOrConnectWithoutManagerInput[]
    upsert?: EmployeeProfileUpsertWithWhereUniqueWithoutManagerInput | EmployeeProfileUpsertWithWhereUniqueWithoutManagerInput[]
    createMany?: EmployeeProfileCreateManyManagerInputEnvelope
    set?: EmployeeProfileWhereUniqueInput | EmployeeProfileWhereUniqueInput[]
    disconnect?: EmployeeProfileWhereUniqueInput | EmployeeProfileWhereUniqueInput[]
    delete?: EmployeeProfileWhereUniqueInput | EmployeeProfileWhereUniqueInput[]
    connect?: EmployeeProfileWhereUniqueInput | EmployeeProfileWhereUniqueInput[]
    update?: EmployeeProfileUpdateWithWhereUniqueWithoutManagerInput | EmployeeProfileUpdateWithWhereUniqueWithoutManagerInput[]
    updateMany?: EmployeeProfileUpdateManyWithWhereWithoutManagerInput | EmployeeProfileUpdateManyWithWhereWithoutManagerInput[]
    deleteMany?: EmployeeProfileScalarWhereInput | EmployeeProfileScalarWhereInput[]
  }

  export type AuditLogUncheckedUpdateManyWithoutActorNestedInput = {
    create?: XOR<AuditLogCreateWithoutActorInput, AuditLogUncheckedCreateWithoutActorInput> | AuditLogCreateWithoutActorInput[] | AuditLogUncheckedCreateWithoutActorInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutActorInput | AuditLogCreateOrConnectWithoutActorInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutActorInput | AuditLogUpsertWithWhereUniqueWithoutActorInput[]
    createMany?: AuditLogCreateManyActorInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutActorInput | AuditLogUpdateWithWhereUniqueWithoutActorInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutActorInput | AuditLogUpdateManyWithWhereWithoutActorInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutEmployeeProfileInput = {
    create?: XOR<UserCreateWithoutEmployeeProfileInput, UserUncheckedCreateWithoutEmployeeProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutEmployeeProfileInput
    connect?: UserWhereUniqueInput
  }

  export type TeamCreateNestedOneWithoutEmployeesInput = {
    create?: XOR<TeamCreateWithoutEmployeesInput, TeamUncheckedCreateWithoutEmployeesInput>
    connectOrCreate?: TeamCreateOrConnectWithoutEmployeesInput
    connect?: TeamWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutLeadEmployeesInput = {
    create?: XOR<UserCreateWithoutLeadEmployeesInput, UserUncheckedCreateWithoutLeadEmployeesInput>
    connectOrCreate?: UserCreateOrConnectWithoutLeadEmployeesInput
    connect?: UserWhereUniqueInput
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type UserUpdateOneRequiredWithoutEmployeeProfileNestedInput = {
    create?: XOR<UserCreateWithoutEmployeeProfileInput, UserUncheckedCreateWithoutEmployeeProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutEmployeeProfileInput
    upsert?: UserUpsertWithoutEmployeeProfileInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutEmployeeProfileInput, UserUpdateWithoutEmployeeProfileInput>, UserUncheckedUpdateWithoutEmployeeProfileInput>
  }

  export type TeamUpdateOneWithoutEmployeesNestedInput = {
    create?: XOR<TeamCreateWithoutEmployeesInput, TeamUncheckedCreateWithoutEmployeesInput>
    connectOrCreate?: TeamCreateOrConnectWithoutEmployeesInput
    upsert?: TeamUpsertWithoutEmployeesInput
    disconnect?: TeamWhereInput | boolean
    delete?: TeamWhereInput | boolean
    connect?: TeamWhereUniqueInput
    update?: XOR<XOR<TeamUpdateToOneWithWhereWithoutEmployeesInput, TeamUpdateWithoutEmployeesInput>, TeamUncheckedUpdateWithoutEmployeesInput>
  }

  export type UserUpdateOneWithoutLeadEmployeesNestedInput = {
    create?: XOR<UserCreateWithoutLeadEmployeesInput, UserUncheckedCreateWithoutLeadEmployeesInput>
    connectOrCreate?: UserCreateOrConnectWithoutLeadEmployeesInput
    upsert?: UserUpsertWithoutLeadEmployeesInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutLeadEmployeesInput, UserUpdateWithoutLeadEmployeesInput>, UserUncheckedUpdateWithoutLeadEmployeesInput>
  }

  export type UserCreateNestedOneWithoutDailyEntriesInput = {
    create?: XOR<UserCreateWithoutDailyEntriesInput, UserUncheckedCreateWithoutDailyEntriesInput>
    connectOrCreate?: UserCreateOrConnectWithoutDailyEntriesInput
    connect?: UserWhereUniqueInput
  }

  export type EnumPlacementTypeFieldUpdateOperationsInput = {
    set?: $Enums.PlacementType
  }

  export type EnumBillingStatusFieldUpdateOperationsInput = {
    set?: $Enums.BillingStatus
  }

  export type UserUpdateOneRequiredWithoutDailyEntriesNestedInput = {
    create?: XOR<UserCreateWithoutDailyEntriesInput, UserUncheckedCreateWithoutDailyEntriesInput>
    connectOrCreate?: UserCreateOrConnectWithoutDailyEntriesInput
    upsert?: UserUpsertWithoutDailyEntriesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDailyEntriesInput, UserUpdateWithoutDailyEntriesInput>, UserUncheckedUpdateWithoutDailyEntriesInput>
  }

  export type UserCreateNestedOneWithoutPlacementsInput = {
    create?: XOR<UserCreateWithoutPlacementsInput, UserUncheckedCreateWithoutPlacementsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPlacementsInput
    connect?: UserWhereUniqueInput
  }

  export type MonthlyBillingCreateNestedManyWithoutPlacementInput = {
    create?: XOR<MonthlyBillingCreateWithoutPlacementInput, MonthlyBillingUncheckedCreateWithoutPlacementInput> | MonthlyBillingCreateWithoutPlacementInput[] | MonthlyBillingUncheckedCreateWithoutPlacementInput[]
    connectOrCreate?: MonthlyBillingCreateOrConnectWithoutPlacementInput | MonthlyBillingCreateOrConnectWithoutPlacementInput[]
    createMany?: MonthlyBillingCreateManyPlacementInputEnvelope
    connect?: MonthlyBillingWhereUniqueInput | MonthlyBillingWhereUniqueInput[]
  }

  export type MonthlyBillingUncheckedCreateNestedManyWithoutPlacementInput = {
    create?: XOR<MonthlyBillingCreateWithoutPlacementInput, MonthlyBillingUncheckedCreateWithoutPlacementInput> | MonthlyBillingCreateWithoutPlacementInput[] | MonthlyBillingUncheckedCreateWithoutPlacementInput[]
    connectOrCreate?: MonthlyBillingCreateOrConnectWithoutPlacementInput | MonthlyBillingCreateOrConnectWithoutPlacementInput[]
    createMany?: MonthlyBillingCreateManyPlacementInputEnvelope
    connect?: MonthlyBillingWhereUniqueInput | MonthlyBillingWhereUniqueInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutPlacementsNestedInput = {
    create?: XOR<UserCreateWithoutPlacementsInput, UserUncheckedCreateWithoutPlacementsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPlacementsInput
    upsert?: UserUpsertWithoutPlacementsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPlacementsInput, UserUpdateWithoutPlacementsInput>, UserUncheckedUpdateWithoutPlacementsInput>
  }

  export type MonthlyBillingUpdateManyWithoutPlacementNestedInput = {
    create?: XOR<MonthlyBillingCreateWithoutPlacementInput, MonthlyBillingUncheckedCreateWithoutPlacementInput> | MonthlyBillingCreateWithoutPlacementInput[] | MonthlyBillingUncheckedCreateWithoutPlacementInput[]
    connectOrCreate?: MonthlyBillingCreateOrConnectWithoutPlacementInput | MonthlyBillingCreateOrConnectWithoutPlacementInput[]
    upsert?: MonthlyBillingUpsertWithWhereUniqueWithoutPlacementInput | MonthlyBillingUpsertWithWhereUniqueWithoutPlacementInput[]
    createMany?: MonthlyBillingCreateManyPlacementInputEnvelope
    set?: MonthlyBillingWhereUniqueInput | MonthlyBillingWhereUniqueInput[]
    disconnect?: MonthlyBillingWhereUniqueInput | MonthlyBillingWhereUniqueInput[]
    delete?: MonthlyBillingWhereUniqueInput | MonthlyBillingWhereUniqueInput[]
    connect?: MonthlyBillingWhereUniqueInput | MonthlyBillingWhereUniqueInput[]
    update?: MonthlyBillingUpdateWithWhereUniqueWithoutPlacementInput | MonthlyBillingUpdateWithWhereUniqueWithoutPlacementInput[]
    updateMany?: MonthlyBillingUpdateManyWithWhereWithoutPlacementInput | MonthlyBillingUpdateManyWithWhereWithoutPlacementInput[]
    deleteMany?: MonthlyBillingScalarWhereInput | MonthlyBillingScalarWhereInput[]
  }

  export type MonthlyBillingUncheckedUpdateManyWithoutPlacementNestedInput = {
    create?: XOR<MonthlyBillingCreateWithoutPlacementInput, MonthlyBillingUncheckedCreateWithoutPlacementInput> | MonthlyBillingCreateWithoutPlacementInput[] | MonthlyBillingUncheckedCreateWithoutPlacementInput[]
    connectOrCreate?: MonthlyBillingCreateOrConnectWithoutPlacementInput | MonthlyBillingCreateOrConnectWithoutPlacementInput[]
    upsert?: MonthlyBillingUpsertWithWhereUniqueWithoutPlacementInput | MonthlyBillingUpsertWithWhereUniqueWithoutPlacementInput[]
    createMany?: MonthlyBillingCreateManyPlacementInputEnvelope
    set?: MonthlyBillingWhereUniqueInput | MonthlyBillingWhereUniqueInput[]
    disconnect?: MonthlyBillingWhereUniqueInput | MonthlyBillingWhereUniqueInput[]
    delete?: MonthlyBillingWhereUniqueInput | MonthlyBillingWhereUniqueInput[]
    connect?: MonthlyBillingWhereUniqueInput | MonthlyBillingWhereUniqueInput[]
    update?: MonthlyBillingUpdateWithWhereUniqueWithoutPlacementInput | MonthlyBillingUpdateWithWhereUniqueWithoutPlacementInput[]
    updateMany?: MonthlyBillingUpdateManyWithWhereWithoutPlacementInput | MonthlyBillingUpdateManyWithWhereWithoutPlacementInput[]
    deleteMany?: MonthlyBillingScalarWhereInput | MonthlyBillingScalarWhereInput[]
  }

  export type PlacementCreateNestedOneWithoutMonthlyBillingsInput = {
    create?: XOR<PlacementCreateWithoutMonthlyBillingsInput, PlacementUncheckedCreateWithoutMonthlyBillingsInput>
    connectOrCreate?: PlacementCreateOrConnectWithoutMonthlyBillingsInput
    connect?: PlacementWhereUniqueInput
  }

  export type PlacementUpdateOneRequiredWithoutMonthlyBillingsNestedInput = {
    create?: XOR<PlacementCreateWithoutMonthlyBillingsInput, PlacementUncheckedCreateWithoutMonthlyBillingsInput>
    connectOrCreate?: PlacementCreateOrConnectWithoutMonthlyBillingsInput
    upsert?: PlacementUpsertWithoutMonthlyBillingsInput
    connect?: PlacementWhereUniqueInput
    update?: XOR<XOR<PlacementUpdateToOneWithWhereWithoutMonthlyBillingsInput, PlacementUpdateWithoutMonthlyBillingsInput>, PlacementUncheckedUpdateWithoutMonthlyBillingsInput>
  }

  export type UserCreateNestedOneWithoutIncentivesInput = {
    create?: XOR<UserCreateWithoutIncentivesInput, UserUncheckedCreateWithoutIncentivesInput>
    connectOrCreate?: UserCreateOrConnectWithoutIncentivesInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutIncentivesNestedInput = {
    create?: XOR<UserCreateWithoutIncentivesInput, UserUncheckedCreateWithoutIncentivesInput>
    connectOrCreate?: UserCreateOrConnectWithoutIncentivesInput
    upsert?: UserUpsertWithoutIncentivesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutIncentivesInput, UserUpdateWithoutIncentivesInput>, UserUncheckedUpdateWithoutIncentivesInput>
  }

  export type UserCreateNestedOneWithoutRefreshTokensInput = {
    create?: XOR<UserCreateWithoutRefreshTokensInput, UserUncheckedCreateWithoutRefreshTokensInput>
    connectOrCreate?: UserCreateOrConnectWithoutRefreshTokensInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutRefreshTokensNestedInput = {
    create?: XOR<UserCreateWithoutRefreshTokensInput, UserUncheckedCreateWithoutRefreshTokensInput>
    connectOrCreate?: UserCreateOrConnectWithoutRefreshTokensInput
    upsert?: UserUpsertWithoutRefreshTokensInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutRefreshTokensInput, UserUpdateWithoutRefreshTokensInput>, UserUncheckedUpdateWithoutRefreshTokensInput>
  }

  export type UserCreateNestedOneWithoutCreatedCampaignsInput = {
    create?: XOR<UserCreateWithoutCreatedCampaignsInput, UserUncheckedCreateWithoutCreatedCampaignsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedCampaignsInput
    connect?: UserWhereUniqueInput
  }

  export type CampaignImageCreateNestedManyWithoutCampaignInput = {
    create?: XOR<CampaignImageCreateWithoutCampaignInput, CampaignImageUncheckedCreateWithoutCampaignInput> | CampaignImageCreateWithoutCampaignInput[] | CampaignImageUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: CampaignImageCreateOrConnectWithoutCampaignInput | CampaignImageCreateOrConnectWithoutCampaignInput[]
    createMany?: CampaignImageCreateManyCampaignInputEnvelope
    connect?: CampaignImageWhereUniqueInput | CampaignImageWhereUniqueInput[]
  }

  export type CampaignTeamLeadCreateNestedManyWithoutCampaignInput = {
    create?: XOR<CampaignTeamLeadCreateWithoutCampaignInput, CampaignTeamLeadUncheckedCreateWithoutCampaignInput> | CampaignTeamLeadCreateWithoutCampaignInput[] | CampaignTeamLeadUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: CampaignTeamLeadCreateOrConnectWithoutCampaignInput | CampaignTeamLeadCreateOrConnectWithoutCampaignInput[]
    createMany?: CampaignTeamLeadCreateManyCampaignInputEnvelope
    connect?: CampaignTeamLeadWhereUniqueInput | CampaignTeamLeadWhereUniqueInput[]
  }

  export type CampaignAssignmentCreateNestedManyWithoutCampaignInput = {
    create?: XOR<CampaignAssignmentCreateWithoutCampaignInput, CampaignAssignmentUncheckedCreateWithoutCampaignInput> | CampaignAssignmentCreateWithoutCampaignInput[] | CampaignAssignmentUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: CampaignAssignmentCreateOrConnectWithoutCampaignInput | CampaignAssignmentCreateOrConnectWithoutCampaignInput[]
    createMany?: CampaignAssignmentCreateManyCampaignInputEnvelope
    connect?: CampaignAssignmentWhereUniqueInput | CampaignAssignmentWhereUniqueInput[]
  }

  export type CampaignTaskCreateNestedManyWithoutCampaignInput = {
    create?: XOR<CampaignTaskCreateWithoutCampaignInput, CampaignTaskUncheckedCreateWithoutCampaignInput> | CampaignTaskCreateWithoutCampaignInput[] | CampaignTaskUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: CampaignTaskCreateOrConnectWithoutCampaignInput | CampaignTaskCreateOrConnectWithoutCampaignInput[]
    createMany?: CampaignTaskCreateManyCampaignInputEnvelope
    connect?: CampaignTaskWhereUniqueInput | CampaignTaskWhereUniqueInput[]
  }

  export type CampaignActivityCreateNestedManyWithoutCampaignInput = {
    create?: XOR<CampaignActivityCreateWithoutCampaignInput, CampaignActivityUncheckedCreateWithoutCampaignInput> | CampaignActivityCreateWithoutCampaignInput[] | CampaignActivityUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: CampaignActivityCreateOrConnectWithoutCampaignInput | CampaignActivityCreateOrConnectWithoutCampaignInput[]
    createMany?: CampaignActivityCreateManyCampaignInputEnvelope
    connect?: CampaignActivityWhereUniqueInput | CampaignActivityWhereUniqueInput[]
  }

  export type CampaignImageUncheckedCreateNestedManyWithoutCampaignInput = {
    create?: XOR<CampaignImageCreateWithoutCampaignInput, CampaignImageUncheckedCreateWithoutCampaignInput> | CampaignImageCreateWithoutCampaignInput[] | CampaignImageUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: CampaignImageCreateOrConnectWithoutCampaignInput | CampaignImageCreateOrConnectWithoutCampaignInput[]
    createMany?: CampaignImageCreateManyCampaignInputEnvelope
    connect?: CampaignImageWhereUniqueInput | CampaignImageWhereUniqueInput[]
  }

  export type CampaignTeamLeadUncheckedCreateNestedManyWithoutCampaignInput = {
    create?: XOR<CampaignTeamLeadCreateWithoutCampaignInput, CampaignTeamLeadUncheckedCreateWithoutCampaignInput> | CampaignTeamLeadCreateWithoutCampaignInput[] | CampaignTeamLeadUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: CampaignTeamLeadCreateOrConnectWithoutCampaignInput | CampaignTeamLeadCreateOrConnectWithoutCampaignInput[]
    createMany?: CampaignTeamLeadCreateManyCampaignInputEnvelope
    connect?: CampaignTeamLeadWhereUniqueInput | CampaignTeamLeadWhereUniqueInput[]
  }

  export type CampaignAssignmentUncheckedCreateNestedManyWithoutCampaignInput = {
    create?: XOR<CampaignAssignmentCreateWithoutCampaignInput, CampaignAssignmentUncheckedCreateWithoutCampaignInput> | CampaignAssignmentCreateWithoutCampaignInput[] | CampaignAssignmentUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: CampaignAssignmentCreateOrConnectWithoutCampaignInput | CampaignAssignmentCreateOrConnectWithoutCampaignInput[]
    createMany?: CampaignAssignmentCreateManyCampaignInputEnvelope
    connect?: CampaignAssignmentWhereUniqueInput | CampaignAssignmentWhereUniqueInput[]
  }

  export type CampaignTaskUncheckedCreateNestedManyWithoutCampaignInput = {
    create?: XOR<CampaignTaskCreateWithoutCampaignInput, CampaignTaskUncheckedCreateWithoutCampaignInput> | CampaignTaskCreateWithoutCampaignInput[] | CampaignTaskUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: CampaignTaskCreateOrConnectWithoutCampaignInput | CampaignTaskCreateOrConnectWithoutCampaignInput[]
    createMany?: CampaignTaskCreateManyCampaignInputEnvelope
    connect?: CampaignTaskWhereUniqueInput | CampaignTaskWhereUniqueInput[]
  }

  export type CampaignActivityUncheckedCreateNestedManyWithoutCampaignInput = {
    create?: XOR<CampaignActivityCreateWithoutCampaignInput, CampaignActivityUncheckedCreateWithoutCampaignInput> | CampaignActivityCreateWithoutCampaignInput[] | CampaignActivityUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: CampaignActivityCreateOrConnectWithoutCampaignInput | CampaignActivityCreateOrConnectWithoutCampaignInput[]
    createMany?: CampaignActivityCreateManyCampaignInputEnvelope
    connect?: CampaignActivityWhereUniqueInput | CampaignActivityWhereUniqueInput[]
  }

  export type EnumCampaignStatusFieldUpdateOperationsInput = {
    set?: $Enums.CampaignStatus
  }

  export type UserUpdateOneRequiredWithoutCreatedCampaignsNestedInput = {
    create?: XOR<UserCreateWithoutCreatedCampaignsInput, UserUncheckedCreateWithoutCreatedCampaignsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedCampaignsInput
    upsert?: UserUpsertWithoutCreatedCampaignsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedCampaignsInput, UserUpdateWithoutCreatedCampaignsInput>, UserUncheckedUpdateWithoutCreatedCampaignsInput>
  }

  export type CampaignImageUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<CampaignImageCreateWithoutCampaignInput, CampaignImageUncheckedCreateWithoutCampaignInput> | CampaignImageCreateWithoutCampaignInput[] | CampaignImageUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: CampaignImageCreateOrConnectWithoutCampaignInput | CampaignImageCreateOrConnectWithoutCampaignInput[]
    upsert?: CampaignImageUpsertWithWhereUniqueWithoutCampaignInput | CampaignImageUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: CampaignImageCreateManyCampaignInputEnvelope
    set?: CampaignImageWhereUniqueInput | CampaignImageWhereUniqueInput[]
    disconnect?: CampaignImageWhereUniqueInput | CampaignImageWhereUniqueInput[]
    delete?: CampaignImageWhereUniqueInput | CampaignImageWhereUniqueInput[]
    connect?: CampaignImageWhereUniqueInput | CampaignImageWhereUniqueInput[]
    update?: CampaignImageUpdateWithWhereUniqueWithoutCampaignInput | CampaignImageUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: CampaignImageUpdateManyWithWhereWithoutCampaignInput | CampaignImageUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: CampaignImageScalarWhereInput | CampaignImageScalarWhereInput[]
  }

  export type CampaignTeamLeadUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<CampaignTeamLeadCreateWithoutCampaignInput, CampaignTeamLeadUncheckedCreateWithoutCampaignInput> | CampaignTeamLeadCreateWithoutCampaignInput[] | CampaignTeamLeadUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: CampaignTeamLeadCreateOrConnectWithoutCampaignInput | CampaignTeamLeadCreateOrConnectWithoutCampaignInput[]
    upsert?: CampaignTeamLeadUpsertWithWhereUniqueWithoutCampaignInput | CampaignTeamLeadUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: CampaignTeamLeadCreateManyCampaignInputEnvelope
    set?: CampaignTeamLeadWhereUniqueInput | CampaignTeamLeadWhereUniqueInput[]
    disconnect?: CampaignTeamLeadWhereUniqueInput | CampaignTeamLeadWhereUniqueInput[]
    delete?: CampaignTeamLeadWhereUniqueInput | CampaignTeamLeadWhereUniqueInput[]
    connect?: CampaignTeamLeadWhereUniqueInput | CampaignTeamLeadWhereUniqueInput[]
    update?: CampaignTeamLeadUpdateWithWhereUniqueWithoutCampaignInput | CampaignTeamLeadUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: CampaignTeamLeadUpdateManyWithWhereWithoutCampaignInput | CampaignTeamLeadUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: CampaignTeamLeadScalarWhereInput | CampaignTeamLeadScalarWhereInput[]
  }

  export type CampaignAssignmentUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<CampaignAssignmentCreateWithoutCampaignInput, CampaignAssignmentUncheckedCreateWithoutCampaignInput> | CampaignAssignmentCreateWithoutCampaignInput[] | CampaignAssignmentUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: CampaignAssignmentCreateOrConnectWithoutCampaignInput | CampaignAssignmentCreateOrConnectWithoutCampaignInput[]
    upsert?: CampaignAssignmentUpsertWithWhereUniqueWithoutCampaignInput | CampaignAssignmentUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: CampaignAssignmentCreateManyCampaignInputEnvelope
    set?: CampaignAssignmentWhereUniqueInput | CampaignAssignmentWhereUniqueInput[]
    disconnect?: CampaignAssignmentWhereUniqueInput | CampaignAssignmentWhereUniqueInput[]
    delete?: CampaignAssignmentWhereUniqueInput | CampaignAssignmentWhereUniqueInput[]
    connect?: CampaignAssignmentWhereUniqueInput | CampaignAssignmentWhereUniqueInput[]
    update?: CampaignAssignmentUpdateWithWhereUniqueWithoutCampaignInput | CampaignAssignmentUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: CampaignAssignmentUpdateManyWithWhereWithoutCampaignInput | CampaignAssignmentUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: CampaignAssignmentScalarWhereInput | CampaignAssignmentScalarWhereInput[]
  }

  export type CampaignTaskUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<CampaignTaskCreateWithoutCampaignInput, CampaignTaskUncheckedCreateWithoutCampaignInput> | CampaignTaskCreateWithoutCampaignInput[] | CampaignTaskUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: CampaignTaskCreateOrConnectWithoutCampaignInput | CampaignTaskCreateOrConnectWithoutCampaignInput[]
    upsert?: CampaignTaskUpsertWithWhereUniqueWithoutCampaignInput | CampaignTaskUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: CampaignTaskCreateManyCampaignInputEnvelope
    set?: CampaignTaskWhereUniqueInput | CampaignTaskWhereUniqueInput[]
    disconnect?: CampaignTaskWhereUniqueInput | CampaignTaskWhereUniqueInput[]
    delete?: CampaignTaskWhereUniqueInput | CampaignTaskWhereUniqueInput[]
    connect?: CampaignTaskWhereUniqueInput | CampaignTaskWhereUniqueInput[]
    update?: CampaignTaskUpdateWithWhereUniqueWithoutCampaignInput | CampaignTaskUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: CampaignTaskUpdateManyWithWhereWithoutCampaignInput | CampaignTaskUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: CampaignTaskScalarWhereInput | CampaignTaskScalarWhereInput[]
  }

  export type CampaignActivityUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<CampaignActivityCreateWithoutCampaignInput, CampaignActivityUncheckedCreateWithoutCampaignInput> | CampaignActivityCreateWithoutCampaignInput[] | CampaignActivityUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: CampaignActivityCreateOrConnectWithoutCampaignInput | CampaignActivityCreateOrConnectWithoutCampaignInput[]
    upsert?: CampaignActivityUpsertWithWhereUniqueWithoutCampaignInput | CampaignActivityUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: CampaignActivityCreateManyCampaignInputEnvelope
    set?: CampaignActivityWhereUniqueInput | CampaignActivityWhereUniqueInput[]
    disconnect?: CampaignActivityWhereUniqueInput | CampaignActivityWhereUniqueInput[]
    delete?: CampaignActivityWhereUniqueInput | CampaignActivityWhereUniqueInput[]
    connect?: CampaignActivityWhereUniqueInput | CampaignActivityWhereUniqueInput[]
    update?: CampaignActivityUpdateWithWhereUniqueWithoutCampaignInput | CampaignActivityUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: CampaignActivityUpdateManyWithWhereWithoutCampaignInput | CampaignActivityUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: CampaignActivityScalarWhereInput | CampaignActivityScalarWhereInput[]
  }

  export type CampaignImageUncheckedUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<CampaignImageCreateWithoutCampaignInput, CampaignImageUncheckedCreateWithoutCampaignInput> | CampaignImageCreateWithoutCampaignInput[] | CampaignImageUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: CampaignImageCreateOrConnectWithoutCampaignInput | CampaignImageCreateOrConnectWithoutCampaignInput[]
    upsert?: CampaignImageUpsertWithWhereUniqueWithoutCampaignInput | CampaignImageUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: CampaignImageCreateManyCampaignInputEnvelope
    set?: CampaignImageWhereUniqueInput | CampaignImageWhereUniqueInput[]
    disconnect?: CampaignImageWhereUniqueInput | CampaignImageWhereUniqueInput[]
    delete?: CampaignImageWhereUniqueInput | CampaignImageWhereUniqueInput[]
    connect?: CampaignImageWhereUniqueInput | CampaignImageWhereUniqueInput[]
    update?: CampaignImageUpdateWithWhereUniqueWithoutCampaignInput | CampaignImageUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: CampaignImageUpdateManyWithWhereWithoutCampaignInput | CampaignImageUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: CampaignImageScalarWhereInput | CampaignImageScalarWhereInput[]
  }

  export type CampaignTeamLeadUncheckedUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<CampaignTeamLeadCreateWithoutCampaignInput, CampaignTeamLeadUncheckedCreateWithoutCampaignInput> | CampaignTeamLeadCreateWithoutCampaignInput[] | CampaignTeamLeadUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: CampaignTeamLeadCreateOrConnectWithoutCampaignInput | CampaignTeamLeadCreateOrConnectWithoutCampaignInput[]
    upsert?: CampaignTeamLeadUpsertWithWhereUniqueWithoutCampaignInput | CampaignTeamLeadUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: CampaignTeamLeadCreateManyCampaignInputEnvelope
    set?: CampaignTeamLeadWhereUniqueInput | CampaignTeamLeadWhereUniqueInput[]
    disconnect?: CampaignTeamLeadWhereUniqueInput | CampaignTeamLeadWhereUniqueInput[]
    delete?: CampaignTeamLeadWhereUniqueInput | CampaignTeamLeadWhereUniqueInput[]
    connect?: CampaignTeamLeadWhereUniqueInput | CampaignTeamLeadWhereUniqueInput[]
    update?: CampaignTeamLeadUpdateWithWhereUniqueWithoutCampaignInput | CampaignTeamLeadUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: CampaignTeamLeadUpdateManyWithWhereWithoutCampaignInput | CampaignTeamLeadUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: CampaignTeamLeadScalarWhereInput | CampaignTeamLeadScalarWhereInput[]
  }

  export type CampaignAssignmentUncheckedUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<CampaignAssignmentCreateWithoutCampaignInput, CampaignAssignmentUncheckedCreateWithoutCampaignInput> | CampaignAssignmentCreateWithoutCampaignInput[] | CampaignAssignmentUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: CampaignAssignmentCreateOrConnectWithoutCampaignInput | CampaignAssignmentCreateOrConnectWithoutCampaignInput[]
    upsert?: CampaignAssignmentUpsertWithWhereUniqueWithoutCampaignInput | CampaignAssignmentUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: CampaignAssignmentCreateManyCampaignInputEnvelope
    set?: CampaignAssignmentWhereUniqueInput | CampaignAssignmentWhereUniqueInput[]
    disconnect?: CampaignAssignmentWhereUniqueInput | CampaignAssignmentWhereUniqueInput[]
    delete?: CampaignAssignmentWhereUniqueInput | CampaignAssignmentWhereUniqueInput[]
    connect?: CampaignAssignmentWhereUniqueInput | CampaignAssignmentWhereUniqueInput[]
    update?: CampaignAssignmentUpdateWithWhereUniqueWithoutCampaignInput | CampaignAssignmentUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: CampaignAssignmentUpdateManyWithWhereWithoutCampaignInput | CampaignAssignmentUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: CampaignAssignmentScalarWhereInput | CampaignAssignmentScalarWhereInput[]
  }

  export type CampaignTaskUncheckedUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<CampaignTaskCreateWithoutCampaignInput, CampaignTaskUncheckedCreateWithoutCampaignInput> | CampaignTaskCreateWithoutCampaignInput[] | CampaignTaskUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: CampaignTaskCreateOrConnectWithoutCampaignInput | CampaignTaskCreateOrConnectWithoutCampaignInput[]
    upsert?: CampaignTaskUpsertWithWhereUniqueWithoutCampaignInput | CampaignTaskUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: CampaignTaskCreateManyCampaignInputEnvelope
    set?: CampaignTaskWhereUniqueInput | CampaignTaskWhereUniqueInput[]
    disconnect?: CampaignTaskWhereUniqueInput | CampaignTaskWhereUniqueInput[]
    delete?: CampaignTaskWhereUniqueInput | CampaignTaskWhereUniqueInput[]
    connect?: CampaignTaskWhereUniqueInput | CampaignTaskWhereUniqueInput[]
    update?: CampaignTaskUpdateWithWhereUniqueWithoutCampaignInput | CampaignTaskUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: CampaignTaskUpdateManyWithWhereWithoutCampaignInput | CampaignTaskUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: CampaignTaskScalarWhereInput | CampaignTaskScalarWhereInput[]
  }

  export type CampaignActivityUncheckedUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<CampaignActivityCreateWithoutCampaignInput, CampaignActivityUncheckedCreateWithoutCampaignInput> | CampaignActivityCreateWithoutCampaignInput[] | CampaignActivityUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: CampaignActivityCreateOrConnectWithoutCampaignInput | CampaignActivityCreateOrConnectWithoutCampaignInput[]
    upsert?: CampaignActivityUpsertWithWhereUniqueWithoutCampaignInput | CampaignActivityUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: CampaignActivityCreateManyCampaignInputEnvelope
    set?: CampaignActivityWhereUniqueInput | CampaignActivityWhereUniqueInput[]
    disconnect?: CampaignActivityWhereUniqueInput | CampaignActivityWhereUniqueInput[]
    delete?: CampaignActivityWhereUniqueInput | CampaignActivityWhereUniqueInput[]
    connect?: CampaignActivityWhereUniqueInput | CampaignActivityWhereUniqueInput[]
    update?: CampaignActivityUpdateWithWhereUniqueWithoutCampaignInput | CampaignActivityUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: CampaignActivityUpdateManyWithWhereWithoutCampaignInput | CampaignActivityUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: CampaignActivityScalarWhereInput | CampaignActivityScalarWhereInput[]
  }

  export type CampaignCreateNestedOneWithoutImagesInput = {
    create?: XOR<CampaignCreateWithoutImagesInput, CampaignUncheckedCreateWithoutImagesInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutImagesInput
    connect?: CampaignWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutUploadedCampaignImagesInput = {
    create?: XOR<UserCreateWithoutUploadedCampaignImagesInput, UserUncheckedCreateWithoutUploadedCampaignImagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutUploadedCampaignImagesInput
    connect?: UserWhereUniqueInput
  }

  export type CampaignUpdateOneRequiredWithoutImagesNestedInput = {
    create?: XOR<CampaignCreateWithoutImagesInput, CampaignUncheckedCreateWithoutImagesInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutImagesInput
    upsert?: CampaignUpsertWithoutImagesInput
    connect?: CampaignWhereUniqueInput
    update?: XOR<XOR<CampaignUpdateToOneWithWhereWithoutImagesInput, CampaignUpdateWithoutImagesInput>, CampaignUncheckedUpdateWithoutImagesInput>
  }

  export type UserUpdateOneRequiredWithoutUploadedCampaignImagesNestedInput = {
    create?: XOR<UserCreateWithoutUploadedCampaignImagesInput, UserUncheckedCreateWithoutUploadedCampaignImagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutUploadedCampaignImagesInput
    upsert?: UserUpsertWithoutUploadedCampaignImagesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUploadedCampaignImagesInput, UserUpdateWithoutUploadedCampaignImagesInput>, UserUncheckedUpdateWithoutUploadedCampaignImagesInput>
  }

  export type CampaignCreateNestedOneWithoutTeamLeadsInput = {
    create?: XOR<CampaignCreateWithoutTeamLeadsInput, CampaignUncheckedCreateWithoutTeamLeadsInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutTeamLeadsInput
    connect?: CampaignWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCampaignTeamLeadsInput = {
    create?: XOR<UserCreateWithoutCampaignTeamLeadsInput, UserUncheckedCreateWithoutCampaignTeamLeadsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCampaignTeamLeadsInput
    connect?: UserWhereUniqueInput
  }

  export type CampaignUpdateOneRequiredWithoutTeamLeadsNestedInput = {
    create?: XOR<CampaignCreateWithoutTeamLeadsInput, CampaignUncheckedCreateWithoutTeamLeadsInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutTeamLeadsInput
    upsert?: CampaignUpsertWithoutTeamLeadsInput
    connect?: CampaignWhereUniqueInput
    update?: XOR<XOR<CampaignUpdateToOneWithWhereWithoutTeamLeadsInput, CampaignUpdateWithoutTeamLeadsInput>, CampaignUncheckedUpdateWithoutTeamLeadsInput>
  }

  export type UserUpdateOneRequiredWithoutCampaignTeamLeadsNestedInput = {
    create?: XOR<UserCreateWithoutCampaignTeamLeadsInput, UserUncheckedCreateWithoutCampaignTeamLeadsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCampaignTeamLeadsInput
    upsert?: UserUpsertWithoutCampaignTeamLeadsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCampaignTeamLeadsInput, UserUpdateWithoutCampaignTeamLeadsInput>, UserUncheckedUpdateWithoutCampaignTeamLeadsInput>
  }

  export type CampaignCreateNestedOneWithoutAssignmentsInput = {
    create?: XOR<CampaignCreateWithoutAssignmentsInput, CampaignUncheckedCreateWithoutAssignmentsInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutAssignmentsInput
    connect?: CampaignWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCampaignAssignmentsInput = {
    create?: XOR<UserCreateWithoutCampaignAssignmentsInput, UserUncheckedCreateWithoutCampaignAssignmentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCampaignAssignmentsInput
    connect?: UserWhereUniqueInput
  }

  export type CampaignTaskCreateNestedManyWithoutAssignmentInput = {
    create?: XOR<CampaignTaskCreateWithoutAssignmentInput, CampaignTaskUncheckedCreateWithoutAssignmentInput> | CampaignTaskCreateWithoutAssignmentInput[] | CampaignTaskUncheckedCreateWithoutAssignmentInput[]
    connectOrCreate?: CampaignTaskCreateOrConnectWithoutAssignmentInput | CampaignTaskCreateOrConnectWithoutAssignmentInput[]
    createMany?: CampaignTaskCreateManyAssignmentInputEnvelope
    connect?: CampaignTaskWhereUniqueInput | CampaignTaskWhereUniqueInput[]
  }

  export type CampaignTaskUncheckedCreateNestedManyWithoutAssignmentInput = {
    create?: XOR<CampaignTaskCreateWithoutAssignmentInput, CampaignTaskUncheckedCreateWithoutAssignmentInput> | CampaignTaskCreateWithoutAssignmentInput[] | CampaignTaskUncheckedCreateWithoutAssignmentInput[]
    connectOrCreate?: CampaignTaskCreateOrConnectWithoutAssignmentInput | CampaignTaskCreateOrConnectWithoutAssignmentInput[]
    createMany?: CampaignTaskCreateManyAssignmentInputEnvelope
    connect?: CampaignTaskWhereUniqueInput | CampaignTaskWhereUniqueInput[]
  }

  export type CampaignUpdateOneRequiredWithoutAssignmentsNestedInput = {
    create?: XOR<CampaignCreateWithoutAssignmentsInput, CampaignUncheckedCreateWithoutAssignmentsInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutAssignmentsInput
    upsert?: CampaignUpsertWithoutAssignmentsInput
    connect?: CampaignWhereUniqueInput
    update?: XOR<XOR<CampaignUpdateToOneWithWhereWithoutAssignmentsInput, CampaignUpdateWithoutAssignmentsInput>, CampaignUncheckedUpdateWithoutAssignmentsInput>
  }

  export type UserUpdateOneRequiredWithoutCampaignAssignmentsNestedInput = {
    create?: XOR<UserCreateWithoutCampaignAssignmentsInput, UserUncheckedCreateWithoutCampaignAssignmentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCampaignAssignmentsInput
    upsert?: UserUpsertWithoutCampaignAssignmentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCampaignAssignmentsInput, UserUpdateWithoutCampaignAssignmentsInput>, UserUncheckedUpdateWithoutCampaignAssignmentsInput>
  }

  export type CampaignTaskUpdateManyWithoutAssignmentNestedInput = {
    create?: XOR<CampaignTaskCreateWithoutAssignmentInput, CampaignTaskUncheckedCreateWithoutAssignmentInput> | CampaignTaskCreateWithoutAssignmentInput[] | CampaignTaskUncheckedCreateWithoutAssignmentInput[]
    connectOrCreate?: CampaignTaskCreateOrConnectWithoutAssignmentInput | CampaignTaskCreateOrConnectWithoutAssignmentInput[]
    upsert?: CampaignTaskUpsertWithWhereUniqueWithoutAssignmentInput | CampaignTaskUpsertWithWhereUniqueWithoutAssignmentInput[]
    createMany?: CampaignTaskCreateManyAssignmentInputEnvelope
    set?: CampaignTaskWhereUniqueInput | CampaignTaskWhereUniqueInput[]
    disconnect?: CampaignTaskWhereUniqueInput | CampaignTaskWhereUniqueInput[]
    delete?: CampaignTaskWhereUniqueInput | CampaignTaskWhereUniqueInput[]
    connect?: CampaignTaskWhereUniqueInput | CampaignTaskWhereUniqueInput[]
    update?: CampaignTaskUpdateWithWhereUniqueWithoutAssignmentInput | CampaignTaskUpdateWithWhereUniqueWithoutAssignmentInput[]
    updateMany?: CampaignTaskUpdateManyWithWhereWithoutAssignmentInput | CampaignTaskUpdateManyWithWhereWithoutAssignmentInput[]
    deleteMany?: CampaignTaskScalarWhereInput | CampaignTaskScalarWhereInput[]
  }

  export type CampaignTaskUncheckedUpdateManyWithoutAssignmentNestedInput = {
    create?: XOR<CampaignTaskCreateWithoutAssignmentInput, CampaignTaskUncheckedCreateWithoutAssignmentInput> | CampaignTaskCreateWithoutAssignmentInput[] | CampaignTaskUncheckedCreateWithoutAssignmentInput[]
    connectOrCreate?: CampaignTaskCreateOrConnectWithoutAssignmentInput | CampaignTaskCreateOrConnectWithoutAssignmentInput[]
    upsert?: CampaignTaskUpsertWithWhereUniqueWithoutAssignmentInput | CampaignTaskUpsertWithWhereUniqueWithoutAssignmentInput[]
    createMany?: CampaignTaskCreateManyAssignmentInputEnvelope
    set?: CampaignTaskWhereUniqueInput | CampaignTaskWhereUniqueInput[]
    disconnect?: CampaignTaskWhereUniqueInput | CampaignTaskWhereUniqueInput[]
    delete?: CampaignTaskWhereUniqueInput | CampaignTaskWhereUniqueInput[]
    connect?: CampaignTaskWhereUniqueInput | CampaignTaskWhereUniqueInput[]
    update?: CampaignTaskUpdateWithWhereUniqueWithoutAssignmentInput | CampaignTaskUpdateWithWhereUniqueWithoutAssignmentInput[]
    updateMany?: CampaignTaskUpdateManyWithWhereWithoutAssignmentInput | CampaignTaskUpdateManyWithWhereWithoutAssignmentInput[]
    deleteMany?: CampaignTaskScalarWhereInput | CampaignTaskScalarWhereInput[]
  }

  export type CampaignCreateNestedOneWithoutTasksInput = {
    create?: XOR<CampaignCreateWithoutTasksInput, CampaignUncheckedCreateWithoutTasksInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutTasksInput
    connect?: CampaignWhereUniqueInput
  }

  export type CampaignAssignmentCreateNestedOneWithoutTasksInput = {
    create?: XOR<CampaignAssignmentCreateWithoutTasksInput, CampaignAssignmentUncheckedCreateWithoutTasksInput>
    connectOrCreate?: CampaignAssignmentCreateOrConnectWithoutTasksInput
    connect?: CampaignAssignmentWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCompletedCampaignTasksInput = {
    create?: XOR<UserCreateWithoutCompletedCampaignTasksInput, UserUncheckedCreateWithoutCompletedCampaignTasksInput>
    connectOrCreate?: UserCreateOrConnectWithoutCompletedCampaignTasksInput
    connect?: UserWhereUniqueInput
  }

  export type CampaignUpdateOneRequiredWithoutTasksNestedInput = {
    create?: XOR<CampaignCreateWithoutTasksInput, CampaignUncheckedCreateWithoutTasksInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutTasksInput
    upsert?: CampaignUpsertWithoutTasksInput
    connect?: CampaignWhereUniqueInput
    update?: XOR<XOR<CampaignUpdateToOneWithWhereWithoutTasksInput, CampaignUpdateWithoutTasksInput>, CampaignUncheckedUpdateWithoutTasksInput>
  }

  export type CampaignAssignmentUpdateOneWithoutTasksNestedInput = {
    create?: XOR<CampaignAssignmentCreateWithoutTasksInput, CampaignAssignmentUncheckedCreateWithoutTasksInput>
    connectOrCreate?: CampaignAssignmentCreateOrConnectWithoutTasksInput
    upsert?: CampaignAssignmentUpsertWithoutTasksInput
    disconnect?: CampaignAssignmentWhereInput | boolean
    delete?: CampaignAssignmentWhereInput | boolean
    connect?: CampaignAssignmentWhereUniqueInput
    update?: XOR<XOR<CampaignAssignmentUpdateToOneWithWhereWithoutTasksInput, CampaignAssignmentUpdateWithoutTasksInput>, CampaignAssignmentUncheckedUpdateWithoutTasksInput>
  }

  export type UserUpdateOneWithoutCompletedCampaignTasksNestedInput = {
    create?: XOR<UserCreateWithoutCompletedCampaignTasksInput, UserUncheckedCreateWithoutCompletedCampaignTasksInput>
    connectOrCreate?: UserCreateOrConnectWithoutCompletedCampaignTasksInput
    upsert?: UserUpsertWithoutCompletedCampaignTasksInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCompletedCampaignTasksInput, UserUpdateWithoutCompletedCampaignTasksInput>, UserUncheckedUpdateWithoutCompletedCampaignTasksInput>
  }

  export type CampaignCreateNestedOneWithoutActivitiesInput = {
    create?: XOR<CampaignCreateWithoutActivitiesInput, CampaignUncheckedCreateWithoutActivitiesInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutActivitiesInput
    connect?: CampaignWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCampaignActivitiesInput = {
    create?: XOR<UserCreateWithoutCampaignActivitiesInput, UserUncheckedCreateWithoutCampaignActivitiesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCampaignActivitiesInput
    connect?: UserWhereUniqueInput
  }

  export type CampaignUpdateOneRequiredWithoutActivitiesNestedInput = {
    create?: XOR<CampaignCreateWithoutActivitiesInput, CampaignUncheckedCreateWithoutActivitiesInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutActivitiesInput
    upsert?: CampaignUpsertWithoutActivitiesInput
    connect?: CampaignWhereUniqueInput
    update?: XOR<XOR<CampaignUpdateToOneWithWhereWithoutActivitiesInput, CampaignUpdateWithoutActivitiesInput>, CampaignUncheckedUpdateWithoutActivitiesInput>
  }

  export type UserUpdateOneRequiredWithoutCampaignActivitiesNestedInput = {
    create?: XOR<UserCreateWithoutCampaignActivitiesInput, UserUncheckedCreateWithoutCampaignActivitiesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCampaignActivitiesInput
    upsert?: UserUpsertWithoutCampaignActivitiesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCampaignActivitiesInput, UserUpdateWithoutCampaignActivitiesInput>, UserUncheckedUpdateWithoutCampaignActivitiesInput>
  }

  export type UserCreateNestedOneWithoutAuditLogsInput = {
    create?: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutAuditLogsNestedInput = {
    create?: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogsInput
    upsert?: UserUpsertWithoutAuditLogsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAuditLogsInput, UserUpdateWithoutAuditLogsInput>, UserUncheckedUpdateWithoutAuditLogsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type NestedEnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumPlacementTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PlacementType | EnumPlacementTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PlacementType[] | ListEnumPlacementTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PlacementType[] | ListEnumPlacementTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPlacementTypeFilter<$PrismaModel> | $Enums.PlacementType
  }

  export type NestedEnumBillingStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.BillingStatus | EnumBillingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BillingStatus[] | ListEnumBillingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BillingStatus[] | ListEnumBillingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBillingStatusFilter<$PrismaModel> | $Enums.BillingStatus
  }

  export type NestedEnumPlacementTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PlacementType | EnumPlacementTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PlacementType[] | ListEnumPlacementTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PlacementType[] | ListEnumPlacementTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPlacementTypeWithAggregatesFilter<$PrismaModel> | $Enums.PlacementType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPlacementTypeFilter<$PrismaModel>
    _max?: NestedEnumPlacementTypeFilter<$PrismaModel>
  }

  export type NestedEnumBillingStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BillingStatus | EnumBillingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BillingStatus[] | ListEnumBillingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BillingStatus[] | ListEnumBillingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBillingStatusWithAggregatesFilter<$PrismaModel> | $Enums.BillingStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBillingStatusFilter<$PrismaModel>
    _max?: NestedEnumBillingStatusFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumCampaignStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.CampaignStatus | EnumCampaignStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CampaignStatus[] | ListEnumCampaignStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CampaignStatus[] | ListEnumCampaignStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCampaignStatusFilter<$PrismaModel> | $Enums.CampaignStatus
  }

  export type NestedEnumCampaignStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CampaignStatus | EnumCampaignStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CampaignStatus[] | ListEnumCampaignStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CampaignStatus[] | ListEnumCampaignStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCampaignStatusWithAggregatesFilter<$PrismaModel> | $Enums.CampaignStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCampaignStatusFilter<$PrismaModel>
    _max?: NestedEnumCampaignStatusFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type EmployeeProfileCreateWithoutTeamInput = {
    level?: string | null
    yearlyTarget: Decimal | DecimalJsLike | number | string
    isActive?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutEmployeeProfileInput
    manager?: UserCreateNestedOneWithoutLeadEmployeesInput
  }

  export type EmployeeProfileUncheckedCreateWithoutTeamInput = {
    id: string
    managerId?: string | null
    level?: string | null
    yearlyTarget: Decimal | DecimalJsLike | number | string
    isActive?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmployeeProfileCreateOrConnectWithoutTeamInput = {
    where: EmployeeProfileWhereUniqueInput
    create: XOR<EmployeeProfileCreateWithoutTeamInput, EmployeeProfileUncheckedCreateWithoutTeamInput>
  }

  export type EmployeeProfileCreateManyTeamInputEnvelope = {
    data: EmployeeProfileCreateManyTeamInput | EmployeeProfileCreateManyTeamInput[]
    skipDuplicates?: boolean
  }

  export type EmployeeProfileUpsertWithWhereUniqueWithoutTeamInput = {
    where: EmployeeProfileWhereUniqueInput
    update: XOR<EmployeeProfileUpdateWithoutTeamInput, EmployeeProfileUncheckedUpdateWithoutTeamInput>
    create: XOR<EmployeeProfileCreateWithoutTeamInput, EmployeeProfileUncheckedCreateWithoutTeamInput>
  }

  export type EmployeeProfileUpdateWithWhereUniqueWithoutTeamInput = {
    where: EmployeeProfileWhereUniqueInput
    data: XOR<EmployeeProfileUpdateWithoutTeamInput, EmployeeProfileUncheckedUpdateWithoutTeamInput>
  }

  export type EmployeeProfileUpdateManyWithWhereWithoutTeamInput = {
    where: EmployeeProfileScalarWhereInput
    data: XOR<EmployeeProfileUpdateManyMutationInput, EmployeeProfileUncheckedUpdateManyWithoutTeamInput>
  }

  export type EmployeeProfileScalarWhereInput = {
    AND?: EmployeeProfileScalarWhereInput | EmployeeProfileScalarWhereInput[]
    OR?: EmployeeProfileScalarWhereInput[]
    NOT?: EmployeeProfileScalarWhereInput | EmployeeProfileScalarWhereInput[]
    id?: StringFilter<"EmployeeProfile"> | string
    teamId?: StringNullableFilter<"EmployeeProfile"> | string | null
    managerId?: StringNullableFilter<"EmployeeProfile"> | string | null
    level?: StringNullableFilter<"EmployeeProfile"> | string | null
    yearlyTarget?: DecimalFilter<"EmployeeProfile"> | Decimal | DecimalJsLike | number | string
    isActive?: BoolFilter<"EmployeeProfile"> | boolean
    deletedAt?: DateTimeNullableFilter<"EmployeeProfile"> | Date | string | null
    createdAt?: DateTimeFilter<"EmployeeProfile"> | Date | string
    updatedAt?: DateTimeFilter<"EmployeeProfile"> | Date | string
  }

  export type EmployeeProfileCreateWithoutUserInput = {
    level?: string | null
    yearlyTarget: Decimal | DecimalJsLike | number | string
    isActive?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    team?: TeamCreateNestedOneWithoutEmployeesInput
    manager?: UserCreateNestedOneWithoutLeadEmployeesInput
  }

  export type EmployeeProfileUncheckedCreateWithoutUserInput = {
    teamId?: string | null
    managerId?: string | null
    level?: string | null
    yearlyTarget: Decimal | DecimalJsLike | number | string
    isActive?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmployeeProfileCreateOrConnectWithoutUserInput = {
    where: EmployeeProfileWhereUniqueInput
    create: XOR<EmployeeProfileCreateWithoutUserInput, EmployeeProfileUncheckedCreateWithoutUserInput>
  }

  export type RefreshTokenCreateWithoutUserInput = {
    id?: string
    token: string
    isRevoked?: boolean
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type RefreshTokenUncheckedCreateWithoutUserInput = {
    id?: string
    token: string
    isRevoked?: boolean
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type RefreshTokenCreateOrConnectWithoutUserInput = {
    where: RefreshTokenWhereUniqueInput
    create: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput>
  }

  export type RefreshTokenCreateManyUserInputEnvelope = {
    data: RefreshTokenCreateManyUserInput | RefreshTokenCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type DailyEntryCreateWithoutEmployeeInput = {
    id?: string
    date: Date | string
    clientName: string
    placementType: $Enums.PlacementType
    revenue: Decimal | DecimalJsLike | number | string
    marginPercent: Decimal | DecimalJsLike | number | string
    billingStatus: $Enums.BillingStatus
    doi: Date | string
    doj: Date | string
    remarks?: string | null
    createdAt?: Date | string
  }

  export type DailyEntryUncheckedCreateWithoutEmployeeInput = {
    id?: string
    date: Date | string
    clientName: string
    placementType: $Enums.PlacementType
    revenue: Decimal | DecimalJsLike | number | string
    marginPercent: Decimal | DecimalJsLike | number | string
    billingStatus: $Enums.BillingStatus
    doi: Date | string
    doj: Date | string
    remarks?: string | null
    createdAt?: Date | string
  }

  export type DailyEntryCreateOrConnectWithoutEmployeeInput = {
    where: DailyEntryWhereUniqueInput
    create: XOR<DailyEntryCreateWithoutEmployeeInput, DailyEntryUncheckedCreateWithoutEmployeeInput>
  }

  export type DailyEntryCreateManyEmployeeInputEnvelope = {
    data: DailyEntryCreateManyEmployeeInput | DailyEntryCreateManyEmployeeInput[]
    skipDuplicates?: boolean
  }

  export type PlacementCreateWithoutEmployeeInput = {
    id?: string
    candidateName: string
    clientName: string
    doi: Date | string
    doj: Date | string
    daysCompleted: number
    placementType: $Enums.PlacementType
    billedHours?: number | null
    marginPercent: Decimal | DecimalJsLike | number | string
    revenue: Decimal | DecimalJsLike | number | string
    billingStatus: $Enums.BillingStatus
    incentivePayoutEta?: Date | string | null
    incentiveAmountInr: Decimal | DecimalJsLike | number | string
    incentivePaid: boolean
    qualifier: boolean
    createdAt?: Date | string
    monthlyBillings?: MonthlyBillingCreateNestedManyWithoutPlacementInput
  }

  export type PlacementUncheckedCreateWithoutEmployeeInput = {
    id?: string
    candidateName: string
    clientName: string
    doi: Date | string
    doj: Date | string
    daysCompleted: number
    placementType: $Enums.PlacementType
    billedHours?: number | null
    marginPercent: Decimal | DecimalJsLike | number | string
    revenue: Decimal | DecimalJsLike | number | string
    billingStatus: $Enums.BillingStatus
    incentivePayoutEta?: Date | string | null
    incentiveAmountInr: Decimal | DecimalJsLike | number | string
    incentivePaid: boolean
    qualifier: boolean
    createdAt?: Date | string
    monthlyBillings?: MonthlyBillingUncheckedCreateNestedManyWithoutPlacementInput
  }

  export type PlacementCreateOrConnectWithoutEmployeeInput = {
    where: PlacementWhereUniqueInput
    create: XOR<PlacementCreateWithoutEmployeeInput, PlacementUncheckedCreateWithoutEmployeeInput>
  }

  export type PlacementCreateManyEmployeeInputEnvelope = {
    data: PlacementCreateManyEmployeeInput | PlacementCreateManyEmployeeInput[]
    skipDuplicates?: boolean
  }

  export type IncentiveCreateWithoutEmployeeInput = {
    id?: string
    periodStart: Date | string
    periodEnd: Date | string
    revenueTotal: Decimal | DecimalJsLike | number | string
    slabName: string
    amountUsd: Decimal | DecimalJsLike | number | string
    amountInr: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
  }

  export type IncentiveUncheckedCreateWithoutEmployeeInput = {
    id?: string
    periodStart: Date | string
    periodEnd: Date | string
    revenueTotal: Decimal | DecimalJsLike | number | string
    slabName: string
    amountUsd: Decimal | DecimalJsLike | number | string
    amountInr: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
  }

  export type IncentiveCreateOrConnectWithoutEmployeeInput = {
    where: IncentiveWhereUniqueInput
    create: XOR<IncentiveCreateWithoutEmployeeInput, IncentiveUncheckedCreateWithoutEmployeeInput>
  }

  export type IncentiveCreateManyEmployeeInputEnvelope = {
    data: IncentiveCreateManyEmployeeInput | IncentiveCreateManyEmployeeInput[]
    skipDuplicates?: boolean
  }

  export type CampaignAssignmentCreateWithoutUserInput = {
    id?: string
    role: $Enums.Role
    targetAmount: Decimal | DecimalJsLike | number | string
    progressPercent?: number
    isCompleted?: boolean
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    campaign: CampaignCreateNestedOneWithoutAssignmentsInput
    tasks?: CampaignTaskCreateNestedManyWithoutAssignmentInput
  }

  export type CampaignAssignmentUncheckedCreateWithoutUserInput = {
    id?: string
    campaignId: string
    role: $Enums.Role
    targetAmount: Decimal | DecimalJsLike | number | string
    progressPercent?: number
    isCompleted?: boolean
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tasks?: CampaignTaskUncheckedCreateNestedManyWithoutAssignmentInput
  }

  export type CampaignAssignmentCreateOrConnectWithoutUserInput = {
    where: CampaignAssignmentWhereUniqueInput
    create: XOR<CampaignAssignmentCreateWithoutUserInput, CampaignAssignmentUncheckedCreateWithoutUserInput>
  }

  export type CampaignAssignmentCreateManyUserInputEnvelope = {
    data: CampaignAssignmentCreateManyUserInput | CampaignAssignmentCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type CampaignTeamLeadCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    campaign: CampaignCreateNestedOneWithoutTeamLeadsInput
  }

  export type CampaignTeamLeadUncheckedCreateWithoutUserInput = {
    id?: string
    campaignId: string
    createdAt?: Date | string
  }

  export type CampaignTeamLeadCreateOrConnectWithoutUserInput = {
    where: CampaignTeamLeadWhereUniqueInput
    create: XOR<CampaignTeamLeadCreateWithoutUserInput, CampaignTeamLeadUncheckedCreateWithoutUserInput>
  }

  export type CampaignTeamLeadCreateManyUserInputEnvelope = {
    data: CampaignTeamLeadCreateManyUserInput | CampaignTeamLeadCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type CampaignActivityCreateWithoutUserInput = {
    id?: string
    action: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    campaign: CampaignCreateNestedOneWithoutActivitiesInput
  }

  export type CampaignActivityUncheckedCreateWithoutUserInput = {
    id?: string
    campaignId: string
    action: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type CampaignActivityCreateOrConnectWithoutUserInput = {
    where: CampaignActivityWhereUniqueInput
    create: XOR<CampaignActivityCreateWithoutUserInput, CampaignActivityUncheckedCreateWithoutUserInput>
  }

  export type CampaignActivityCreateManyUserInputEnvelope = {
    data: CampaignActivityCreateManyUserInput | CampaignActivityCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type CampaignCreateWithoutCreatedByInput = {
    id?: string
    name: string
    description?: string | null
    objective?: string | null
    status?: $Enums.CampaignStatus
    targetAmount: Decimal | DecimalJsLike | number | string
    startDate: Date | string
    endDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    images?: CampaignImageCreateNestedManyWithoutCampaignInput
    teamLeads?: CampaignTeamLeadCreateNestedManyWithoutCampaignInput
    assignments?: CampaignAssignmentCreateNestedManyWithoutCampaignInput
    tasks?: CampaignTaskCreateNestedManyWithoutCampaignInput
    activities?: CampaignActivityCreateNestedManyWithoutCampaignInput
  }

  export type CampaignUncheckedCreateWithoutCreatedByInput = {
    id?: string
    name: string
    description?: string | null
    objective?: string | null
    status?: $Enums.CampaignStatus
    targetAmount: Decimal | DecimalJsLike | number | string
    startDate: Date | string
    endDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    images?: CampaignImageUncheckedCreateNestedManyWithoutCampaignInput
    teamLeads?: CampaignTeamLeadUncheckedCreateNestedManyWithoutCampaignInput
    assignments?: CampaignAssignmentUncheckedCreateNestedManyWithoutCampaignInput
    tasks?: CampaignTaskUncheckedCreateNestedManyWithoutCampaignInput
    activities?: CampaignActivityUncheckedCreateNestedManyWithoutCampaignInput
  }

  export type CampaignCreateOrConnectWithoutCreatedByInput = {
    where: CampaignWhereUniqueInput
    create: XOR<CampaignCreateWithoutCreatedByInput, CampaignUncheckedCreateWithoutCreatedByInput>
  }

  export type CampaignCreateManyCreatedByInputEnvelope = {
    data: CampaignCreateManyCreatedByInput | CampaignCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type CampaignImageCreateWithoutUploadedByInput = {
    id?: string
    url: string
    title?: string | null
    description?: string | null
    createdAt?: Date | string
    campaign: CampaignCreateNestedOneWithoutImagesInput
  }

  export type CampaignImageUncheckedCreateWithoutUploadedByInput = {
    id?: string
    campaignId: string
    url: string
    title?: string | null
    description?: string | null
    createdAt?: Date | string
  }

  export type CampaignImageCreateOrConnectWithoutUploadedByInput = {
    where: CampaignImageWhereUniqueInput
    create: XOR<CampaignImageCreateWithoutUploadedByInput, CampaignImageUncheckedCreateWithoutUploadedByInput>
  }

  export type CampaignImageCreateManyUploadedByInputEnvelope = {
    data: CampaignImageCreateManyUploadedByInput | CampaignImageCreateManyUploadedByInput[]
    skipDuplicates?: boolean
  }

  export type CampaignTaskCreateWithoutCompletedByInput = {
    id?: string
    title: string
    description?: string | null
    isCompleted?: boolean
    dueDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    campaign: CampaignCreateNestedOneWithoutTasksInput
    assignment?: CampaignAssignmentCreateNestedOneWithoutTasksInput
  }

  export type CampaignTaskUncheckedCreateWithoutCompletedByInput = {
    id?: string
    campaignId: string
    assignmentId?: string | null
    title: string
    description?: string | null
    isCompleted?: boolean
    dueDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CampaignTaskCreateOrConnectWithoutCompletedByInput = {
    where: CampaignTaskWhereUniqueInput
    create: XOR<CampaignTaskCreateWithoutCompletedByInput, CampaignTaskUncheckedCreateWithoutCompletedByInput>
  }

  export type CampaignTaskCreateManyCompletedByInputEnvelope = {
    data: CampaignTaskCreateManyCompletedByInput | CampaignTaskCreateManyCompletedByInput[]
    skipDuplicates?: boolean
  }

  export type EmployeeProfileCreateWithoutManagerInput = {
    level?: string | null
    yearlyTarget: Decimal | DecimalJsLike | number | string
    isActive?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutEmployeeProfileInput
    team?: TeamCreateNestedOneWithoutEmployeesInput
  }

  export type EmployeeProfileUncheckedCreateWithoutManagerInput = {
    id: string
    teamId?: string | null
    level?: string | null
    yearlyTarget: Decimal | DecimalJsLike | number | string
    isActive?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmployeeProfileCreateOrConnectWithoutManagerInput = {
    where: EmployeeProfileWhereUniqueInput
    create: XOR<EmployeeProfileCreateWithoutManagerInput, EmployeeProfileUncheckedCreateWithoutManagerInput>
  }

  export type EmployeeProfileCreateManyManagerInputEnvelope = {
    data: EmployeeProfileCreateManyManagerInput | EmployeeProfileCreateManyManagerInput[]
    skipDuplicates?: boolean
  }

  export type AuditLogCreateWithoutActorInput = {
    id?: string
    action: string
    entityType: string
    entityId: string
    changes?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AuditLogUncheckedCreateWithoutActorInput = {
    id?: string
    action: string
    entityType: string
    entityId: string
    changes?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AuditLogCreateOrConnectWithoutActorInput = {
    where: AuditLogWhereUniqueInput
    create: XOR<AuditLogCreateWithoutActorInput, AuditLogUncheckedCreateWithoutActorInput>
  }

  export type AuditLogCreateManyActorInputEnvelope = {
    data: AuditLogCreateManyActorInput | AuditLogCreateManyActorInput[]
    skipDuplicates?: boolean
  }

  export type EmployeeProfileUpsertWithoutUserInput = {
    update: XOR<EmployeeProfileUpdateWithoutUserInput, EmployeeProfileUncheckedUpdateWithoutUserInput>
    create: XOR<EmployeeProfileCreateWithoutUserInput, EmployeeProfileUncheckedCreateWithoutUserInput>
    where?: EmployeeProfileWhereInput
  }

  export type EmployeeProfileUpdateToOneWithWhereWithoutUserInput = {
    where?: EmployeeProfileWhereInput
    data: XOR<EmployeeProfileUpdateWithoutUserInput, EmployeeProfileUncheckedUpdateWithoutUserInput>
  }

  export type EmployeeProfileUpdateWithoutUserInput = {
    level?: NullableStringFieldUpdateOperationsInput | string | null
    yearlyTarget?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    team?: TeamUpdateOneWithoutEmployeesNestedInput
    manager?: UserUpdateOneWithoutLeadEmployeesNestedInput
  }

  export type EmployeeProfileUncheckedUpdateWithoutUserInput = {
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    yearlyTarget?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefreshTokenUpsertWithWhereUniqueWithoutUserInput = {
    where: RefreshTokenWhereUniqueInput
    update: XOR<RefreshTokenUpdateWithoutUserInput, RefreshTokenUncheckedUpdateWithoutUserInput>
    create: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput>
  }

  export type RefreshTokenUpdateWithWhereUniqueWithoutUserInput = {
    where: RefreshTokenWhereUniqueInput
    data: XOR<RefreshTokenUpdateWithoutUserInput, RefreshTokenUncheckedUpdateWithoutUserInput>
  }

  export type RefreshTokenUpdateManyWithWhereWithoutUserInput = {
    where: RefreshTokenScalarWhereInput
    data: XOR<RefreshTokenUpdateManyMutationInput, RefreshTokenUncheckedUpdateManyWithoutUserInput>
  }

  export type RefreshTokenScalarWhereInput = {
    AND?: RefreshTokenScalarWhereInput | RefreshTokenScalarWhereInput[]
    OR?: RefreshTokenScalarWhereInput[]
    NOT?: RefreshTokenScalarWhereInput | RefreshTokenScalarWhereInput[]
    id?: StringFilter<"RefreshToken"> | string
    token?: StringFilter<"RefreshToken"> | string
    userId?: StringFilter<"RefreshToken"> | string
    isRevoked?: BoolFilter<"RefreshToken"> | boolean
    expiresAt?: DateTimeFilter<"RefreshToken"> | Date | string
    createdAt?: DateTimeFilter<"RefreshToken"> | Date | string
  }

  export type DailyEntryUpsertWithWhereUniqueWithoutEmployeeInput = {
    where: DailyEntryWhereUniqueInput
    update: XOR<DailyEntryUpdateWithoutEmployeeInput, DailyEntryUncheckedUpdateWithoutEmployeeInput>
    create: XOR<DailyEntryCreateWithoutEmployeeInput, DailyEntryUncheckedCreateWithoutEmployeeInput>
  }

  export type DailyEntryUpdateWithWhereUniqueWithoutEmployeeInput = {
    where: DailyEntryWhereUniqueInput
    data: XOR<DailyEntryUpdateWithoutEmployeeInput, DailyEntryUncheckedUpdateWithoutEmployeeInput>
  }

  export type DailyEntryUpdateManyWithWhereWithoutEmployeeInput = {
    where: DailyEntryScalarWhereInput
    data: XOR<DailyEntryUpdateManyMutationInput, DailyEntryUncheckedUpdateManyWithoutEmployeeInput>
  }

  export type DailyEntryScalarWhereInput = {
    AND?: DailyEntryScalarWhereInput | DailyEntryScalarWhereInput[]
    OR?: DailyEntryScalarWhereInput[]
    NOT?: DailyEntryScalarWhereInput | DailyEntryScalarWhereInput[]
    id?: StringFilter<"DailyEntry"> | string
    employeeId?: StringFilter<"DailyEntry"> | string
    date?: DateTimeFilter<"DailyEntry"> | Date | string
    clientName?: StringFilter<"DailyEntry"> | string
    placementType?: EnumPlacementTypeFilter<"DailyEntry"> | $Enums.PlacementType
    revenue?: DecimalFilter<"DailyEntry"> | Decimal | DecimalJsLike | number | string
    marginPercent?: DecimalFilter<"DailyEntry"> | Decimal | DecimalJsLike | number | string
    billingStatus?: EnumBillingStatusFilter<"DailyEntry"> | $Enums.BillingStatus
    doi?: DateTimeFilter<"DailyEntry"> | Date | string
    doj?: DateTimeFilter<"DailyEntry"> | Date | string
    remarks?: StringNullableFilter<"DailyEntry"> | string | null
    createdAt?: DateTimeFilter<"DailyEntry"> | Date | string
  }

  export type PlacementUpsertWithWhereUniqueWithoutEmployeeInput = {
    where: PlacementWhereUniqueInput
    update: XOR<PlacementUpdateWithoutEmployeeInput, PlacementUncheckedUpdateWithoutEmployeeInput>
    create: XOR<PlacementCreateWithoutEmployeeInput, PlacementUncheckedCreateWithoutEmployeeInput>
  }

  export type PlacementUpdateWithWhereUniqueWithoutEmployeeInput = {
    where: PlacementWhereUniqueInput
    data: XOR<PlacementUpdateWithoutEmployeeInput, PlacementUncheckedUpdateWithoutEmployeeInput>
  }

  export type PlacementUpdateManyWithWhereWithoutEmployeeInput = {
    where: PlacementScalarWhereInput
    data: XOR<PlacementUpdateManyMutationInput, PlacementUncheckedUpdateManyWithoutEmployeeInput>
  }

  export type PlacementScalarWhereInput = {
    AND?: PlacementScalarWhereInput | PlacementScalarWhereInput[]
    OR?: PlacementScalarWhereInput[]
    NOT?: PlacementScalarWhereInput | PlacementScalarWhereInput[]
    id?: StringFilter<"Placement"> | string
    employeeId?: StringFilter<"Placement"> | string
    candidateName?: StringFilter<"Placement"> | string
    clientName?: StringFilter<"Placement"> | string
    doi?: DateTimeFilter<"Placement"> | Date | string
    doj?: DateTimeFilter<"Placement"> | Date | string
    daysCompleted?: IntFilter<"Placement"> | number
    placementType?: EnumPlacementTypeFilter<"Placement"> | $Enums.PlacementType
    billedHours?: IntNullableFilter<"Placement"> | number | null
    marginPercent?: DecimalFilter<"Placement"> | Decimal | DecimalJsLike | number | string
    revenue?: DecimalFilter<"Placement"> | Decimal | DecimalJsLike | number | string
    billingStatus?: EnumBillingStatusFilter<"Placement"> | $Enums.BillingStatus
    incentivePayoutEta?: DateTimeNullableFilter<"Placement"> | Date | string | null
    incentiveAmountInr?: DecimalFilter<"Placement"> | Decimal | DecimalJsLike | number | string
    incentivePaid?: BoolFilter<"Placement"> | boolean
    qualifier?: BoolFilter<"Placement"> | boolean
    createdAt?: DateTimeFilter<"Placement"> | Date | string
  }

  export type IncentiveUpsertWithWhereUniqueWithoutEmployeeInput = {
    where: IncentiveWhereUniqueInput
    update: XOR<IncentiveUpdateWithoutEmployeeInput, IncentiveUncheckedUpdateWithoutEmployeeInput>
    create: XOR<IncentiveCreateWithoutEmployeeInput, IncentiveUncheckedCreateWithoutEmployeeInput>
  }

  export type IncentiveUpdateWithWhereUniqueWithoutEmployeeInput = {
    where: IncentiveWhereUniqueInput
    data: XOR<IncentiveUpdateWithoutEmployeeInput, IncentiveUncheckedUpdateWithoutEmployeeInput>
  }

  export type IncentiveUpdateManyWithWhereWithoutEmployeeInput = {
    where: IncentiveScalarWhereInput
    data: XOR<IncentiveUpdateManyMutationInput, IncentiveUncheckedUpdateManyWithoutEmployeeInput>
  }

  export type IncentiveScalarWhereInput = {
    AND?: IncentiveScalarWhereInput | IncentiveScalarWhereInput[]
    OR?: IncentiveScalarWhereInput[]
    NOT?: IncentiveScalarWhereInput | IncentiveScalarWhereInput[]
    id?: StringFilter<"Incentive"> | string
    employeeId?: StringFilter<"Incentive"> | string
    periodStart?: DateTimeFilter<"Incentive"> | Date | string
    periodEnd?: DateTimeFilter<"Incentive"> | Date | string
    revenueTotal?: DecimalFilter<"Incentive"> | Decimal | DecimalJsLike | number | string
    slabName?: StringFilter<"Incentive"> | string
    amountUsd?: DecimalFilter<"Incentive"> | Decimal | DecimalJsLike | number | string
    amountInr?: DecimalFilter<"Incentive"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"Incentive"> | Date | string
  }

  export type CampaignAssignmentUpsertWithWhereUniqueWithoutUserInput = {
    where: CampaignAssignmentWhereUniqueInput
    update: XOR<CampaignAssignmentUpdateWithoutUserInput, CampaignAssignmentUncheckedUpdateWithoutUserInput>
    create: XOR<CampaignAssignmentCreateWithoutUserInput, CampaignAssignmentUncheckedCreateWithoutUserInput>
  }

  export type CampaignAssignmentUpdateWithWhereUniqueWithoutUserInput = {
    where: CampaignAssignmentWhereUniqueInput
    data: XOR<CampaignAssignmentUpdateWithoutUserInput, CampaignAssignmentUncheckedUpdateWithoutUserInput>
  }

  export type CampaignAssignmentUpdateManyWithWhereWithoutUserInput = {
    where: CampaignAssignmentScalarWhereInput
    data: XOR<CampaignAssignmentUpdateManyMutationInput, CampaignAssignmentUncheckedUpdateManyWithoutUserInput>
  }

  export type CampaignAssignmentScalarWhereInput = {
    AND?: CampaignAssignmentScalarWhereInput | CampaignAssignmentScalarWhereInput[]
    OR?: CampaignAssignmentScalarWhereInput[]
    NOT?: CampaignAssignmentScalarWhereInput | CampaignAssignmentScalarWhereInput[]
    id?: StringFilter<"CampaignAssignment"> | string
    campaignId?: StringFilter<"CampaignAssignment"> | string
    userId?: StringFilter<"CampaignAssignment"> | string
    role?: EnumRoleFilter<"CampaignAssignment"> | $Enums.Role
    targetAmount?: DecimalFilter<"CampaignAssignment"> | Decimal | DecimalJsLike | number | string
    progressPercent?: IntFilter<"CampaignAssignment"> | number
    isCompleted?: BoolFilter<"CampaignAssignment"> | boolean
    completedAt?: DateTimeNullableFilter<"CampaignAssignment"> | Date | string | null
    createdAt?: DateTimeFilter<"CampaignAssignment"> | Date | string
    updatedAt?: DateTimeFilter<"CampaignAssignment"> | Date | string
  }

  export type CampaignTeamLeadUpsertWithWhereUniqueWithoutUserInput = {
    where: CampaignTeamLeadWhereUniqueInput
    update: XOR<CampaignTeamLeadUpdateWithoutUserInput, CampaignTeamLeadUncheckedUpdateWithoutUserInput>
    create: XOR<CampaignTeamLeadCreateWithoutUserInput, CampaignTeamLeadUncheckedCreateWithoutUserInput>
  }

  export type CampaignTeamLeadUpdateWithWhereUniqueWithoutUserInput = {
    where: CampaignTeamLeadWhereUniqueInput
    data: XOR<CampaignTeamLeadUpdateWithoutUserInput, CampaignTeamLeadUncheckedUpdateWithoutUserInput>
  }

  export type CampaignTeamLeadUpdateManyWithWhereWithoutUserInput = {
    where: CampaignTeamLeadScalarWhereInput
    data: XOR<CampaignTeamLeadUpdateManyMutationInput, CampaignTeamLeadUncheckedUpdateManyWithoutUserInput>
  }

  export type CampaignTeamLeadScalarWhereInput = {
    AND?: CampaignTeamLeadScalarWhereInput | CampaignTeamLeadScalarWhereInput[]
    OR?: CampaignTeamLeadScalarWhereInput[]
    NOT?: CampaignTeamLeadScalarWhereInput | CampaignTeamLeadScalarWhereInput[]
    id?: StringFilter<"CampaignTeamLead"> | string
    campaignId?: StringFilter<"CampaignTeamLead"> | string
    userId?: StringFilter<"CampaignTeamLead"> | string
    createdAt?: DateTimeFilter<"CampaignTeamLead"> | Date | string
  }

  export type CampaignActivityUpsertWithWhereUniqueWithoutUserInput = {
    where: CampaignActivityWhereUniqueInput
    update: XOR<CampaignActivityUpdateWithoutUserInput, CampaignActivityUncheckedUpdateWithoutUserInput>
    create: XOR<CampaignActivityCreateWithoutUserInput, CampaignActivityUncheckedCreateWithoutUserInput>
  }

  export type CampaignActivityUpdateWithWhereUniqueWithoutUserInput = {
    where: CampaignActivityWhereUniqueInput
    data: XOR<CampaignActivityUpdateWithoutUserInput, CampaignActivityUncheckedUpdateWithoutUserInput>
  }

  export type CampaignActivityUpdateManyWithWhereWithoutUserInput = {
    where: CampaignActivityScalarWhereInput
    data: XOR<CampaignActivityUpdateManyMutationInput, CampaignActivityUncheckedUpdateManyWithoutUserInput>
  }

  export type CampaignActivityScalarWhereInput = {
    AND?: CampaignActivityScalarWhereInput | CampaignActivityScalarWhereInput[]
    OR?: CampaignActivityScalarWhereInput[]
    NOT?: CampaignActivityScalarWhereInput | CampaignActivityScalarWhereInput[]
    id?: StringFilter<"CampaignActivity"> | string
    campaignId?: StringFilter<"CampaignActivity"> | string
    userId?: StringFilter<"CampaignActivity"> | string
    action?: StringFilter<"CampaignActivity"> | string
    metadata?: JsonNullableFilter<"CampaignActivity">
    createdAt?: DateTimeFilter<"CampaignActivity"> | Date | string
  }

  export type CampaignUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: CampaignWhereUniqueInput
    update: XOR<CampaignUpdateWithoutCreatedByInput, CampaignUncheckedUpdateWithoutCreatedByInput>
    create: XOR<CampaignCreateWithoutCreatedByInput, CampaignUncheckedCreateWithoutCreatedByInput>
  }

  export type CampaignUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: CampaignWhereUniqueInput
    data: XOR<CampaignUpdateWithoutCreatedByInput, CampaignUncheckedUpdateWithoutCreatedByInput>
  }

  export type CampaignUpdateManyWithWhereWithoutCreatedByInput = {
    where: CampaignScalarWhereInput
    data: XOR<CampaignUpdateManyMutationInput, CampaignUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type CampaignScalarWhereInput = {
    AND?: CampaignScalarWhereInput | CampaignScalarWhereInput[]
    OR?: CampaignScalarWhereInput[]
    NOT?: CampaignScalarWhereInput | CampaignScalarWhereInput[]
    id?: StringFilter<"Campaign"> | string
    name?: StringFilter<"Campaign"> | string
    description?: StringNullableFilter<"Campaign"> | string | null
    objective?: StringNullableFilter<"Campaign"> | string | null
    status?: EnumCampaignStatusFilter<"Campaign"> | $Enums.CampaignStatus
    targetAmount?: DecimalFilter<"Campaign"> | Decimal | DecimalJsLike | number | string
    startDate?: DateTimeFilter<"Campaign"> | Date | string
    endDate?: DateTimeFilter<"Campaign"> | Date | string
    createdById?: StringFilter<"Campaign"> | string
    createdAt?: DateTimeFilter<"Campaign"> | Date | string
    updatedAt?: DateTimeFilter<"Campaign"> | Date | string
  }

  export type CampaignImageUpsertWithWhereUniqueWithoutUploadedByInput = {
    where: CampaignImageWhereUniqueInput
    update: XOR<CampaignImageUpdateWithoutUploadedByInput, CampaignImageUncheckedUpdateWithoutUploadedByInput>
    create: XOR<CampaignImageCreateWithoutUploadedByInput, CampaignImageUncheckedCreateWithoutUploadedByInput>
  }

  export type CampaignImageUpdateWithWhereUniqueWithoutUploadedByInput = {
    where: CampaignImageWhereUniqueInput
    data: XOR<CampaignImageUpdateWithoutUploadedByInput, CampaignImageUncheckedUpdateWithoutUploadedByInput>
  }

  export type CampaignImageUpdateManyWithWhereWithoutUploadedByInput = {
    where: CampaignImageScalarWhereInput
    data: XOR<CampaignImageUpdateManyMutationInput, CampaignImageUncheckedUpdateManyWithoutUploadedByInput>
  }

  export type CampaignImageScalarWhereInput = {
    AND?: CampaignImageScalarWhereInput | CampaignImageScalarWhereInput[]
    OR?: CampaignImageScalarWhereInput[]
    NOT?: CampaignImageScalarWhereInput | CampaignImageScalarWhereInput[]
    id?: StringFilter<"CampaignImage"> | string
    campaignId?: StringFilter<"CampaignImage"> | string
    url?: StringFilter<"CampaignImage"> | string
    title?: StringNullableFilter<"CampaignImage"> | string | null
    description?: StringNullableFilter<"CampaignImage"> | string | null
    uploadedById?: StringFilter<"CampaignImage"> | string
    createdAt?: DateTimeFilter<"CampaignImage"> | Date | string
  }

  export type CampaignTaskUpsertWithWhereUniqueWithoutCompletedByInput = {
    where: CampaignTaskWhereUniqueInput
    update: XOR<CampaignTaskUpdateWithoutCompletedByInput, CampaignTaskUncheckedUpdateWithoutCompletedByInput>
    create: XOR<CampaignTaskCreateWithoutCompletedByInput, CampaignTaskUncheckedCreateWithoutCompletedByInput>
  }

  export type CampaignTaskUpdateWithWhereUniqueWithoutCompletedByInput = {
    where: CampaignTaskWhereUniqueInput
    data: XOR<CampaignTaskUpdateWithoutCompletedByInput, CampaignTaskUncheckedUpdateWithoutCompletedByInput>
  }

  export type CampaignTaskUpdateManyWithWhereWithoutCompletedByInput = {
    where: CampaignTaskScalarWhereInput
    data: XOR<CampaignTaskUpdateManyMutationInput, CampaignTaskUncheckedUpdateManyWithoutCompletedByInput>
  }

  export type CampaignTaskScalarWhereInput = {
    AND?: CampaignTaskScalarWhereInput | CampaignTaskScalarWhereInput[]
    OR?: CampaignTaskScalarWhereInput[]
    NOT?: CampaignTaskScalarWhereInput | CampaignTaskScalarWhereInput[]
    id?: StringFilter<"CampaignTask"> | string
    campaignId?: StringFilter<"CampaignTask"> | string
    assignmentId?: StringNullableFilter<"CampaignTask"> | string | null
    title?: StringFilter<"CampaignTask"> | string
    description?: StringNullableFilter<"CampaignTask"> | string | null
    isCompleted?: BoolFilter<"CampaignTask"> | boolean
    completedById?: StringNullableFilter<"CampaignTask"> | string | null
    dueDate?: DateTimeNullableFilter<"CampaignTask"> | Date | string | null
    createdAt?: DateTimeFilter<"CampaignTask"> | Date | string
    updatedAt?: DateTimeFilter<"CampaignTask"> | Date | string
  }

  export type EmployeeProfileUpsertWithWhereUniqueWithoutManagerInput = {
    where: EmployeeProfileWhereUniqueInput
    update: XOR<EmployeeProfileUpdateWithoutManagerInput, EmployeeProfileUncheckedUpdateWithoutManagerInput>
    create: XOR<EmployeeProfileCreateWithoutManagerInput, EmployeeProfileUncheckedCreateWithoutManagerInput>
  }

  export type EmployeeProfileUpdateWithWhereUniqueWithoutManagerInput = {
    where: EmployeeProfileWhereUniqueInput
    data: XOR<EmployeeProfileUpdateWithoutManagerInput, EmployeeProfileUncheckedUpdateWithoutManagerInput>
  }

  export type EmployeeProfileUpdateManyWithWhereWithoutManagerInput = {
    where: EmployeeProfileScalarWhereInput
    data: XOR<EmployeeProfileUpdateManyMutationInput, EmployeeProfileUncheckedUpdateManyWithoutManagerInput>
  }

  export type AuditLogUpsertWithWhereUniqueWithoutActorInput = {
    where: AuditLogWhereUniqueInput
    update: XOR<AuditLogUpdateWithoutActorInput, AuditLogUncheckedUpdateWithoutActorInput>
    create: XOR<AuditLogCreateWithoutActorInput, AuditLogUncheckedCreateWithoutActorInput>
  }

  export type AuditLogUpdateWithWhereUniqueWithoutActorInput = {
    where: AuditLogWhereUniqueInput
    data: XOR<AuditLogUpdateWithoutActorInput, AuditLogUncheckedUpdateWithoutActorInput>
  }

  export type AuditLogUpdateManyWithWhereWithoutActorInput = {
    where: AuditLogScalarWhereInput
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyWithoutActorInput>
  }

  export type AuditLogScalarWhereInput = {
    AND?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    OR?: AuditLogScalarWhereInput[]
    NOT?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    id?: StringFilter<"AuditLog"> | string
    actorId?: StringFilter<"AuditLog"> | string
    action?: StringFilter<"AuditLog"> | string
    entityType?: StringFilter<"AuditLog"> | string
    entityId?: StringFilter<"AuditLog"> | string
    changes?: JsonNullableFilter<"AuditLog">
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
  }

  export type UserCreateWithoutEmployeeProfileInput = {
    id?: string
    email: string
    passwordHash: string
    name: string
    role: $Enums.Role
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    dailyEntries?: DailyEntryCreateNestedManyWithoutEmployeeInput
    placements?: PlacementCreateNestedManyWithoutEmployeeInput
    incentives?: IncentiveCreateNestedManyWithoutEmployeeInput
    campaignAssignments?: CampaignAssignmentCreateNestedManyWithoutUserInput
    campaignTeamLeads?: CampaignTeamLeadCreateNestedManyWithoutUserInput
    campaignActivities?: CampaignActivityCreateNestedManyWithoutUserInput
    createdCampaigns?: CampaignCreateNestedManyWithoutCreatedByInput
    uploadedCampaignImages?: CampaignImageCreateNestedManyWithoutUploadedByInput
    completedCampaignTasks?: CampaignTaskCreateNestedManyWithoutCompletedByInput
    leadEmployees?: EmployeeProfileCreateNestedManyWithoutManagerInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
  }

  export type UserUncheckedCreateWithoutEmployeeProfileInput = {
    id?: string
    email: string
    passwordHash: string
    name: string
    role: $Enums.Role
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    dailyEntries?: DailyEntryUncheckedCreateNestedManyWithoutEmployeeInput
    placements?: PlacementUncheckedCreateNestedManyWithoutEmployeeInput
    incentives?: IncentiveUncheckedCreateNestedManyWithoutEmployeeInput
    campaignAssignments?: CampaignAssignmentUncheckedCreateNestedManyWithoutUserInput
    campaignTeamLeads?: CampaignTeamLeadUncheckedCreateNestedManyWithoutUserInput
    campaignActivities?: CampaignActivityUncheckedCreateNestedManyWithoutUserInput
    createdCampaigns?: CampaignUncheckedCreateNestedManyWithoutCreatedByInput
    uploadedCampaignImages?: CampaignImageUncheckedCreateNestedManyWithoutUploadedByInput
    completedCampaignTasks?: CampaignTaskUncheckedCreateNestedManyWithoutCompletedByInput
    leadEmployees?: EmployeeProfileUncheckedCreateNestedManyWithoutManagerInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
  }

  export type UserCreateOrConnectWithoutEmployeeProfileInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutEmployeeProfileInput, UserUncheckedCreateWithoutEmployeeProfileInput>
  }

  export type TeamCreateWithoutEmployeesInput = {
    id?: string
    name: string
    color?: string | null
    yearlyTarget: Decimal | DecimalJsLike | number | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TeamUncheckedCreateWithoutEmployeesInput = {
    id?: string
    name: string
    color?: string | null
    yearlyTarget: Decimal | DecimalJsLike | number | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TeamCreateOrConnectWithoutEmployeesInput = {
    where: TeamWhereUniqueInput
    create: XOR<TeamCreateWithoutEmployeesInput, TeamUncheckedCreateWithoutEmployeesInput>
  }

  export type UserCreateWithoutLeadEmployeesInput = {
    id?: string
    email: string
    passwordHash: string
    name: string
    role: $Enums.Role
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    employeeProfile?: EmployeeProfileCreateNestedOneWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    dailyEntries?: DailyEntryCreateNestedManyWithoutEmployeeInput
    placements?: PlacementCreateNestedManyWithoutEmployeeInput
    incentives?: IncentiveCreateNestedManyWithoutEmployeeInput
    campaignAssignments?: CampaignAssignmentCreateNestedManyWithoutUserInput
    campaignTeamLeads?: CampaignTeamLeadCreateNestedManyWithoutUserInput
    campaignActivities?: CampaignActivityCreateNestedManyWithoutUserInput
    createdCampaigns?: CampaignCreateNestedManyWithoutCreatedByInput
    uploadedCampaignImages?: CampaignImageCreateNestedManyWithoutUploadedByInput
    completedCampaignTasks?: CampaignTaskCreateNestedManyWithoutCompletedByInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
  }

  export type UserUncheckedCreateWithoutLeadEmployeesInput = {
    id?: string
    email: string
    passwordHash: string
    name: string
    role: $Enums.Role
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    employeeProfile?: EmployeeProfileUncheckedCreateNestedOneWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    dailyEntries?: DailyEntryUncheckedCreateNestedManyWithoutEmployeeInput
    placements?: PlacementUncheckedCreateNestedManyWithoutEmployeeInput
    incentives?: IncentiveUncheckedCreateNestedManyWithoutEmployeeInput
    campaignAssignments?: CampaignAssignmentUncheckedCreateNestedManyWithoutUserInput
    campaignTeamLeads?: CampaignTeamLeadUncheckedCreateNestedManyWithoutUserInput
    campaignActivities?: CampaignActivityUncheckedCreateNestedManyWithoutUserInput
    createdCampaigns?: CampaignUncheckedCreateNestedManyWithoutCreatedByInput
    uploadedCampaignImages?: CampaignImageUncheckedCreateNestedManyWithoutUploadedByInput
    completedCampaignTasks?: CampaignTaskUncheckedCreateNestedManyWithoutCompletedByInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
  }

  export type UserCreateOrConnectWithoutLeadEmployeesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutLeadEmployeesInput, UserUncheckedCreateWithoutLeadEmployeesInput>
  }

  export type UserUpsertWithoutEmployeeProfileInput = {
    update: XOR<UserUpdateWithoutEmployeeProfileInput, UserUncheckedUpdateWithoutEmployeeProfileInput>
    create: XOR<UserCreateWithoutEmployeeProfileInput, UserUncheckedCreateWithoutEmployeeProfileInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutEmployeeProfileInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutEmployeeProfileInput, UserUncheckedUpdateWithoutEmployeeProfileInput>
  }

  export type UserUpdateWithoutEmployeeProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    dailyEntries?: DailyEntryUpdateManyWithoutEmployeeNestedInput
    placements?: PlacementUpdateManyWithoutEmployeeNestedInput
    incentives?: IncentiveUpdateManyWithoutEmployeeNestedInput
    campaignAssignments?: CampaignAssignmentUpdateManyWithoutUserNestedInput
    campaignTeamLeads?: CampaignTeamLeadUpdateManyWithoutUserNestedInput
    campaignActivities?: CampaignActivityUpdateManyWithoutUserNestedInput
    createdCampaigns?: CampaignUpdateManyWithoutCreatedByNestedInput
    uploadedCampaignImages?: CampaignImageUpdateManyWithoutUploadedByNestedInput
    completedCampaignTasks?: CampaignTaskUpdateManyWithoutCompletedByNestedInput
    leadEmployees?: EmployeeProfileUpdateManyWithoutManagerNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
  }

  export type UserUncheckedUpdateWithoutEmployeeProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    dailyEntries?: DailyEntryUncheckedUpdateManyWithoutEmployeeNestedInput
    placements?: PlacementUncheckedUpdateManyWithoutEmployeeNestedInput
    incentives?: IncentiveUncheckedUpdateManyWithoutEmployeeNestedInput
    campaignAssignments?: CampaignAssignmentUncheckedUpdateManyWithoutUserNestedInput
    campaignTeamLeads?: CampaignTeamLeadUncheckedUpdateManyWithoutUserNestedInput
    campaignActivities?: CampaignActivityUncheckedUpdateManyWithoutUserNestedInput
    createdCampaigns?: CampaignUncheckedUpdateManyWithoutCreatedByNestedInput
    uploadedCampaignImages?: CampaignImageUncheckedUpdateManyWithoutUploadedByNestedInput
    completedCampaignTasks?: CampaignTaskUncheckedUpdateManyWithoutCompletedByNestedInput
    leadEmployees?: EmployeeProfileUncheckedUpdateManyWithoutManagerNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
  }

  export type TeamUpsertWithoutEmployeesInput = {
    update: XOR<TeamUpdateWithoutEmployeesInput, TeamUncheckedUpdateWithoutEmployeesInput>
    create: XOR<TeamCreateWithoutEmployeesInput, TeamUncheckedCreateWithoutEmployeesInput>
    where?: TeamWhereInput
  }

  export type TeamUpdateToOneWithWhereWithoutEmployeesInput = {
    where?: TeamWhereInput
    data: XOR<TeamUpdateWithoutEmployeesInput, TeamUncheckedUpdateWithoutEmployeesInput>
  }

  export type TeamUpdateWithoutEmployeesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    yearlyTarget?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamUncheckedUpdateWithoutEmployeesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    yearlyTarget?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutLeadEmployeesInput = {
    update: XOR<UserUpdateWithoutLeadEmployeesInput, UserUncheckedUpdateWithoutLeadEmployeesInput>
    create: XOR<UserCreateWithoutLeadEmployeesInput, UserUncheckedCreateWithoutLeadEmployeesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutLeadEmployeesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutLeadEmployeesInput, UserUncheckedUpdateWithoutLeadEmployeesInput>
  }

  export type UserUpdateWithoutLeadEmployeesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employeeProfile?: EmployeeProfileUpdateOneWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    dailyEntries?: DailyEntryUpdateManyWithoutEmployeeNestedInput
    placements?: PlacementUpdateManyWithoutEmployeeNestedInput
    incentives?: IncentiveUpdateManyWithoutEmployeeNestedInput
    campaignAssignments?: CampaignAssignmentUpdateManyWithoutUserNestedInput
    campaignTeamLeads?: CampaignTeamLeadUpdateManyWithoutUserNestedInput
    campaignActivities?: CampaignActivityUpdateManyWithoutUserNestedInput
    createdCampaigns?: CampaignUpdateManyWithoutCreatedByNestedInput
    uploadedCampaignImages?: CampaignImageUpdateManyWithoutUploadedByNestedInput
    completedCampaignTasks?: CampaignTaskUpdateManyWithoutCompletedByNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
  }

  export type UserUncheckedUpdateWithoutLeadEmployeesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employeeProfile?: EmployeeProfileUncheckedUpdateOneWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    dailyEntries?: DailyEntryUncheckedUpdateManyWithoutEmployeeNestedInput
    placements?: PlacementUncheckedUpdateManyWithoutEmployeeNestedInput
    incentives?: IncentiveUncheckedUpdateManyWithoutEmployeeNestedInput
    campaignAssignments?: CampaignAssignmentUncheckedUpdateManyWithoutUserNestedInput
    campaignTeamLeads?: CampaignTeamLeadUncheckedUpdateManyWithoutUserNestedInput
    campaignActivities?: CampaignActivityUncheckedUpdateManyWithoutUserNestedInput
    createdCampaigns?: CampaignUncheckedUpdateManyWithoutCreatedByNestedInput
    uploadedCampaignImages?: CampaignImageUncheckedUpdateManyWithoutUploadedByNestedInput
    completedCampaignTasks?: CampaignTaskUncheckedUpdateManyWithoutCompletedByNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
  }

  export type UserCreateWithoutDailyEntriesInput = {
    id?: string
    email: string
    passwordHash: string
    name: string
    role: $Enums.Role
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    employeeProfile?: EmployeeProfileCreateNestedOneWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    placements?: PlacementCreateNestedManyWithoutEmployeeInput
    incentives?: IncentiveCreateNestedManyWithoutEmployeeInput
    campaignAssignments?: CampaignAssignmentCreateNestedManyWithoutUserInput
    campaignTeamLeads?: CampaignTeamLeadCreateNestedManyWithoutUserInput
    campaignActivities?: CampaignActivityCreateNestedManyWithoutUserInput
    createdCampaigns?: CampaignCreateNestedManyWithoutCreatedByInput
    uploadedCampaignImages?: CampaignImageCreateNestedManyWithoutUploadedByInput
    completedCampaignTasks?: CampaignTaskCreateNestedManyWithoutCompletedByInput
    leadEmployees?: EmployeeProfileCreateNestedManyWithoutManagerInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
  }

  export type UserUncheckedCreateWithoutDailyEntriesInput = {
    id?: string
    email: string
    passwordHash: string
    name: string
    role: $Enums.Role
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    employeeProfile?: EmployeeProfileUncheckedCreateNestedOneWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    placements?: PlacementUncheckedCreateNestedManyWithoutEmployeeInput
    incentives?: IncentiveUncheckedCreateNestedManyWithoutEmployeeInput
    campaignAssignments?: CampaignAssignmentUncheckedCreateNestedManyWithoutUserInput
    campaignTeamLeads?: CampaignTeamLeadUncheckedCreateNestedManyWithoutUserInput
    campaignActivities?: CampaignActivityUncheckedCreateNestedManyWithoutUserInput
    createdCampaigns?: CampaignUncheckedCreateNestedManyWithoutCreatedByInput
    uploadedCampaignImages?: CampaignImageUncheckedCreateNestedManyWithoutUploadedByInput
    completedCampaignTasks?: CampaignTaskUncheckedCreateNestedManyWithoutCompletedByInput
    leadEmployees?: EmployeeProfileUncheckedCreateNestedManyWithoutManagerInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
  }

  export type UserCreateOrConnectWithoutDailyEntriesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDailyEntriesInput, UserUncheckedCreateWithoutDailyEntriesInput>
  }

  export type UserUpsertWithoutDailyEntriesInput = {
    update: XOR<UserUpdateWithoutDailyEntriesInput, UserUncheckedUpdateWithoutDailyEntriesInput>
    create: XOR<UserCreateWithoutDailyEntriesInput, UserUncheckedCreateWithoutDailyEntriesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDailyEntriesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDailyEntriesInput, UserUncheckedUpdateWithoutDailyEntriesInput>
  }

  export type UserUpdateWithoutDailyEntriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employeeProfile?: EmployeeProfileUpdateOneWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    placements?: PlacementUpdateManyWithoutEmployeeNestedInput
    incentives?: IncentiveUpdateManyWithoutEmployeeNestedInput
    campaignAssignments?: CampaignAssignmentUpdateManyWithoutUserNestedInput
    campaignTeamLeads?: CampaignTeamLeadUpdateManyWithoutUserNestedInput
    campaignActivities?: CampaignActivityUpdateManyWithoutUserNestedInput
    createdCampaigns?: CampaignUpdateManyWithoutCreatedByNestedInput
    uploadedCampaignImages?: CampaignImageUpdateManyWithoutUploadedByNestedInput
    completedCampaignTasks?: CampaignTaskUpdateManyWithoutCompletedByNestedInput
    leadEmployees?: EmployeeProfileUpdateManyWithoutManagerNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
  }

  export type UserUncheckedUpdateWithoutDailyEntriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employeeProfile?: EmployeeProfileUncheckedUpdateOneWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    placements?: PlacementUncheckedUpdateManyWithoutEmployeeNestedInput
    incentives?: IncentiveUncheckedUpdateManyWithoutEmployeeNestedInput
    campaignAssignments?: CampaignAssignmentUncheckedUpdateManyWithoutUserNestedInput
    campaignTeamLeads?: CampaignTeamLeadUncheckedUpdateManyWithoutUserNestedInput
    campaignActivities?: CampaignActivityUncheckedUpdateManyWithoutUserNestedInput
    createdCampaigns?: CampaignUncheckedUpdateManyWithoutCreatedByNestedInput
    uploadedCampaignImages?: CampaignImageUncheckedUpdateManyWithoutUploadedByNestedInput
    completedCampaignTasks?: CampaignTaskUncheckedUpdateManyWithoutCompletedByNestedInput
    leadEmployees?: EmployeeProfileUncheckedUpdateManyWithoutManagerNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
  }

  export type UserCreateWithoutPlacementsInput = {
    id?: string
    email: string
    passwordHash: string
    name: string
    role: $Enums.Role
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    employeeProfile?: EmployeeProfileCreateNestedOneWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    dailyEntries?: DailyEntryCreateNestedManyWithoutEmployeeInput
    incentives?: IncentiveCreateNestedManyWithoutEmployeeInput
    campaignAssignments?: CampaignAssignmentCreateNestedManyWithoutUserInput
    campaignTeamLeads?: CampaignTeamLeadCreateNestedManyWithoutUserInput
    campaignActivities?: CampaignActivityCreateNestedManyWithoutUserInput
    createdCampaigns?: CampaignCreateNestedManyWithoutCreatedByInput
    uploadedCampaignImages?: CampaignImageCreateNestedManyWithoutUploadedByInput
    completedCampaignTasks?: CampaignTaskCreateNestedManyWithoutCompletedByInput
    leadEmployees?: EmployeeProfileCreateNestedManyWithoutManagerInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
  }

  export type UserUncheckedCreateWithoutPlacementsInput = {
    id?: string
    email: string
    passwordHash: string
    name: string
    role: $Enums.Role
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    employeeProfile?: EmployeeProfileUncheckedCreateNestedOneWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    dailyEntries?: DailyEntryUncheckedCreateNestedManyWithoutEmployeeInput
    incentives?: IncentiveUncheckedCreateNestedManyWithoutEmployeeInput
    campaignAssignments?: CampaignAssignmentUncheckedCreateNestedManyWithoutUserInput
    campaignTeamLeads?: CampaignTeamLeadUncheckedCreateNestedManyWithoutUserInput
    campaignActivities?: CampaignActivityUncheckedCreateNestedManyWithoutUserInput
    createdCampaigns?: CampaignUncheckedCreateNestedManyWithoutCreatedByInput
    uploadedCampaignImages?: CampaignImageUncheckedCreateNestedManyWithoutUploadedByInput
    completedCampaignTasks?: CampaignTaskUncheckedCreateNestedManyWithoutCompletedByInput
    leadEmployees?: EmployeeProfileUncheckedCreateNestedManyWithoutManagerInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
  }

  export type UserCreateOrConnectWithoutPlacementsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPlacementsInput, UserUncheckedCreateWithoutPlacementsInput>
  }

  export type MonthlyBillingCreateWithoutPlacementInput = {
    id?: string
    month: string
    hours?: number | null
    status: $Enums.BillingStatus
  }

  export type MonthlyBillingUncheckedCreateWithoutPlacementInput = {
    id?: string
    month: string
    hours?: number | null
    status: $Enums.BillingStatus
  }

  export type MonthlyBillingCreateOrConnectWithoutPlacementInput = {
    where: MonthlyBillingWhereUniqueInput
    create: XOR<MonthlyBillingCreateWithoutPlacementInput, MonthlyBillingUncheckedCreateWithoutPlacementInput>
  }

  export type MonthlyBillingCreateManyPlacementInputEnvelope = {
    data: MonthlyBillingCreateManyPlacementInput | MonthlyBillingCreateManyPlacementInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutPlacementsInput = {
    update: XOR<UserUpdateWithoutPlacementsInput, UserUncheckedUpdateWithoutPlacementsInput>
    create: XOR<UserCreateWithoutPlacementsInput, UserUncheckedCreateWithoutPlacementsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPlacementsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPlacementsInput, UserUncheckedUpdateWithoutPlacementsInput>
  }

  export type UserUpdateWithoutPlacementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employeeProfile?: EmployeeProfileUpdateOneWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    dailyEntries?: DailyEntryUpdateManyWithoutEmployeeNestedInput
    incentives?: IncentiveUpdateManyWithoutEmployeeNestedInput
    campaignAssignments?: CampaignAssignmentUpdateManyWithoutUserNestedInput
    campaignTeamLeads?: CampaignTeamLeadUpdateManyWithoutUserNestedInput
    campaignActivities?: CampaignActivityUpdateManyWithoutUserNestedInput
    createdCampaigns?: CampaignUpdateManyWithoutCreatedByNestedInput
    uploadedCampaignImages?: CampaignImageUpdateManyWithoutUploadedByNestedInput
    completedCampaignTasks?: CampaignTaskUpdateManyWithoutCompletedByNestedInput
    leadEmployees?: EmployeeProfileUpdateManyWithoutManagerNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
  }

  export type UserUncheckedUpdateWithoutPlacementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employeeProfile?: EmployeeProfileUncheckedUpdateOneWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    dailyEntries?: DailyEntryUncheckedUpdateManyWithoutEmployeeNestedInput
    incentives?: IncentiveUncheckedUpdateManyWithoutEmployeeNestedInput
    campaignAssignments?: CampaignAssignmentUncheckedUpdateManyWithoutUserNestedInput
    campaignTeamLeads?: CampaignTeamLeadUncheckedUpdateManyWithoutUserNestedInput
    campaignActivities?: CampaignActivityUncheckedUpdateManyWithoutUserNestedInput
    createdCampaigns?: CampaignUncheckedUpdateManyWithoutCreatedByNestedInput
    uploadedCampaignImages?: CampaignImageUncheckedUpdateManyWithoutUploadedByNestedInput
    completedCampaignTasks?: CampaignTaskUncheckedUpdateManyWithoutCompletedByNestedInput
    leadEmployees?: EmployeeProfileUncheckedUpdateManyWithoutManagerNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
  }

  export type MonthlyBillingUpsertWithWhereUniqueWithoutPlacementInput = {
    where: MonthlyBillingWhereUniqueInput
    update: XOR<MonthlyBillingUpdateWithoutPlacementInput, MonthlyBillingUncheckedUpdateWithoutPlacementInput>
    create: XOR<MonthlyBillingCreateWithoutPlacementInput, MonthlyBillingUncheckedCreateWithoutPlacementInput>
  }

  export type MonthlyBillingUpdateWithWhereUniqueWithoutPlacementInput = {
    where: MonthlyBillingWhereUniqueInput
    data: XOR<MonthlyBillingUpdateWithoutPlacementInput, MonthlyBillingUncheckedUpdateWithoutPlacementInput>
  }

  export type MonthlyBillingUpdateManyWithWhereWithoutPlacementInput = {
    where: MonthlyBillingScalarWhereInput
    data: XOR<MonthlyBillingUpdateManyMutationInput, MonthlyBillingUncheckedUpdateManyWithoutPlacementInput>
  }

  export type MonthlyBillingScalarWhereInput = {
    AND?: MonthlyBillingScalarWhereInput | MonthlyBillingScalarWhereInput[]
    OR?: MonthlyBillingScalarWhereInput[]
    NOT?: MonthlyBillingScalarWhereInput | MonthlyBillingScalarWhereInput[]
    id?: StringFilter<"MonthlyBilling"> | string
    placementId?: StringFilter<"MonthlyBilling"> | string
    month?: StringFilter<"MonthlyBilling"> | string
    hours?: IntNullableFilter<"MonthlyBilling"> | number | null
    status?: EnumBillingStatusFilter<"MonthlyBilling"> | $Enums.BillingStatus
  }

  export type PlacementCreateWithoutMonthlyBillingsInput = {
    id?: string
    candidateName: string
    clientName: string
    doi: Date | string
    doj: Date | string
    daysCompleted: number
    placementType: $Enums.PlacementType
    billedHours?: number | null
    marginPercent: Decimal | DecimalJsLike | number | string
    revenue: Decimal | DecimalJsLike | number | string
    billingStatus: $Enums.BillingStatus
    incentivePayoutEta?: Date | string | null
    incentiveAmountInr: Decimal | DecimalJsLike | number | string
    incentivePaid: boolean
    qualifier: boolean
    createdAt?: Date | string
    employee: UserCreateNestedOneWithoutPlacementsInput
  }

  export type PlacementUncheckedCreateWithoutMonthlyBillingsInput = {
    id?: string
    employeeId: string
    candidateName: string
    clientName: string
    doi: Date | string
    doj: Date | string
    daysCompleted: number
    placementType: $Enums.PlacementType
    billedHours?: number | null
    marginPercent: Decimal | DecimalJsLike | number | string
    revenue: Decimal | DecimalJsLike | number | string
    billingStatus: $Enums.BillingStatus
    incentivePayoutEta?: Date | string | null
    incentiveAmountInr: Decimal | DecimalJsLike | number | string
    incentivePaid: boolean
    qualifier: boolean
    createdAt?: Date | string
  }

  export type PlacementCreateOrConnectWithoutMonthlyBillingsInput = {
    where: PlacementWhereUniqueInput
    create: XOR<PlacementCreateWithoutMonthlyBillingsInput, PlacementUncheckedCreateWithoutMonthlyBillingsInput>
  }

  export type PlacementUpsertWithoutMonthlyBillingsInput = {
    update: XOR<PlacementUpdateWithoutMonthlyBillingsInput, PlacementUncheckedUpdateWithoutMonthlyBillingsInput>
    create: XOR<PlacementCreateWithoutMonthlyBillingsInput, PlacementUncheckedCreateWithoutMonthlyBillingsInput>
    where?: PlacementWhereInput
  }

  export type PlacementUpdateToOneWithWhereWithoutMonthlyBillingsInput = {
    where?: PlacementWhereInput
    data: XOR<PlacementUpdateWithoutMonthlyBillingsInput, PlacementUncheckedUpdateWithoutMonthlyBillingsInput>
  }

  export type PlacementUpdateWithoutMonthlyBillingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    candidateName?: StringFieldUpdateOperationsInput | string
    clientName?: StringFieldUpdateOperationsInput | string
    doi?: DateTimeFieldUpdateOperationsInput | Date | string
    doj?: DateTimeFieldUpdateOperationsInput | Date | string
    daysCompleted?: IntFieldUpdateOperationsInput | number
    placementType?: EnumPlacementTypeFieldUpdateOperationsInput | $Enums.PlacementType
    billedHours?: NullableIntFieldUpdateOperationsInput | number | null
    marginPercent?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    revenue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    billingStatus?: EnumBillingStatusFieldUpdateOperationsInput | $Enums.BillingStatus
    incentivePayoutEta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    incentiveAmountInr?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    incentivePaid?: BoolFieldUpdateOperationsInput | boolean
    qualifier?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: UserUpdateOneRequiredWithoutPlacementsNestedInput
  }

  export type PlacementUncheckedUpdateWithoutMonthlyBillingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    candidateName?: StringFieldUpdateOperationsInput | string
    clientName?: StringFieldUpdateOperationsInput | string
    doi?: DateTimeFieldUpdateOperationsInput | Date | string
    doj?: DateTimeFieldUpdateOperationsInput | Date | string
    daysCompleted?: IntFieldUpdateOperationsInput | number
    placementType?: EnumPlacementTypeFieldUpdateOperationsInput | $Enums.PlacementType
    billedHours?: NullableIntFieldUpdateOperationsInput | number | null
    marginPercent?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    revenue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    billingStatus?: EnumBillingStatusFieldUpdateOperationsInput | $Enums.BillingStatus
    incentivePayoutEta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    incentiveAmountInr?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    incentivePaid?: BoolFieldUpdateOperationsInput | boolean
    qualifier?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutIncentivesInput = {
    id?: string
    email: string
    passwordHash: string
    name: string
    role: $Enums.Role
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    employeeProfile?: EmployeeProfileCreateNestedOneWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    dailyEntries?: DailyEntryCreateNestedManyWithoutEmployeeInput
    placements?: PlacementCreateNestedManyWithoutEmployeeInput
    campaignAssignments?: CampaignAssignmentCreateNestedManyWithoutUserInput
    campaignTeamLeads?: CampaignTeamLeadCreateNestedManyWithoutUserInput
    campaignActivities?: CampaignActivityCreateNestedManyWithoutUserInput
    createdCampaigns?: CampaignCreateNestedManyWithoutCreatedByInput
    uploadedCampaignImages?: CampaignImageCreateNestedManyWithoutUploadedByInput
    completedCampaignTasks?: CampaignTaskCreateNestedManyWithoutCompletedByInput
    leadEmployees?: EmployeeProfileCreateNestedManyWithoutManagerInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
  }

  export type UserUncheckedCreateWithoutIncentivesInput = {
    id?: string
    email: string
    passwordHash: string
    name: string
    role: $Enums.Role
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    employeeProfile?: EmployeeProfileUncheckedCreateNestedOneWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    dailyEntries?: DailyEntryUncheckedCreateNestedManyWithoutEmployeeInput
    placements?: PlacementUncheckedCreateNestedManyWithoutEmployeeInput
    campaignAssignments?: CampaignAssignmentUncheckedCreateNestedManyWithoutUserInput
    campaignTeamLeads?: CampaignTeamLeadUncheckedCreateNestedManyWithoutUserInput
    campaignActivities?: CampaignActivityUncheckedCreateNestedManyWithoutUserInput
    createdCampaigns?: CampaignUncheckedCreateNestedManyWithoutCreatedByInput
    uploadedCampaignImages?: CampaignImageUncheckedCreateNestedManyWithoutUploadedByInput
    completedCampaignTasks?: CampaignTaskUncheckedCreateNestedManyWithoutCompletedByInput
    leadEmployees?: EmployeeProfileUncheckedCreateNestedManyWithoutManagerInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
  }

  export type UserCreateOrConnectWithoutIncentivesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutIncentivesInput, UserUncheckedCreateWithoutIncentivesInput>
  }

  export type UserUpsertWithoutIncentivesInput = {
    update: XOR<UserUpdateWithoutIncentivesInput, UserUncheckedUpdateWithoutIncentivesInput>
    create: XOR<UserCreateWithoutIncentivesInput, UserUncheckedCreateWithoutIncentivesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutIncentivesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutIncentivesInput, UserUncheckedUpdateWithoutIncentivesInput>
  }

  export type UserUpdateWithoutIncentivesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employeeProfile?: EmployeeProfileUpdateOneWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    dailyEntries?: DailyEntryUpdateManyWithoutEmployeeNestedInput
    placements?: PlacementUpdateManyWithoutEmployeeNestedInput
    campaignAssignments?: CampaignAssignmentUpdateManyWithoutUserNestedInput
    campaignTeamLeads?: CampaignTeamLeadUpdateManyWithoutUserNestedInput
    campaignActivities?: CampaignActivityUpdateManyWithoutUserNestedInput
    createdCampaigns?: CampaignUpdateManyWithoutCreatedByNestedInput
    uploadedCampaignImages?: CampaignImageUpdateManyWithoutUploadedByNestedInput
    completedCampaignTasks?: CampaignTaskUpdateManyWithoutCompletedByNestedInput
    leadEmployees?: EmployeeProfileUpdateManyWithoutManagerNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
  }

  export type UserUncheckedUpdateWithoutIncentivesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employeeProfile?: EmployeeProfileUncheckedUpdateOneWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    dailyEntries?: DailyEntryUncheckedUpdateManyWithoutEmployeeNestedInput
    placements?: PlacementUncheckedUpdateManyWithoutEmployeeNestedInput
    campaignAssignments?: CampaignAssignmentUncheckedUpdateManyWithoutUserNestedInput
    campaignTeamLeads?: CampaignTeamLeadUncheckedUpdateManyWithoutUserNestedInput
    campaignActivities?: CampaignActivityUncheckedUpdateManyWithoutUserNestedInput
    createdCampaigns?: CampaignUncheckedUpdateManyWithoutCreatedByNestedInput
    uploadedCampaignImages?: CampaignImageUncheckedUpdateManyWithoutUploadedByNestedInput
    completedCampaignTasks?: CampaignTaskUncheckedUpdateManyWithoutCompletedByNestedInput
    leadEmployees?: EmployeeProfileUncheckedUpdateManyWithoutManagerNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
  }

  export type UserCreateWithoutRefreshTokensInput = {
    id?: string
    email: string
    passwordHash: string
    name: string
    role: $Enums.Role
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    employeeProfile?: EmployeeProfileCreateNestedOneWithoutUserInput
    dailyEntries?: DailyEntryCreateNestedManyWithoutEmployeeInput
    placements?: PlacementCreateNestedManyWithoutEmployeeInput
    incentives?: IncentiveCreateNestedManyWithoutEmployeeInput
    campaignAssignments?: CampaignAssignmentCreateNestedManyWithoutUserInput
    campaignTeamLeads?: CampaignTeamLeadCreateNestedManyWithoutUserInput
    campaignActivities?: CampaignActivityCreateNestedManyWithoutUserInput
    createdCampaigns?: CampaignCreateNestedManyWithoutCreatedByInput
    uploadedCampaignImages?: CampaignImageCreateNestedManyWithoutUploadedByInput
    completedCampaignTasks?: CampaignTaskCreateNestedManyWithoutCompletedByInput
    leadEmployees?: EmployeeProfileCreateNestedManyWithoutManagerInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
  }

  export type UserUncheckedCreateWithoutRefreshTokensInput = {
    id?: string
    email: string
    passwordHash: string
    name: string
    role: $Enums.Role
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    employeeProfile?: EmployeeProfileUncheckedCreateNestedOneWithoutUserInput
    dailyEntries?: DailyEntryUncheckedCreateNestedManyWithoutEmployeeInput
    placements?: PlacementUncheckedCreateNestedManyWithoutEmployeeInput
    incentives?: IncentiveUncheckedCreateNestedManyWithoutEmployeeInput
    campaignAssignments?: CampaignAssignmentUncheckedCreateNestedManyWithoutUserInput
    campaignTeamLeads?: CampaignTeamLeadUncheckedCreateNestedManyWithoutUserInput
    campaignActivities?: CampaignActivityUncheckedCreateNestedManyWithoutUserInput
    createdCampaigns?: CampaignUncheckedCreateNestedManyWithoutCreatedByInput
    uploadedCampaignImages?: CampaignImageUncheckedCreateNestedManyWithoutUploadedByInput
    completedCampaignTasks?: CampaignTaskUncheckedCreateNestedManyWithoutCompletedByInput
    leadEmployees?: EmployeeProfileUncheckedCreateNestedManyWithoutManagerInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
  }

  export type UserCreateOrConnectWithoutRefreshTokensInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRefreshTokensInput, UserUncheckedCreateWithoutRefreshTokensInput>
  }

  export type UserUpsertWithoutRefreshTokensInput = {
    update: XOR<UserUpdateWithoutRefreshTokensInput, UserUncheckedUpdateWithoutRefreshTokensInput>
    create: XOR<UserCreateWithoutRefreshTokensInput, UserUncheckedCreateWithoutRefreshTokensInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutRefreshTokensInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutRefreshTokensInput, UserUncheckedUpdateWithoutRefreshTokensInput>
  }

  export type UserUpdateWithoutRefreshTokensInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employeeProfile?: EmployeeProfileUpdateOneWithoutUserNestedInput
    dailyEntries?: DailyEntryUpdateManyWithoutEmployeeNestedInput
    placements?: PlacementUpdateManyWithoutEmployeeNestedInput
    incentives?: IncentiveUpdateManyWithoutEmployeeNestedInput
    campaignAssignments?: CampaignAssignmentUpdateManyWithoutUserNestedInput
    campaignTeamLeads?: CampaignTeamLeadUpdateManyWithoutUserNestedInput
    campaignActivities?: CampaignActivityUpdateManyWithoutUserNestedInput
    createdCampaigns?: CampaignUpdateManyWithoutCreatedByNestedInput
    uploadedCampaignImages?: CampaignImageUpdateManyWithoutUploadedByNestedInput
    completedCampaignTasks?: CampaignTaskUpdateManyWithoutCompletedByNestedInput
    leadEmployees?: EmployeeProfileUpdateManyWithoutManagerNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
  }

  export type UserUncheckedUpdateWithoutRefreshTokensInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employeeProfile?: EmployeeProfileUncheckedUpdateOneWithoutUserNestedInput
    dailyEntries?: DailyEntryUncheckedUpdateManyWithoutEmployeeNestedInput
    placements?: PlacementUncheckedUpdateManyWithoutEmployeeNestedInput
    incentives?: IncentiveUncheckedUpdateManyWithoutEmployeeNestedInput
    campaignAssignments?: CampaignAssignmentUncheckedUpdateManyWithoutUserNestedInput
    campaignTeamLeads?: CampaignTeamLeadUncheckedUpdateManyWithoutUserNestedInput
    campaignActivities?: CampaignActivityUncheckedUpdateManyWithoutUserNestedInput
    createdCampaigns?: CampaignUncheckedUpdateManyWithoutCreatedByNestedInput
    uploadedCampaignImages?: CampaignImageUncheckedUpdateManyWithoutUploadedByNestedInput
    completedCampaignTasks?: CampaignTaskUncheckedUpdateManyWithoutCompletedByNestedInput
    leadEmployees?: EmployeeProfileUncheckedUpdateManyWithoutManagerNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
  }

  export type UserCreateWithoutCreatedCampaignsInput = {
    id?: string
    email: string
    passwordHash: string
    name: string
    role: $Enums.Role
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    employeeProfile?: EmployeeProfileCreateNestedOneWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    dailyEntries?: DailyEntryCreateNestedManyWithoutEmployeeInput
    placements?: PlacementCreateNestedManyWithoutEmployeeInput
    incentives?: IncentiveCreateNestedManyWithoutEmployeeInput
    campaignAssignments?: CampaignAssignmentCreateNestedManyWithoutUserInput
    campaignTeamLeads?: CampaignTeamLeadCreateNestedManyWithoutUserInput
    campaignActivities?: CampaignActivityCreateNestedManyWithoutUserInput
    uploadedCampaignImages?: CampaignImageCreateNestedManyWithoutUploadedByInput
    completedCampaignTasks?: CampaignTaskCreateNestedManyWithoutCompletedByInput
    leadEmployees?: EmployeeProfileCreateNestedManyWithoutManagerInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
  }

  export type UserUncheckedCreateWithoutCreatedCampaignsInput = {
    id?: string
    email: string
    passwordHash: string
    name: string
    role: $Enums.Role
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    employeeProfile?: EmployeeProfileUncheckedCreateNestedOneWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    dailyEntries?: DailyEntryUncheckedCreateNestedManyWithoutEmployeeInput
    placements?: PlacementUncheckedCreateNestedManyWithoutEmployeeInput
    incentives?: IncentiveUncheckedCreateNestedManyWithoutEmployeeInput
    campaignAssignments?: CampaignAssignmentUncheckedCreateNestedManyWithoutUserInput
    campaignTeamLeads?: CampaignTeamLeadUncheckedCreateNestedManyWithoutUserInput
    campaignActivities?: CampaignActivityUncheckedCreateNestedManyWithoutUserInput
    uploadedCampaignImages?: CampaignImageUncheckedCreateNestedManyWithoutUploadedByInput
    completedCampaignTasks?: CampaignTaskUncheckedCreateNestedManyWithoutCompletedByInput
    leadEmployees?: EmployeeProfileUncheckedCreateNestedManyWithoutManagerInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
  }

  export type UserCreateOrConnectWithoutCreatedCampaignsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedCampaignsInput, UserUncheckedCreateWithoutCreatedCampaignsInput>
  }

  export type CampaignImageCreateWithoutCampaignInput = {
    id?: string
    url: string
    title?: string | null
    description?: string | null
    createdAt?: Date | string
    uploadedBy: UserCreateNestedOneWithoutUploadedCampaignImagesInput
  }

  export type CampaignImageUncheckedCreateWithoutCampaignInput = {
    id?: string
    url: string
    title?: string | null
    description?: string | null
    uploadedById: string
    createdAt?: Date | string
  }

  export type CampaignImageCreateOrConnectWithoutCampaignInput = {
    where: CampaignImageWhereUniqueInput
    create: XOR<CampaignImageCreateWithoutCampaignInput, CampaignImageUncheckedCreateWithoutCampaignInput>
  }

  export type CampaignImageCreateManyCampaignInputEnvelope = {
    data: CampaignImageCreateManyCampaignInput | CampaignImageCreateManyCampaignInput[]
    skipDuplicates?: boolean
  }

  export type CampaignTeamLeadCreateWithoutCampaignInput = {
    id?: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutCampaignTeamLeadsInput
  }

  export type CampaignTeamLeadUncheckedCreateWithoutCampaignInput = {
    id?: string
    userId: string
    createdAt?: Date | string
  }

  export type CampaignTeamLeadCreateOrConnectWithoutCampaignInput = {
    where: CampaignTeamLeadWhereUniqueInput
    create: XOR<CampaignTeamLeadCreateWithoutCampaignInput, CampaignTeamLeadUncheckedCreateWithoutCampaignInput>
  }

  export type CampaignTeamLeadCreateManyCampaignInputEnvelope = {
    data: CampaignTeamLeadCreateManyCampaignInput | CampaignTeamLeadCreateManyCampaignInput[]
    skipDuplicates?: boolean
  }

  export type CampaignAssignmentCreateWithoutCampaignInput = {
    id?: string
    role: $Enums.Role
    targetAmount: Decimal | DecimalJsLike | number | string
    progressPercent?: number
    isCompleted?: boolean
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutCampaignAssignmentsInput
    tasks?: CampaignTaskCreateNestedManyWithoutAssignmentInput
  }

  export type CampaignAssignmentUncheckedCreateWithoutCampaignInput = {
    id?: string
    userId: string
    role: $Enums.Role
    targetAmount: Decimal | DecimalJsLike | number | string
    progressPercent?: number
    isCompleted?: boolean
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tasks?: CampaignTaskUncheckedCreateNestedManyWithoutAssignmentInput
  }

  export type CampaignAssignmentCreateOrConnectWithoutCampaignInput = {
    where: CampaignAssignmentWhereUniqueInput
    create: XOR<CampaignAssignmentCreateWithoutCampaignInput, CampaignAssignmentUncheckedCreateWithoutCampaignInput>
  }

  export type CampaignAssignmentCreateManyCampaignInputEnvelope = {
    data: CampaignAssignmentCreateManyCampaignInput | CampaignAssignmentCreateManyCampaignInput[]
    skipDuplicates?: boolean
  }

  export type CampaignTaskCreateWithoutCampaignInput = {
    id?: string
    title: string
    description?: string | null
    isCompleted?: boolean
    dueDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    assignment?: CampaignAssignmentCreateNestedOneWithoutTasksInput
    completedBy?: UserCreateNestedOneWithoutCompletedCampaignTasksInput
  }

  export type CampaignTaskUncheckedCreateWithoutCampaignInput = {
    id?: string
    assignmentId?: string | null
    title: string
    description?: string | null
    isCompleted?: boolean
    completedById?: string | null
    dueDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CampaignTaskCreateOrConnectWithoutCampaignInput = {
    where: CampaignTaskWhereUniqueInput
    create: XOR<CampaignTaskCreateWithoutCampaignInput, CampaignTaskUncheckedCreateWithoutCampaignInput>
  }

  export type CampaignTaskCreateManyCampaignInputEnvelope = {
    data: CampaignTaskCreateManyCampaignInput | CampaignTaskCreateManyCampaignInput[]
    skipDuplicates?: boolean
  }

  export type CampaignActivityCreateWithoutCampaignInput = {
    id?: string
    action: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutCampaignActivitiesInput
  }

  export type CampaignActivityUncheckedCreateWithoutCampaignInput = {
    id?: string
    userId: string
    action: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type CampaignActivityCreateOrConnectWithoutCampaignInput = {
    where: CampaignActivityWhereUniqueInput
    create: XOR<CampaignActivityCreateWithoutCampaignInput, CampaignActivityUncheckedCreateWithoutCampaignInput>
  }

  export type CampaignActivityCreateManyCampaignInputEnvelope = {
    data: CampaignActivityCreateManyCampaignInput | CampaignActivityCreateManyCampaignInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutCreatedCampaignsInput = {
    update: XOR<UserUpdateWithoutCreatedCampaignsInput, UserUncheckedUpdateWithoutCreatedCampaignsInput>
    create: XOR<UserCreateWithoutCreatedCampaignsInput, UserUncheckedCreateWithoutCreatedCampaignsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedCampaignsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedCampaignsInput, UserUncheckedUpdateWithoutCreatedCampaignsInput>
  }

  export type UserUpdateWithoutCreatedCampaignsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employeeProfile?: EmployeeProfileUpdateOneWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    dailyEntries?: DailyEntryUpdateManyWithoutEmployeeNestedInput
    placements?: PlacementUpdateManyWithoutEmployeeNestedInput
    incentives?: IncentiveUpdateManyWithoutEmployeeNestedInput
    campaignAssignments?: CampaignAssignmentUpdateManyWithoutUserNestedInput
    campaignTeamLeads?: CampaignTeamLeadUpdateManyWithoutUserNestedInput
    campaignActivities?: CampaignActivityUpdateManyWithoutUserNestedInput
    uploadedCampaignImages?: CampaignImageUpdateManyWithoutUploadedByNestedInput
    completedCampaignTasks?: CampaignTaskUpdateManyWithoutCompletedByNestedInput
    leadEmployees?: EmployeeProfileUpdateManyWithoutManagerNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedCampaignsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employeeProfile?: EmployeeProfileUncheckedUpdateOneWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    dailyEntries?: DailyEntryUncheckedUpdateManyWithoutEmployeeNestedInput
    placements?: PlacementUncheckedUpdateManyWithoutEmployeeNestedInput
    incentives?: IncentiveUncheckedUpdateManyWithoutEmployeeNestedInput
    campaignAssignments?: CampaignAssignmentUncheckedUpdateManyWithoutUserNestedInput
    campaignTeamLeads?: CampaignTeamLeadUncheckedUpdateManyWithoutUserNestedInput
    campaignActivities?: CampaignActivityUncheckedUpdateManyWithoutUserNestedInput
    uploadedCampaignImages?: CampaignImageUncheckedUpdateManyWithoutUploadedByNestedInput
    completedCampaignTasks?: CampaignTaskUncheckedUpdateManyWithoutCompletedByNestedInput
    leadEmployees?: EmployeeProfileUncheckedUpdateManyWithoutManagerNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
  }

  export type CampaignImageUpsertWithWhereUniqueWithoutCampaignInput = {
    where: CampaignImageWhereUniqueInput
    update: XOR<CampaignImageUpdateWithoutCampaignInput, CampaignImageUncheckedUpdateWithoutCampaignInput>
    create: XOR<CampaignImageCreateWithoutCampaignInput, CampaignImageUncheckedCreateWithoutCampaignInput>
  }

  export type CampaignImageUpdateWithWhereUniqueWithoutCampaignInput = {
    where: CampaignImageWhereUniqueInput
    data: XOR<CampaignImageUpdateWithoutCampaignInput, CampaignImageUncheckedUpdateWithoutCampaignInput>
  }

  export type CampaignImageUpdateManyWithWhereWithoutCampaignInput = {
    where: CampaignImageScalarWhereInput
    data: XOR<CampaignImageUpdateManyMutationInput, CampaignImageUncheckedUpdateManyWithoutCampaignInput>
  }

  export type CampaignTeamLeadUpsertWithWhereUniqueWithoutCampaignInput = {
    where: CampaignTeamLeadWhereUniqueInput
    update: XOR<CampaignTeamLeadUpdateWithoutCampaignInput, CampaignTeamLeadUncheckedUpdateWithoutCampaignInput>
    create: XOR<CampaignTeamLeadCreateWithoutCampaignInput, CampaignTeamLeadUncheckedCreateWithoutCampaignInput>
  }

  export type CampaignTeamLeadUpdateWithWhereUniqueWithoutCampaignInput = {
    where: CampaignTeamLeadWhereUniqueInput
    data: XOR<CampaignTeamLeadUpdateWithoutCampaignInput, CampaignTeamLeadUncheckedUpdateWithoutCampaignInput>
  }

  export type CampaignTeamLeadUpdateManyWithWhereWithoutCampaignInput = {
    where: CampaignTeamLeadScalarWhereInput
    data: XOR<CampaignTeamLeadUpdateManyMutationInput, CampaignTeamLeadUncheckedUpdateManyWithoutCampaignInput>
  }

  export type CampaignAssignmentUpsertWithWhereUniqueWithoutCampaignInput = {
    where: CampaignAssignmentWhereUniqueInput
    update: XOR<CampaignAssignmentUpdateWithoutCampaignInput, CampaignAssignmentUncheckedUpdateWithoutCampaignInput>
    create: XOR<CampaignAssignmentCreateWithoutCampaignInput, CampaignAssignmentUncheckedCreateWithoutCampaignInput>
  }

  export type CampaignAssignmentUpdateWithWhereUniqueWithoutCampaignInput = {
    where: CampaignAssignmentWhereUniqueInput
    data: XOR<CampaignAssignmentUpdateWithoutCampaignInput, CampaignAssignmentUncheckedUpdateWithoutCampaignInput>
  }

  export type CampaignAssignmentUpdateManyWithWhereWithoutCampaignInput = {
    where: CampaignAssignmentScalarWhereInput
    data: XOR<CampaignAssignmentUpdateManyMutationInput, CampaignAssignmentUncheckedUpdateManyWithoutCampaignInput>
  }

  export type CampaignTaskUpsertWithWhereUniqueWithoutCampaignInput = {
    where: CampaignTaskWhereUniqueInput
    update: XOR<CampaignTaskUpdateWithoutCampaignInput, CampaignTaskUncheckedUpdateWithoutCampaignInput>
    create: XOR<CampaignTaskCreateWithoutCampaignInput, CampaignTaskUncheckedCreateWithoutCampaignInput>
  }

  export type CampaignTaskUpdateWithWhereUniqueWithoutCampaignInput = {
    where: CampaignTaskWhereUniqueInput
    data: XOR<CampaignTaskUpdateWithoutCampaignInput, CampaignTaskUncheckedUpdateWithoutCampaignInput>
  }

  export type CampaignTaskUpdateManyWithWhereWithoutCampaignInput = {
    where: CampaignTaskScalarWhereInput
    data: XOR<CampaignTaskUpdateManyMutationInput, CampaignTaskUncheckedUpdateManyWithoutCampaignInput>
  }

  export type CampaignActivityUpsertWithWhereUniqueWithoutCampaignInput = {
    where: CampaignActivityWhereUniqueInput
    update: XOR<CampaignActivityUpdateWithoutCampaignInput, CampaignActivityUncheckedUpdateWithoutCampaignInput>
    create: XOR<CampaignActivityCreateWithoutCampaignInput, CampaignActivityUncheckedCreateWithoutCampaignInput>
  }

  export type CampaignActivityUpdateWithWhereUniqueWithoutCampaignInput = {
    where: CampaignActivityWhereUniqueInput
    data: XOR<CampaignActivityUpdateWithoutCampaignInput, CampaignActivityUncheckedUpdateWithoutCampaignInput>
  }

  export type CampaignActivityUpdateManyWithWhereWithoutCampaignInput = {
    where: CampaignActivityScalarWhereInput
    data: XOR<CampaignActivityUpdateManyMutationInput, CampaignActivityUncheckedUpdateManyWithoutCampaignInput>
  }

  export type CampaignCreateWithoutImagesInput = {
    id?: string
    name: string
    description?: string | null
    objective?: string | null
    status?: $Enums.CampaignStatus
    targetAmount: Decimal | DecimalJsLike | number | string
    startDate: Date | string
    endDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: UserCreateNestedOneWithoutCreatedCampaignsInput
    teamLeads?: CampaignTeamLeadCreateNestedManyWithoutCampaignInput
    assignments?: CampaignAssignmentCreateNestedManyWithoutCampaignInput
    tasks?: CampaignTaskCreateNestedManyWithoutCampaignInput
    activities?: CampaignActivityCreateNestedManyWithoutCampaignInput
  }

  export type CampaignUncheckedCreateWithoutImagesInput = {
    id?: string
    name: string
    description?: string | null
    objective?: string | null
    status?: $Enums.CampaignStatus
    targetAmount: Decimal | DecimalJsLike | number | string
    startDate: Date | string
    endDate: Date | string
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    teamLeads?: CampaignTeamLeadUncheckedCreateNestedManyWithoutCampaignInput
    assignments?: CampaignAssignmentUncheckedCreateNestedManyWithoutCampaignInput
    tasks?: CampaignTaskUncheckedCreateNestedManyWithoutCampaignInput
    activities?: CampaignActivityUncheckedCreateNestedManyWithoutCampaignInput
  }

  export type CampaignCreateOrConnectWithoutImagesInput = {
    where: CampaignWhereUniqueInput
    create: XOR<CampaignCreateWithoutImagesInput, CampaignUncheckedCreateWithoutImagesInput>
  }

  export type UserCreateWithoutUploadedCampaignImagesInput = {
    id?: string
    email: string
    passwordHash: string
    name: string
    role: $Enums.Role
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    employeeProfile?: EmployeeProfileCreateNestedOneWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    dailyEntries?: DailyEntryCreateNestedManyWithoutEmployeeInput
    placements?: PlacementCreateNestedManyWithoutEmployeeInput
    incentives?: IncentiveCreateNestedManyWithoutEmployeeInput
    campaignAssignments?: CampaignAssignmentCreateNestedManyWithoutUserInput
    campaignTeamLeads?: CampaignTeamLeadCreateNestedManyWithoutUserInput
    campaignActivities?: CampaignActivityCreateNestedManyWithoutUserInput
    createdCampaigns?: CampaignCreateNestedManyWithoutCreatedByInput
    completedCampaignTasks?: CampaignTaskCreateNestedManyWithoutCompletedByInput
    leadEmployees?: EmployeeProfileCreateNestedManyWithoutManagerInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
  }

  export type UserUncheckedCreateWithoutUploadedCampaignImagesInput = {
    id?: string
    email: string
    passwordHash: string
    name: string
    role: $Enums.Role
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    employeeProfile?: EmployeeProfileUncheckedCreateNestedOneWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    dailyEntries?: DailyEntryUncheckedCreateNestedManyWithoutEmployeeInput
    placements?: PlacementUncheckedCreateNestedManyWithoutEmployeeInput
    incentives?: IncentiveUncheckedCreateNestedManyWithoutEmployeeInput
    campaignAssignments?: CampaignAssignmentUncheckedCreateNestedManyWithoutUserInput
    campaignTeamLeads?: CampaignTeamLeadUncheckedCreateNestedManyWithoutUserInput
    campaignActivities?: CampaignActivityUncheckedCreateNestedManyWithoutUserInput
    createdCampaigns?: CampaignUncheckedCreateNestedManyWithoutCreatedByInput
    completedCampaignTasks?: CampaignTaskUncheckedCreateNestedManyWithoutCompletedByInput
    leadEmployees?: EmployeeProfileUncheckedCreateNestedManyWithoutManagerInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
  }

  export type UserCreateOrConnectWithoutUploadedCampaignImagesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUploadedCampaignImagesInput, UserUncheckedCreateWithoutUploadedCampaignImagesInput>
  }

  export type CampaignUpsertWithoutImagesInput = {
    update: XOR<CampaignUpdateWithoutImagesInput, CampaignUncheckedUpdateWithoutImagesInput>
    create: XOR<CampaignCreateWithoutImagesInput, CampaignUncheckedCreateWithoutImagesInput>
    where?: CampaignWhereInput
  }

  export type CampaignUpdateToOneWithWhereWithoutImagesInput = {
    where?: CampaignWhereInput
    data: XOR<CampaignUpdateWithoutImagesInput, CampaignUncheckedUpdateWithoutImagesInput>
  }

  export type CampaignUpdateWithoutImagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    objective?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    targetAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutCreatedCampaignsNestedInput
    teamLeads?: CampaignTeamLeadUpdateManyWithoutCampaignNestedInput
    assignments?: CampaignAssignmentUpdateManyWithoutCampaignNestedInput
    tasks?: CampaignTaskUpdateManyWithoutCampaignNestedInput
    activities?: CampaignActivityUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignUncheckedUpdateWithoutImagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    objective?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    targetAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teamLeads?: CampaignTeamLeadUncheckedUpdateManyWithoutCampaignNestedInput
    assignments?: CampaignAssignmentUncheckedUpdateManyWithoutCampaignNestedInput
    tasks?: CampaignTaskUncheckedUpdateManyWithoutCampaignNestedInput
    activities?: CampaignActivityUncheckedUpdateManyWithoutCampaignNestedInput
  }

  export type UserUpsertWithoutUploadedCampaignImagesInput = {
    update: XOR<UserUpdateWithoutUploadedCampaignImagesInput, UserUncheckedUpdateWithoutUploadedCampaignImagesInput>
    create: XOR<UserCreateWithoutUploadedCampaignImagesInput, UserUncheckedCreateWithoutUploadedCampaignImagesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUploadedCampaignImagesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUploadedCampaignImagesInput, UserUncheckedUpdateWithoutUploadedCampaignImagesInput>
  }

  export type UserUpdateWithoutUploadedCampaignImagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employeeProfile?: EmployeeProfileUpdateOneWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    dailyEntries?: DailyEntryUpdateManyWithoutEmployeeNestedInput
    placements?: PlacementUpdateManyWithoutEmployeeNestedInput
    incentives?: IncentiveUpdateManyWithoutEmployeeNestedInput
    campaignAssignments?: CampaignAssignmentUpdateManyWithoutUserNestedInput
    campaignTeamLeads?: CampaignTeamLeadUpdateManyWithoutUserNestedInput
    campaignActivities?: CampaignActivityUpdateManyWithoutUserNestedInput
    createdCampaigns?: CampaignUpdateManyWithoutCreatedByNestedInput
    completedCampaignTasks?: CampaignTaskUpdateManyWithoutCompletedByNestedInput
    leadEmployees?: EmployeeProfileUpdateManyWithoutManagerNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
  }

  export type UserUncheckedUpdateWithoutUploadedCampaignImagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employeeProfile?: EmployeeProfileUncheckedUpdateOneWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    dailyEntries?: DailyEntryUncheckedUpdateManyWithoutEmployeeNestedInput
    placements?: PlacementUncheckedUpdateManyWithoutEmployeeNestedInput
    incentives?: IncentiveUncheckedUpdateManyWithoutEmployeeNestedInput
    campaignAssignments?: CampaignAssignmentUncheckedUpdateManyWithoutUserNestedInput
    campaignTeamLeads?: CampaignTeamLeadUncheckedUpdateManyWithoutUserNestedInput
    campaignActivities?: CampaignActivityUncheckedUpdateManyWithoutUserNestedInput
    createdCampaigns?: CampaignUncheckedUpdateManyWithoutCreatedByNestedInput
    completedCampaignTasks?: CampaignTaskUncheckedUpdateManyWithoutCompletedByNestedInput
    leadEmployees?: EmployeeProfileUncheckedUpdateManyWithoutManagerNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
  }

  export type CampaignCreateWithoutTeamLeadsInput = {
    id?: string
    name: string
    description?: string | null
    objective?: string | null
    status?: $Enums.CampaignStatus
    targetAmount: Decimal | DecimalJsLike | number | string
    startDate: Date | string
    endDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: UserCreateNestedOneWithoutCreatedCampaignsInput
    images?: CampaignImageCreateNestedManyWithoutCampaignInput
    assignments?: CampaignAssignmentCreateNestedManyWithoutCampaignInput
    tasks?: CampaignTaskCreateNestedManyWithoutCampaignInput
    activities?: CampaignActivityCreateNestedManyWithoutCampaignInput
  }

  export type CampaignUncheckedCreateWithoutTeamLeadsInput = {
    id?: string
    name: string
    description?: string | null
    objective?: string | null
    status?: $Enums.CampaignStatus
    targetAmount: Decimal | DecimalJsLike | number | string
    startDate: Date | string
    endDate: Date | string
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    images?: CampaignImageUncheckedCreateNestedManyWithoutCampaignInput
    assignments?: CampaignAssignmentUncheckedCreateNestedManyWithoutCampaignInput
    tasks?: CampaignTaskUncheckedCreateNestedManyWithoutCampaignInput
    activities?: CampaignActivityUncheckedCreateNestedManyWithoutCampaignInput
  }

  export type CampaignCreateOrConnectWithoutTeamLeadsInput = {
    where: CampaignWhereUniqueInput
    create: XOR<CampaignCreateWithoutTeamLeadsInput, CampaignUncheckedCreateWithoutTeamLeadsInput>
  }

  export type UserCreateWithoutCampaignTeamLeadsInput = {
    id?: string
    email: string
    passwordHash: string
    name: string
    role: $Enums.Role
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    employeeProfile?: EmployeeProfileCreateNestedOneWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    dailyEntries?: DailyEntryCreateNestedManyWithoutEmployeeInput
    placements?: PlacementCreateNestedManyWithoutEmployeeInput
    incentives?: IncentiveCreateNestedManyWithoutEmployeeInput
    campaignAssignments?: CampaignAssignmentCreateNestedManyWithoutUserInput
    campaignActivities?: CampaignActivityCreateNestedManyWithoutUserInput
    createdCampaigns?: CampaignCreateNestedManyWithoutCreatedByInput
    uploadedCampaignImages?: CampaignImageCreateNestedManyWithoutUploadedByInput
    completedCampaignTasks?: CampaignTaskCreateNestedManyWithoutCompletedByInput
    leadEmployees?: EmployeeProfileCreateNestedManyWithoutManagerInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
  }

  export type UserUncheckedCreateWithoutCampaignTeamLeadsInput = {
    id?: string
    email: string
    passwordHash: string
    name: string
    role: $Enums.Role
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    employeeProfile?: EmployeeProfileUncheckedCreateNestedOneWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    dailyEntries?: DailyEntryUncheckedCreateNestedManyWithoutEmployeeInput
    placements?: PlacementUncheckedCreateNestedManyWithoutEmployeeInput
    incentives?: IncentiveUncheckedCreateNestedManyWithoutEmployeeInput
    campaignAssignments?: CampaignAssignmentUncheckedCreateNestedManyWithoutUserInput
    campaignActivities?: CampaignActivityUncheckedCreateNestedManyWithoutUserInput
    createdCampaigns?: CampaignUncheckedCreateNestedManyWithoutCreatedByInput
    uploadedCampaignImages?: CampaignImageUncheckedCreateNestedManyWithoutUploadedByInput
    completedCampaignTasks?: CampaignTaskUncheckedCreateNestedManyWithoutCompletedByInput
    leadEmployees?: EmployeeProfileUncheckedCreateNestedManyWithoutManagerInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
  }

  export type UserCreateOrConnectWithoutCampaignTeamLeadsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCampaignTeamLeadsInput, UserUncheckedCreateWithoutCampaignTeamLeadsInput>
  }

  export type CampaignUpsertWithoutTeamLeadsInput = {
    update: XOR<CampaignUpdateWithoutTeamLeadsInput, CampaignUncheckedUpdateWithoutTeamLeadsInput>
    create: XOR<CampaignCreateWithoutTeamLeadsInput, CampaignUncheckedCreateWithoutTeamLeadsInput>
    where?: CampaignWhereInput
  }

  export type CampaignUpdateToOneWithWhereWithoutTeamLeadsInput = {
    where?: CampaignWhereInput
    data: XOR<CampaignUpdateWithoutTeamLeadsInput, CampaignUncheckedUpdateWithoutTeamLeadsInput>
  }

  export type CampaignUpdateWithoutTeamLeadsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    objective?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    targetAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutCreatedCampaignsNestedInput
    images?: CampaignImageUpdateManyWithoutCampaignNestedInput
    assignments?: CampaignAssignmentUpdateManyWithoutCampaignNestedInput
    tasks?: CampaignTaskUpdateManyWithoutCampaignNestedInput
    activities?: CampaignActivityUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignUncheckedUpdateWithoutTeamLeadsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    objective?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    targetAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    images?: CampaignImageUncheckedUpdateManyWithoutCampaignNestedInput
    assignments?: CampaignAssignmentUncheckedUpdateManyWithoutCampaignNestedInput
    tasks?: CampaignTaskUncheckedUpdateManyWithoutCampaignNestedInput
    activities?: CampaignActivityUncheckedUpdateManyWithoutCampaignNestedInput
  }

  export type UserUpsertWithoutCampaignTeamLeadsInput = {
    update: XOR<UserUpdateWithoutCampaignTeamLeadsInput, UserUncheckedUpdateWithoutCampaignTeamLeadsInput>
    create: XOR<UserCreateWithoutCampaignTeamLeadsInput, UserUncheckedCreateWithoutCampaignTeamLeadsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCampaignTeamLeadsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCampaignTeamLeadsInput, UserUncheckedUpdateWithoutCampaignTeamLeadsInput>
  }

  export type UserUpdateWithoutCampaignTeamLeadsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employeeProfile?: EmployeeProfileUpdateOneWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    dailyEntries?: DailyEntryUpdateManyWithoutEmployeeNestedInput
    placements?: PlacementUpdateManyWithoutEmployeeNestedInput
    incentives?: IncentiveUpdateManyWithoutEmployeeNestedInput
    campaignAssignments?: CampaignAssignmentUpdateManyWithoutUserNestedInput
    campaignActivities?: CampaignActivityUpdateManyWithoutUserNestedInput
    createdCampaigns?: CampaignUpdateManyWithoutCreatedByNestedInput
    uploadedCampaignImages?: CampaignImageUpdateManyWithoutUploadedByNestedInput
    completedCampaignTasks?: CampaignTaskUpdateManyWithoutCompletedByNestedInput
    leadEmployees?: EmployeeProfileUpdateManyWithoutManagerNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
  }

  export type UserUncheckedUpdateWithoutCampaignTeamLeadsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employeeProfile?: EmployeeProfileUncheckedUpdateOneWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    dailyEntries?: DailyEntryUncheckedUpdateManyWithoutEmployeeNestedInput
    placements?: PlacementUncheckedUpdateManyWithoutEmployeeNestedInput
    incentives?: IncentiveUncheckedUpdateManyWithoutEmployeeNestedInput
    campaignAssignments?: CampaignAssignmentUncheckedUpdateManyWithoutUserNestedInput
    campaignActivities?: CampaignActivityUncheckedUpdateManyWithoutUserNestedInput
    createdCampaigns?: CampaignUncheckedUpdateManyWithoutCreatedByNestedInput
    uploadedCampaignImages?: CampaignImageUncheckedUpdateManyWithoutUploadedByNestedInput
    completedCampaignTasks?: CampaignTaskUncheckedUpdateManyWithoutCompletedByNestedInput
    leadEmployees?: EmployeeProfileUncheckedUpdateManyWithoutManagerNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
  }

  export type CampaignCreateWithoutAssignmentsInput = {
    id?: string
    name: string
    description?: string | null
    objective?: string | null
    status?: $Enums.CampaignStatus
    targetAmount: Decimal | DecimalJsLike | number | string
    startDate: Date | string
    endDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: UserCreateNestedOneWithoutCreatedCampaignsInput
    images?: CampaignImageCreateNestedManyWithoutCampaignInput
    teamLeads?: CampaignTeamLeadCreateNestedManyWithoutCampaignInput
    tasks?: CampaignTaskCreateNestedManyWithoutCampaignInput
    activities?: CampaignActivityCreateNestedManyWithoutCampaignInput
  }

  export type CampaignUncheckedCreateWithoutAssignmentsInput = {
    id?: string
    name: string
    description?: string | null
    objective?: string | null
    status?: $Enums.CampaignStatus
    targetAmount: Decimal | DecimalJsLike | number | string
    startDate: Date | string
    endDate: Date | string
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    images?: CampaignImageUncheckedCreateNestedManyWithoutCampaignInput
    teamLeads?: CampaignTeamLeadUncheckedCreateNestedManyWithoutCampaignInput
    tasks?: CampaignTaskUncheckedCreateNestedManyWithoutCampaignInput
    activities?: CampaignActivityUncheckedCreateNestedManyWithoutCampaignInput
  }

  export type CampaignCreateOrConnectWithoutAssignmentsInput = {
    where: CampaignWhereUniqueInput
    create: XOR<CampaignCreateWithoutAssignmentsInput, CampaignUncheckedCreateWithoutAssignmentsInput>
  }

  export type UserCreateWithoutCampaignAssignmentsInput = {
    id?: string
    email: string
    passwordHash: string
    name: string
    role: $Enums.Role
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    employeeProfile?: EmployeeProfileCreateNestedOneWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    dailyEntries?: DailyEntryCreateNestedManyWithoutEmployeeInput
    placements?: PlacementCreateNestedManyWithoutEmployeeInput
    incentives?: IncentiveCreateNestedManyWithoutEmployeeInput
    campaignTeamLeads?: CampaignTeamLeadCreateNestedManyWithoutUserInput
    campaignActivities?: CampaignActivityCreateNestedManyWithoutUserInput
    createdCampaigns?: CampaignCreateNestedManyWithoutCreatedByInput
    uploadedCampaignImages?: CampaignImageCreateNestedManyWithoutUploadedByInput
    completedCampaignTasks?: CampaignTaskCreateNestedManyWithoutCompletedByInput
    leadEmployees?: EmployeeProfileCreateNestedManyWithoutManagerInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
  }

  export type UserUncheckedCreateWithoutCampaignAssignmentsInput = {
    id?: string
    email: string
    passwordHash: string
    name: string
    role: $Enums.Role
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    employeeProfile?: EmployeeProfileUncheckedCreateNestedOneWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    dailyEntries?: DailyEntryUncheckedCreateNestedManyWithoutEmployeeInput
    placements?: PlacementUncheckedCreateNestedManyWithoutEmployeeInput
    incentives?: IncentiveUncheckedCreateNestedManyWithoutEmployeeInput
    campaignTeamLeads?: CampaignTeamLeadUncheckedCreateNestedManyWithoutUserInput
    campaignActivities?: CampaignActivityUncheckedCreateNestedManyWithoutUserInput
    createdCampaigns?: CampaignUncheckedCreateNestedManyWithoutCreatedByInput
    uploadedCampaignImages?: CampaignImageUncheckedCreateNestedManyWithoutUploadedByInput
    completedCampaignTasks?: CampaignTaskUncheckedCreateNestedManyWithoutCompletedByInput
    leadEmployees?: EmployeeProfileUncheckedCreateNestedManyWithoutManagerInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
  }

  export type UserCreateOrConnectWithoutCampaignAssignmentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCampaignAssignmentsInput, UserUncheckedCreateWithoutCampaignAssignmentsInput>
  }

  export type CampaignTaskCreateWithoutAssignmentInput = {
    id?: string
    title: string
    description?: string | null
    isCompleted?: boolean
    dueDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    campaign: CampaignCreateNestedOneWithoutTasksInput
    completedBy?: UserCreateNestedOneWithoutCompletedCampaignTasksInput
  }

  export type CampaignTaskUncheckedCreateWithoutAssignmentInput = {
    id?: string
    campaignId: string
    title: string
    description?: string | null
    isCompleted?: boolean
    completedById?: string | null
    dueDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CampaignTaskCreateOrConnectWithoutAssignmentInput = {
    where: CampaignTaskWhereUniqueInput
    create: XOR<CampaignTaskCreateWithoutAssignmentInput, CampaignTaskUncheckedCreateWithoutAssignmentInput>
  }

  export type CampaignTaskCreateManyAssignmentInputEnvelope = {
    data: CampaignTaskCreateManyAssignmentInput | CampaignTaskCreateManyAssignmentInput[]
    skipDuplicates?: boolean
  }

  export type CampaignUpsertWithoutAssignmentsInput = {
    update: XOR<CampaignUpdateWithoutAssignmentsInput, CampaignUncheckedUpdateWithoutAssignmentsInput>
    create: XOR<CampaignCreateWithoutAssignmentsInput, CampaignUncheckedCreateWithoutAssignmentsInput>
    where?: CampaignWhereInput
  }

  export type CampaignUpdateToOneWithWhereWithoutAssignmentsInput = {
    where?: CampaignWhereInput
    data: XOR<CampaignUpdateWithoutAssignmentsInput, CampaignUncheckedUpdateWithoutAssignmentsInput>
  }

  export type CampaignUpdateWithoutAssignmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    objective?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    targetAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutCreatedCampaignsNestedInput
    images?: CampaignImageUpdateManyWithoutCampaignNestedInput
    teamLeads?: CampaignTeamLeadUpdateManyWithoutCampaignNestedInput
    tasks?: CampaignTaskUpdateManyWithoutCampaignNestedInput
    activities?: CampaignActivityUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignUncheckedUpdateWithoutAssignmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    objective?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    targetAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    images?: CampaignImageUncheckedUpdateManyWithoutCampaignNestedInput
    teamLeads?: CampaignTeamLeadUncheckedUpdateManyWithoutCampaignNestedInput
    tasks?: CampaignTaskUncheckedUpdateManyWithoutCampaignNestedInput
    activities?: CampaignActivityUncheckedUpdateManyWithoutCampaignNestedInput
  }

  export type UserUpsertWithoutCampaignAssignmentsInput = {
    update: XOR<UserUpdateWithoutCampaignAssignmentsInput, UserUncheckedUpdateWithoutCampaignAssignmentsInput>
    create: XOR<UserCreateWithoutCampaignAssignmentsInput, UserUncheckedCreateWithoutCampaignAssignmentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCampaignAssignmentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCampaignAssignmentsInput, UserUncheckedUpdateWithoutCampaignAssignmentsInput>
  }

  export type UserUpdateWithoutCampaignAssignmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employeeProfile?: EmployeeProfileUpdateOneWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    dailyEntries?: DailyEntryUpdateManyWithoutEmployeeNestedInput
    placements?: PlacementUpdateManyWithoutEmployeeNestedInput
    incentives?: IncentiveUpdateManyWithoutEmployeeNestedInput
    campaignTeamLeads?: CampaignTeamLeadUpdateManyWithoutUserNestedInput
    campaignActivities?: CampaignActivityUpdateManyWithoutUserNestedInput
    createdCampaigns?: CampaignUpdateManyWithoutCreatedByNestedInput
    uploadedCampaignImages?: CampaignImageUpdateManyWithoutUploadedByNestedInput
    completedCampaignTasks?: CampaignTaskUpdateManyWithoutCompletedByNestedInput
    leadEmployees?: EmployeeProfileUpdateManyWithoutManagerNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
  }

  export type UserUncheckedUpdateWithoutCampaignAssignmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employeeProfile?: EmployeeProfileUncheckedUpdateOneWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    dailyEntries?: DailyEntryUncheckedUpdateManyWithoutEmployeeNestedInput
    placements?: PlacementUncheckedUpdateManyWithoutEmployeeNestedInput
    incentives?: IncentiveUncheckedUpdateManyWithoutEmployeeNestedInput
    campaignTeamLeads?: CampaignTeamLeadUncheckedUpdateManyWithoutUserNestedInput
    campaignActivities?: CampaignActivityUncheckedUpdateManyWithoutUserNestedInput
    createdCampaigns?: CampaignUncheckedUpdateManyWithoutCreatedByNestedInput
    uploadedCampaignImages?: CampaignImageUncheckedUpdateManyWithoutUploadedByNestedInput
    completedCampaignTasks?: CampaignTaskUncheckedUpdateManyWithoutCompletedByNestedInput
    leadEmployees?: EmployeeProfileUncheckedUpdateManyWithoutManagerNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
  }

  export type CampaignTaskUpsertWithWhereUniqueWithoutAssignmentInput = {
    where: CampaignTaskWhereUniqueInput
    update: XOR<CampaignTaskUpdateWithoutAssignmentInput, CampaignTaskUncheckedUpdateWithoutAssignmentInput>
    create: XOR<CampaignTaskCreateWithoutAssignmentInput, CampaignTaskUncheckedCreateWithoutAssignmentInput>
  }

  export type CampaignTaskUpdateWithWhereUniqueWithoutAssignmentInput = {
    where: CampaignTaskWhereUniqueInput
    data: XOR<CampaignTaskUpdateWithoutAssignmentInput, CampaignTaskUncheckedUpdateWithoutAssignmentInput>
  }

  export type CampaignTaskUpdateManyWithWhereWithoutAssignmentInput = {
    where: CampaignTaskScalarWhereInput
    data: XOR<CampaignTaskUpdateManyMutationInput, CampaignTaskUncheckedUpdateManyWithoutAssignmentInput>
  }

  export type CampaignCreateWithoutTasksInput = {
    id?: string
    name: string
    description?: string | null
    objective?: string | null
    status?: $Enums.CampaignStatus
    targetAmount: Decimal | DecimalJsLike | number | string
    startDate: Date | string
    endDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: UserCreateNestedOneWithoutCreatedCampaignsInput
    images?: CampaignImageCreateNestedManyWithoutCampaignInput
    teamLeads?: CampaignTeamLeadCreateNestedManyWithoutCampaignInput
    assignments?: CampaignAssignmentCreateNestedManyWithoutCampaignInput
    activities?: CampaignActivityCreateNestedManyWithoutCampaignInput
  }

  export type CampaignUncheckedCreateWithoutTasksInput = {
    id?: string
    name: string
    description?: string | null
    objective?: string | null
    status?: $Enums.CampaignStatus
    targetAmount: Decimal | DecimalJsLike | number | string
    startDate: Date | string
    endDate: Date | string
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    images?: CampaignImageUncheckedCreateNestedManyWithoutCampaignInput
    teamLeads?: CampaignTeamLeadUncheckedCreateNestedManyWithoutCampaignInput
    assignments?: CampaignAssignmentUncheckedCreateNestedManyWithoutCampaignInput
    activities?: CampaignActivityUncheckedCreateNestedManyWithoutCampaignInput
  }

  export type CampaignCreateOrConnectWithoutTasksInput = {
    where: CampaignWhereUniqueInput
    create: XOR<CampaignCreateWithoutTasksInput, CampaignUncheckedCreateWithoutTasksInput>
  }

  export type CampaignAssignmentCreateWithoutTasksInput = {
    id?: string
    role: $Enums.Role
    targetAmount: Decimal | DecimalJsLike | number | string
    progressPercent?: number
    isCompleted?: boolean
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    campaign: CampaignCreateNestedOneWithoutAssignmentsInput
    user: UserCreateNestedOneWithoutCampaignAssignmentsInput
  }

  export type CampaignAssignmentUncheckedCreateWithoutTasksInput = {
    id?: string
    campaignId: string
    userId: string
    role: $Enums.Role
    targetAmount: Decimal | DecimalJsLike | number | string
    progressPercent?: number
    isCompleted?: boolean
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CampaignAssignmentCreateOrConnectWithoutTasksInput = {
    where: CampaignAssignmentWhereUniqueInput
    create: XOR<CampaignAssignmentCreateWithoutTasksInput, CampaignAssignmentUncheckedCreateWithoutTasksInput>
  }

  export type UserCreateWithoutCompletedCampaignTasksInput = {
    id?: string
    email: string
    passwordHash: string
    name: string
    role: $Enums.Role
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    employeeProfile?: EmployeeProfileCreateNestedOneWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    dailyEntries?: DailyEntryCreateNestedManyWithoutEmployeeInput
    placements?: PlacementCreateNestedManyWithoutEmployeeInput
    incentives?: IncentiveCreateNestedManyWithoutEmployeeInput
    campaignAssignments?: CampaignAssignmentCreateNestedManyWithoutUserInput
    campaignTeamLeads?: CampaignTeamLeadCreateNestedManyWithoutUserInput
    campaignActivities?: CampaignActivityCreateNestedManyWithoutUserInput
    createdCampaigns?: CampaignCreateNestedManyWithoutCreatedByInput
    uploadedCampaignImages?: CampaignImageCreateNestedManyWithoutUploadedByInput
    leadEmployees?: EmployeeProfileCreateNestedManyWithoutManagerInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
  }

  export type UserUncheckedCreateWithoutCompletedCampaignTasksInput = {
    id?: string
    email: string
    passwordHash: string
    name: string
    role: $Enums.Role
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    employeeProfile?: EmployeeProfileUncheckedCreateNestedOneWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    dailyEntries?: DailyEntryUncheckedCreateNestedManyWithoutEmployeeInput
    placements?: PlacementUncheckedCreateNestedManyWithoutEmployeeInput
    incentives?: IncentiveUncheckedCreateNestedManyWithoutEmployeeInput
    campaignAssignments?: CampaignAssignmentUncheckedCreateNestedManyWithoutUserInput
    campaignTeamLeads?: CampaignTeamLeadUncheckedCreateNestedManyWithoutUserInput
    campaignActivities?: CampaignActivityUncheckedCreateNestedManyWithoutUserInput
    createdCampaigns?: CampaignUncheckedCreateNestedManyWithoutCreatedByInput
    uploadedCampaignImages?: CampaignImageUncheckedCreateNestedManyWithoutUploadedByInput
    leadEmployees?: EmployeeProfileUncheckedCreateNestedManyWithoutManagerInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
  }

  export type UserCreateOrConnectWithoutCompletedCampaignTasksInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCompletedCampaignTasksInput, UserUncheckedCreateWithoutCompletedCampaignTasksInput>
  }

  export type CampaignUpsertWithoutTasksInput = {
    update: XOR<CampaignUpdateWithoutTasksInput, CampaignUncheckedUpdateWithoutTasksInput>
    create: XOR<CampaignCreateWithoutTasksInput, CampaignUncheckedCreateWithoutTasksInput>
    where?: CampaignWhereInput
  }

  export type CampaignUpdateToOneWithWhereWithoutTasksInput = {
    where?: CampaignWhereInput
    data: XOR<CampaignUpdateWithoutTasksInput, CampaignUncheckedUpdateWithoutTasksInput>
  }

  export type CampaignUpdateWithoutTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    objective?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    targetAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutCreatedCampaignsNestedInput
    images?: CampaignImageUpdateManyWithoutCampaignNestedInput
    teamLeads?: CampaignTeamLeadUpdateManyWithoutCampaignNestedInput
    assignments?: CampaignAssignmentUpdateManyWithoutCampaignNestedInput
    activities?: CampaignActivityUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignUncheckedUpdateWithoutTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    objective?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    targetAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    images?: CampaignImageUncheckedUpdateManyWithoutCampaignNestedInput
    teamLeads?: CampaignTeamLeadUncheckedUpdateManyWithoutCampaignNestedInput
    assignments?: CampaignAssignmentUncheckedUpdateManyWithoutCampaignNestedInput
    activities?: CampaignActivityUncheckedUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignAssignmentUpsertWithoutTasksInput = {
    update: XOR<CampaignAssignmentUpdateWithoutTasksInput, CampaignAssignmentUncheckedUpdateWithoutTasksInput>
    create: XOR<CampaignAssignmentCreateWithoutTasksInput, CampaignAssignmentUncheckedCreateWithoutTasksInput>
    where?: CampaignAssignmentWhereInput
  }

  export type CampaignAssignmentUpdateToOneWithWhereWithoutTasksInput = {
    where?: CampaignAssignmentWhereInput
    data: XOR<CampaignAssignmentUpdateWithoutTasksInput, CampaignAssignmentUncheckedUpdateWithoutTasksInput>
  }

  export type CampaignAssignmentUpdateWithoutTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    targetAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    progressPercent?: IntFieldUpdateOperationsInput | number
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaign?: CampaignUpdateOneRequiredWithoutAssignmentsNestedInput
    user?: UserUpdateOneRequiredWithoutCampaignAssignmentsNestedInput
  }

  export type CampaignAssignmentUncheckedUpdateWithoutTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    targetAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    progressPercent?: IntFieldUpdateOperationsInput | number
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutCompletedCampaignTasksInput = {
    update: XOR<UserUpdateWithoutCompletedCampaignTasksInput, UserUncheckedUpdateWithoutCompletedCampaignTasksInput>
    create: XOR<UserCreateWithoutCompletedCampaignTasksInput, UserUncheckedCreateWithoutCompletedCampaignTasksInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCompletedCampaignTasksInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCompletedCampaignTasksInput, UserUncheckedUpdateWithoutCompletedCampaignTasksInput>
  }

  export type UserUpdateWithoutCompletedCampaignTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employeeProfile?: EmployeeProfileUpdateOneWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    dailyEntries?: DailyEntryUpdateManyWithoutEmployeeNestedInput
    placements?: PlacementUpdateManyWithoutEmployeeNestedInput
    incentives?: IncentiveUpdateManyWithoutEmployeeNestedInput
    campaignAssignments?: CampaignAssignmentUpdateManyWithoutUserNestedInput
    campaignTeamLeads?: CampaignTeamLeadUpdateManyWithoutUserNestedInput
    campaignActivities?: CampaignActivityUpdateManyWithoutUserNestedInput
    createdCampaigns?: CampaignUpdateManyWithoutCreatedByNestedInput
    uploadedCampaignImages?: CampaignImageUpdateManyWithoutUploadedByNestedInput
    leadEmployees?: EmployeeProfileUpdateManyWithoutManagerNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
  }

  export type UserUncheckedUpdateWithoutCompletedCampaignTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employeeProfile?: EmployeeProfileUncheckedUpdateOneWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    dailyEntries?: DailyEntryUncheckedUpdateManyWithoutEmployeeNestedInput
    placements?: PlacementUncheckedUpdateManyWithoutEmployeeNestedInput
    incentives?: IncentiveUncheckedUpdateManyWithoutEmployeeNestedInput
    campaignAssignments?: CampaignAssignmentUncheckedUpdateManyWithoutUserNestedInput
    campaignTeamLeads?: CampaignTeamLeadUncheckedUpdateManyWithoutUserNestedInput
    campaignActivities?: CampaignActivityUncheckedUpdateManyWithoutUserNestedInput
    createdCampaigns?: CampaignUncheckedUpdateManyWithoutCreatedByNestedInput
    uploadedCampaignImages?: CampaignImageUncheckedUpdateManyWithoutUploadedByNestedInput
    leadEmployees?: EmployeeProfileUncheckedUpdateManyWithoutManagerNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
  }

  export type CampaignCreateWithoutActivitiesInput = {
    id?: string
    name: string
    description?: string | null
    objective?: string | null
    status?: $Enums.CampaignStatus
    targetAmount: Decimal | DecimalJsLike | number | string
    startDate: Date | string
    endDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: UserCreateNestedOneWithoutCreatedCampaignsInput
    images?: CampaignImageCreateNestedManyWithoutCampaignInput
    teamLeads?: CampaignTeamLeadCreateNestedManyWithoutCampaignInput
    assignments?: CampaignAssignmentCreateNestedManyWithoutCampaignInput
    tasks?: CampaignTaskCreateNestedManyWithoutCampaignInput
  }

  export type CampaignUncheckedCreateWithoutActivitiesInput = {
    id?: string
    name: string
    description?: string | null
    objective?: string | null
    status?: $Enums.CampaignStatus
    targetAmount: Decimal | DecimalJsLike | number | string
    startDate: Date | string
    endDate: Date | string
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    images?: CampaignImageUncheckedCreateNestedManyWithoutCampaignInput
    teamLeads?: CampaignTeamLeadUncheckedCreateNestedManyWithoutCampaignInput
    assignments?: CampaignAssignmentUncheckedCreateNestedManyWithoutCampaignInput
    tasks?: CampaignTaskUncheckedCreateNestedManyWithoutCampaignInput
  }

  export type CampaignCreateOrConnectWithoutActivitiesInput = {
    where: CampaignWhereUniqueInput
    create: XOR<CampaignCreateWithoutActivitiesInput, CampaignUncheckedCreateWithoutActivitiesInput>
  }

  export type UserCreateWithoutCampaignActivitiesInput = {
    id?: string
    email: string
    passwordHash: string
    name: string
    role: $Enums.Role
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    employeeProfile?: EmployeeProfileCreateNestedOneWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    dailyEntries?: DailyEntryCreateNestedManyWithoutEmployeeInput
    placements?: PlacementCreateNestedManyWithoutEmployeeInput
    incentives?: IncentiveCreateNestedManyWithoutEmployeeInput
    campaignAssignments?: CampaignAssignmentCreateNestedManyWithoutUserInput
    campaignTeamLeads?: CampaignTeamLeadCreateNestedManyWithoutUserInput
    createdCampaigns?: CampaignCreateNestedManyWithoutCreatedByInput
    uploadedCampaignImages?: CampaignImageCreateNestedManyWithoutUploadedByInput
    completedCampaignTasks?: CampaignTaskCreateNestedManyWithoutCompletedByInput
    leadEmployees?: EmployeeProfileCreateNestedManyWithoutManagerInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
  }

  export type UserUncheckedCreateWithoutCampaignActivitiesInput = {
    id?: string
    email: string
    passwordHash: string
    name: string
    role: $Enums.Role
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    employeeProfile?: EmployeeProfileUncheckedCreateNestedOneWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    dailyEntries?: DailyEntryUncheckedCreateNestedManyWithoutEmployeeInput
    placements?: PlacementUncheckedCreateNestedManyWithoutEmployeeInput
    incentives?: IncentiveUncheckedCreateNestedManyWithoutEmployeeInput
    campaignAssignments?: CampaignAssignmentUncheckedCreateNestedManyWithoutUserInput
    campaignTeamLeads?: CampaignTeamLeadUncheckedCreateNestedManyWithoutUserInput
    createdCampaigns?: CampaignUncheckedCreateNestedManyWithoutCreatedByInput
    uploadedCampaignImages?: CampaignImageUncheckedCreateNestedManyWithoutUploadedByInput
    completedCampaignTasks?: CampaignTaskUncheckedCreateNestedManyWithoutCompletedByInput
    leadEmployees?: EmployeeProfileUncheckedCreateNestedManyWithoutManagerInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
  }

  export type UserCreateOrConnectWithoutCampaignActivitiesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCampaignActivitiesInput, UserUncheckedCreateWithoutCampaignActivitiesInput>
  }

  export type CampaignUpsertWithoutActivitiesInput = {
    update: XOR<CampaignUpdateWithoutActivitiesInput, CampaignUncheckedUpdateWithoutActivitiesInput>
    create: XOR<CampaignCreateWithoutActivitiesInput, CampaignUncheckedCreateWithoutActivitiesInput>
    where?: CampaignWhereInput
  }

  export type CampaignUpdateToOneWithWhereWithoutActivitiesInput = {
    where?: CampaignWhereInput
    data: XOR<CampaignUpdateWithoutActivitiesInput, CampaignUncheckedUpdateWithoutActivitiesInput>
  }

  export type CampaignUpdateWithoutActivitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    objective?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    targetAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutCreatedCampaignsNestedInput
    images?: CampaignImageUpdateManyWithoutCampaignNestedInput
    teamLeads?: CampaignTeamLeadUpdateManyWithoutCampaignNestedInput
    assignments?: CampaignAssignmentUpdateManyWithoutCampaignNestedInput
    tasks?: CampaignTaskUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignUncheckedUpdateWithoutActivitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    objective?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    targetAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    images?: CampaignImageUncheckedUpdateManyWithoutCampaignNestedInput
    teamLeads?: CampaignTeamLeadUncheckedUpdateManyWithoutCampaignNestedInput
    assignments?: CampaignAssignmentUncheckedUpdateManyWithoutCampaignNestedInput
    tasks?: CampaignTaskUncheckedUpdateManyWithoutCampaignNestedInput
  }

  export type UserUpsertWithoutCampaignActivitiesInput = {
    update: XOR<UserUpdateWithoutCampaignActivitiesInput, UserUncheckedUpdateWithoutCampaignActivitiesInput>
    create: XOR<UserCreateWithoutCampaignActivitiesInput, UserUncheckedCreateWithoutCampaignActivitiesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCampaignActivitiesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCampaignActivitiesInput, UserUncheckedUpdateWithoutCampaignActivitiesInput>
  }

  export type UserUpdateWithoutCampaignActivitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employeeProfile?: EmployeeProfileUpdateOneWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    dailyEntries?: DailyEntryUpdateManyWithoutEmployeeNestedInput
    placements?: PlacementUpdateManyWithoutEmployeeNestedInput
    incentives?: IncentiveUpdateManyWithoutEmployeeNestedInput
    campaignAssignments?: CampaignAssignmentUpdateManyWithoutUserNestedInput
    campaignTeamLeads?: CampaignTeamLeadUpdateManyWithoutUserNestedInput
    createdCampaigns?: CampaignUpdateManyWithoutCreatedByNestedInput
    uploadedCampaignImages?: CampaignImageUpdateManyWithoutUploadedByNestedInput
    completedCampaignTasks?: CampaignTaskUpdateManyWithoutCompletedByNestedInput
    leadEmployees?: EmployeeProfileUpdateManyWithoutManagerNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
  }

  export type UserUncheckedUpdateWithoutCampaignActivitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employeeProfile?: EmployeeProfileUncheckedUpdateOneWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    dailyEntries?: DailyEntryUncheckedUpdateManyWithoutEmployeeNestedInput
    placements?: PlacementUncheckedUpdateManyWithoutEmployeeNestedInput
    incentives?: IncentiveUncheckedUpdateManyWithoutEmployeeNestedInput
    campaignAssignments?: CampaignAssignmentUncheckedUpdateManyWithoutUserNestedInput
    campaignTeamLeads?: CampaignTeamLeadUncheckedUpdateManyWithoutUserNestedInput
    createdCampaigns?: CampaignUncheckedUpdateManyWithoutCreatedByNestedInput
    uploadedCampaignImages?: CampaignImageUncheckedUpdateManyWithoutUploadedByNestedInput
    completedCampaignTasks?: CampaignTaskUncheckedUpdateManyWithoutCompletedByNestedInput
    leadEmployees?: EmployeeProfileUncheckedUpdateManyWithoutManagerNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
  }

  export type UserCreateWithoutAuditLogsInput = {
    id?: string
    email: string
    passwordHash: string
    name: string
    role: $Enums.Role
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    employeeProfile?: EmployeeProfileCreateNestedOneWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    dailyEntries?: DailyEntryCreateNestedManyWithoutEmployeeInput
    placements?: PlacementCreateNestedManyWithoutEmployeeInput
    incentives?: IncentiveCreateNestedManyWithoutEmployeeInput
    campaignAssignments?: CampaignAssignmentCreateNestedManyWithoutUserInput
    campaignTeamLeads?: CampaignTeamLeadCreateNestedManyWithoutUserInput
    campaignActivities?: CampaignActivityCreateNestedManyWithoutUserInput
    createdCampaigns?: CampaignCreateNestedManyWithoutCreatedByInput
    uploadedCampaignImages?: CampaignImageCreateNestedManyWithoutUploadedByInput
    completedCampaignTasks?: CampaignTaskCreateNestedManyWithoutCompletedByInput
    leadEmployees?: EmployeeProfileCreateNestedManyWithoutManagerInput
  }

  export type UserUncheckedCreateWithoutAuditLogsInput = {
    id?: string
    email: string
    passwordHash: string
    name: string
    role: $Enums.Role
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    employeeProfile?: EmployeeProfileUncheckedCreateNestedOneWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    dailyEntries?: DailyEntryUncheckedCreateNestedManyWithoutEmployeeInput
    placements?: PlacementUncheckedCreateNestedManyWithoutEmployeeInput
    incentives?: IncentiveUncheckedCreateNestedManyWithoutEmployeeInput
    campaignAssignments?: CampaignAssignmentUncheckedCreateNestedManyWithoutUserInput
    campaignTeamLeads?: CampaignTeamLeadUncheckedCreateNestedManyWithoutUserInput
    campaignActivities?: CampaignActivityUncheckedCreateNestedManyWithoutUserInput
    createdCampaigns?: CampaignUncheckedCreateNestedManyWithoutCreatedByInput
    uploadedCampaignImages?: CampaignImageUncheckedCreateNestedManyWithoutUploadedByInput
    completedCampaignTasks?: CampaignTaskUncheckedCreateNestedManyWithoutCompletedByInput
    leadEmployees?: EmployeeProfileUncheckedCreateNestedManyWithoutManagerInput
  }

  export type UserCreateOrConnectWithoutAuditLogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
  }

  export type UserUpsertWithoutAuditLogsInput = {
    update: XOR<UserUpdateWithoutAuditLogsInput, UserUncheckedUpdateWithoutAuditLogsInput>
    create: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAuditLogsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAuditLogsInput, UserUncheckedUpdateWithoutAuditLogsInput>
  }

  export type UserUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employeeProfile?: EmployeeProfileUpdateOneWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    dailyEntries?: DailyEntryUpdateManyWithoutEmployeeNestedInput
    placements?: PlacementUpdateManyWithoutEmployeeNestedInput
    incentives?: IncentiveUpdateManyWithoutEmployeeNestedInput
    campaignAssignments?: CampaignAssignmentUpdateManyWithoutUserNestedInput
    campaignTeamLeads?: CampaignTeamLeadUpdateManyWithoutUserNestedInput
    campaignActivities?: CampaignActivityUpdateManyWithoutUserNestedInput
    createdCampaigns?: CampaignUpdateManyWithoutCreatedByNestedInput
    uploadedCampaignImages?: CampaignImageUpdateManyWithoutUploadedByNestedInput
    completedCampaignTasks?: CampaignTaskUpdateManyWithoutCompletedByNestedInput
    leadEmployees?: EmployeeProfileUpdateManyWithoutManagerNestedInput
  }

  export type UserUncheckedUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employeeProfile?: EmployeeProfileUncheckedUpdateOneWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    dailyEntries?: DailyEntryUncheckedUpdateManyWithoutEmployeeNestedInput
    placements?: PlacementUncheckedUpdateManyWithoutEmployeeNestedInput
    incentives?: IncentiveUncheckedUpdateManyWithoutEmployeeNestedInput
    campaignAssignments?: CampaignAssignmentUncheckedUpdateManyWithoutUserNestedInput
    campaignTeamLeads?: CampaignTeamLeadUncheckedUpdateManyWithoutUserNestedInput
    campaignActivities?: CampaignActivityUncheckedUpdateManyWithoutUserNestedInput
    createdCampaigns?: CampaignUncheckedUpdateManyWithoutCreatedByNestedInput
    uploadedCampaignImages?: CampaignImageUncheckedUpdateManyWithoutUploadedByNestedInput
    completedCampaignTasks?: CampaignTaskUncheckedUpdateManyWithoutCompletedByNestedInput
    leadEmployees?: EmployeeProfileUncheckedUpdateManyWithoutManagerNestedInput
  }

  export type EmployeeProfileCreateManyTeamInput = {
    id: string
    managerId?: string | null
    level?: string | null
    yearlyTarget: Decimal | DecimalJsLike | number | string
    isActive?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmployeeProfileUpdateWithoutTeamInput = {
    level?: NullableStringFieldUpdateOperationsInput | string | null
    yearlyTarget?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutEmployeeProfileNestedInput
    manager?: UserUpdateOneWithoutLeadEmployeesNestedInput
  }

  export type EmployeeProfileUncheckedUpdateWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    yearlyTarget?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeProfileUncheckedUpdateManyWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    yearlyTarget?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefreshTokenCreateManyUserInput = {
    id?: string
    token: string
    isRevoked?: boolean
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type DailyEntryCreateManyEmployeeInput = {
    id?: string
    date: Date | string
    clientName: string
    placementType: $Enums.PlacementType
    revenue: Decimal | DecimalJsLike | number | string
    marginPercent: Decimal | DecimalJsLike | number | string
    billingStatus: $Enums.BillingStatus
    doi: Date | string
    doj: Date | string
    remarks?: string | null
    createdAt?: Date | string
  }

  export type PlacementCreateManyEmployeeInput = {
    id?: string
    candidateName: string
    clientName: string
    doi: Date | string
    doj: Date | string
    daysCompleted: number
    placementType: $Enums.PlacementType
    billedHours?: number | null
    marginPercent: Decimal | DecimalJsLike | number | string
    revenue: Decimal | DecimalJsLike | number | string
    billingStatus: $Enums.BillingStatus
    incentivePayoutEta?: Date | string | null
    incentiveAmountInr: Decimal | DecimalJsLike | number | string
    incentivePaid: boolean
    qualifier: boolean
    createdAt?: Date | string
  }

  export type IncentiveCreateManyEmployeeInput = {
    id?: string
    periodStart: Date | string
    periodEnd: Date | string
    revenueTotal: Decimal | DecimalJsLike | number | string
    slabName: string
    amountUsd: Decimal | DecimalJsLike | number | string
    amountInr: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
  }

  export type CampaignAssignmentCreateManyUserInput = {
    id?: string
    campaignId: string
    role: $Enums.Role
    targetAmount: Decimal | DecimalJsLike | number | string
    progressPercent?: number
    isCompleted?: boolean
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CampaignTeamLeadCreateManyUserInput = {
    id?: string
    campaignId: string
    createdAt?: Date | string
  }

  export type CampaignActivityCreateManyUserInput = {
    id?: string
    campaignId: string
    action: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type CampaignCreateManyCreatedByInput = {
    id?: string
    name: string
    description?: string | null
    objective?: string | null
    status?: $Enums.CampaignStatus
    targetAmount: Decimal | DecimalJsLike | number | string
    startDate: Date | string
    endDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CampaignImageCreateManyUploadedByInput = {
    id?: string
    campaignId: string
    url: string
    title?: string | null
    description?: string | null
    createdAt?: Date | string
  }

  export type CampaignTaskCreateManyCompletedByInput = {
    id?: string
    campaignId: string
    assignmentId?: string | null
    title: string
    description?: string | null
    isCompleted?: boolean
    dueDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmployeeProfileCreateManyManagerInput = {
    id: string
    teamId?: string | null
    level?: string | null
    yearlyTarget: Decimal | DecimalJsLike | number | string
    isActive?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AuditLogCreateManyActorInput = {
    id?: string
    action: string
    entityType: string
    entityId: string
    changes?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type RefreshTokenUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    isRevoked?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefreshTokenUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    isRevoked?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefreshTokenUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    isRevoked?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DailyEntryUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    clientName?: StringFieldUpdateOperationsInput | string
    placementType?: EnumPlacementTypeFieldUpdateOperationsInput | $Enums.PlacementType
    revenue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    marginPercent?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    billingStatus?: EnumBillingStatusFieldUpdateOperationsInput | $Enums.BillingStatus
    doi?: DateTimeFieldUpdateOperationsInput | Date | string
    doj?: DateTimeFieldUpdateOperationsInput | Date | string
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DailyEntryUncheckedUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    clientName?: StringFieldUpdateOperationsInput | string
    placementType?: EnumPlacementTypeFieldUpdateOperationsInput | $Enums.PlacementType
    revenue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    marginPercent?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    billingStatus?: EnumBillingStatusFieldUpdateOperationsInput | $Enums.BillingStatus
    doi?: DateTimeFieldUpdateOperationsInput | Date | string
    doj?: DateTimeFieldUpdateOperationsInput | Date | string
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DailyEntryUncheckedUpdateManyWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    clientName?: StringFieldUpdateOperationsInput | string
    placementType?: EnumPlacementTypeFieldUpdateOperationsInput | $Enums.PlacementType
    revenue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    marginPercent?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    billingStatus?: EnumBillingStatusFieldUpdateOperationsInput | $Enums.BillingStatus
    doi?: DateTimeFieldUpdateOperationsInput | Date | string
    doj?: DateTimeFieldUpdateOperationsInput | Date | string
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlacementUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    candidateName?: StringFieldUpdateOperationsInput | string
    clientName?: StringFieldUpdateOperationsInput | string
    doi?: DateTimeFieldUpdateOperationsInput | Date | string
    doj?: DateTimeFieldUpdateOperationsInput | Date | string
    daysCompleted?: IntFieldUpdateOperationsInput | number
    placementType?: EnumPlacementTypeFieldUpdateOperationsInput | $Enums.PlacementType
    billedHours?: NullableIntFieldUpdateOperationsInput | number | null
    marginPercent?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    revenue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    billingStatus?: EnumBillingStatusFieldUpdateOperationsInput | $Enums.BillingStatus
    incentivePayoutEta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    incentiveAmountInr?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    incentivePaid?: BoolFieldUpdateOperationsInput | boolean
    qualifier?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    monthlyBillings?: MonthlyBillingUpdateManyWithoutPlacementNestedInput
  }

  export type PlacementUncheckedUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    candidateName?: StringFieldUpdateOperationsInput | string
    clientName?: StringFieldUpdateOperationsInput | string
    doi?: DateTimeFieldUpdateOperationsInput | Date | string
    doj?: DateTimeFieldUpdateOperationsInput | Date | string
    daysCompleted?: IntFieldUpdateOperationsInput | number
    placementType?: EnumPlacementTypeFieldUpdateOperationsInput | $Enums.PlacementType
    billedHours?: NullableIntFieldUpdateOperationsInput | number | null
    marginPercent?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    revenue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    billingStatus?: EnumBillingStatusFieldUpdateOperationsInput | $Enums.BillingStatus
    incentivePayoutEta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    incentiveAmountInr?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    incentivePaid?: BoolFieldUpdateOperationsInput | boolean
    qualifier?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    monthlyBillings?: MonthlyBillingUncheckedUpdateManyWithoutPlacementNestedInput
  }

  export type PlacementUncheckedUpdateManyWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    candidateName?: StringFieldUpdateOperationsInput | string
    clientName?: StringFieldUpdateOperationsInput | string
    doi?: DateTimeFieldUpdateOperationsInput | Date | string
    doj?: DateTimeFieldUpdateOperationsInput | Date | string
    daysCompleted?: IntFieldUpdateOperationsInput | number
    placementType?: EnumPlacementTypeFieldUpdateOperationsInput | $Enums.PlacementType
    billedHours?: NullableIntFieldUpdateOperationsInput | number | null
    marginPercent?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    revenue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    billingStatus?: EnumBillingStatusFieldUpdateOperationsInput | $Enums.BillingStatus
    incentivePayoutEta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    incentiveAmountInr?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    incentivePaid?: BoolFieldUpdateOperationsInput | boolean
    qualifier?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IncentiveUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    revenueTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    slabName?: StringFieldUpdateOperationsInput | string
    amountUsd?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amountInr?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IncentiveUncheckedUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    revenueTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    slabName?: StringFieldUpdateOperationsInput | string
    amountUsd?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amountInr?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IncentiveUncheckedUpdateManyWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    revenueTotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    slabName?: StringFieldUpdateOperationsInput | string
    amountUsd?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    amountInr?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignAssignmentUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    targetAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    progressPercent?: IntFieldUpdateOperationsInput | number
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaign?: CampaignUpdateOneRequiredWithoutAssignmentsNestedInput
    tasks?: CampaignTaskUpdateManyWithoutAssignmentNestedInput
  }

  export type CampaignAssignmentUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    targetAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    progressPercent?: IntFieldUpdateOperationsInput | number
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tasks?: CampaignTaskUncheckedUpdateManyWithoutAssignmentNestedInput
  }

  export type CampaignAssignmentUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    targetAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    progressPercent?: IntFieldUpdateOperationsInput | number
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignTeamLeadUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaign?: CampaignUpdateOneRequiredWithoutTeamLeadsNestedInput
  }

  export type CampaignTeamLeadUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignTeamLeadUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignActivityUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaign?: CampaignUpdateOneRequiredWithoutActivitiesNestedInput
  }

  export type CampaignActivityUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignActivityUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    objective?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    targetAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    images?: CampaignImageUpdateManyWithoutCampaignNestedInput
    teamLeads?: CampaignTeamLeadUpdateManyWithoutCampaignNestedInput
    assignments?: CampaignAssignmentUpdateManyWithoutCampaignNestedInput
    tasks?: CampaignTaskUpdateManyWithoutCampaignNestedInput
    activities?: CampaignActivityUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    objective?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    targetAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    images?: CampaignImageUncheckedUpdateManyWithoutCampaignNestedInput
    teamLeads?: CampaignTeamLeadUncheckedUpdateManyWithoutCampaignNestedInput
    assignments?: CampaignAssignmentUncheckedUpdateManyWithoutCampaignNestedInput
    tasks?: CampaignTaskUncheckedUpdateManyWithoutCampaignNestedInput
    activities?: CampaignActivityUncheckedUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    objective?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    targetAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignImageUpdateWithoutUploadedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaign?: CampaignUpdateOneRequiredWithoutImagesNestedInput
  }

  export type CampaignImageUncheckedUpdateWithoutUploadedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignImageUncheckedUpdateManyWithoutUploadedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignTaskUpdateWithoutCompletedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaign?: CampaignUpdateOneRequiredWithoutTasksNestedInput
    assignment?: CampaignAssignmentUpdateOneWithoutTasksNestedInput
  }

  export type CampaignTaskUncheckedUpdateWithoutCompletedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    assignmentId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignTaskUncheckedUpdateManyWithoutCompletedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    assignmentId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeProfileUpdateWithoutManagerInput = {
    level?: NullableStringFieldUpdateOperationsInput | string | null
    yearlyTarget?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutEmployeeProfileNestedInput
    team?: TeamUpdateOneWithoutEmployeesNestedInput
  }

  export type EmployeeProfileUncheckedUpdateWithoutManagerInput = {
    id?: StringFieldUpdateOperationsInput | string
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    yearlyTarget?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeProfileUncheckedUpdateManyWithoutManagerInput = {
    id?: StringFieldUpdateOperationsInput | string
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    yearlyTarget?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUpdateWithoutActorInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    changes?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateWithoutActorInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    changes?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyWithoutActorInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    changes?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MonthlyBillingCreateManyPlacementInput = {
    id?: string
    month: string
    hours?: number | null
    status: $Enums.BillingStatus
  }

  export type MonthlyBillingUpdateWithoutPlacementInput = {
    id?: StringFieldUpdateOperationsInput | string
    month?: StringFieldUpdateOperationsInput | string
    hours?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumBillingStatusFieldUpdateOperationsInput | $Enums.BillingStatus
  }

  export type MonthlyBillingUncheckedUpdateWithoutPlacementInput = {
    id?: StringFieldUpdateOperationsInput | string
    month?: StringFieldUpdateOperationsInput | string
    hours?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumBillingStatusFieldUpdateOperationsInput | $Enums.BillingStatus
  }

  export type MonthlyBillingUncheckedUpdateManyWithoutPlacementInput = {
    id?: StringFieldUpdateOperationsInput | string
    month?: StringFieldUpdateOperationsInput | string
    hours?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumBillingStatusFieldUpdateOperationsInput | $Enums.BillingStatus
  }

  export type CampaignImageCreateManyCampaignInput = {
    id?: string
    url: string
    title?: string | null
    description?: string | null
    uploadedById: string
    createdAt?: Date | string
  }

  export type CampaignTeamLeadCreateManyCampaignInput = {
    id?: string
    userId: string
    createdAt?: Date | string
  }

  export type CampaignAssignmentCreateManyCampaignInput = {
    id?: string
    userId: string
    role: $Enums.Role
    targetAmount: Decimal | DecimalJsLike | number | string
    progressPercent?: number
    isCompleted?: boolean
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CampaignTaskCreateManyCampaignInput = {
    id?: string
    assignmentId?: string | null
    title: string
    description?: string | null
    isCompleted?: boolean
    completedById?: string | null
    dueDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CampaignActivityCreateManyCampaignInput = {
    id?: string
    userId: string
    action: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type CampaignImageUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploadedBy?: UserUpdateOneRequiredWithoutUploadedCampaignImagesNestedInput
  }

  export type CampaignImageUncheckedUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignImageUncheckedUpdateManyWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignTeamLeadUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCampaignTeamLeadsNestedInput
  }

  export type CampaignTeamLeadUncheckedUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignTeamLeadUncheckedUpdateManyWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignAssignmentUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    targetAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    progressPercent?: IntFieldUpdateOperationsInput | number
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCampaignAssignmentsNestedInput
    tasks?: CampaignTaskUpdateManyWithoutAssignmentNestedInput
  }

  export type CampaignAssignmentUncheckedUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    targetAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    progressPercent?: IntFieldUpdateOperationsInput | number
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tasks?: CampaignTaskUncheckedUpdateManyWithoutAssignmentNestedInput
  }

  export type CampaignAssignmentUncheckedUpdateManyWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    targetAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    progressPercent?: IntFieldUpdateOperationsInput | number
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignTaskUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignment?: CampaignAssignmentUpdateOneWithoutTasksNestedInput
    completedBy?: UserUpdateOneWithoutCompletedCampaignTasksNestedInput
  }

  export type CampaignTaskUncheckedUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    assignmentId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    completedById?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignTaskUncheckedUpdateManyWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    assignmentId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    completedById?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignActivityUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCampaignActivitiesNestedInput
  }

  export type CampaignActivityUncheckedUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignActivityUncheckedUpdateManyWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignTaskCreateManyAssignmentInput = {
    id?: string
    campaignId: string
    title: string
    description?: string | null
    isCompleted?: boolean
    completedById?: string | null
    dueDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CampaignTaskUpdateWithoutAssignmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaign?: CampaignUpdateOneRequiredWithoutTasksNestedInput
    completedBy?: UserUpdateOneWithoutCompletedCampaignTasksNestedInput
  }

  export type CampaignTaskUncheckedUpdateWithoutAssignmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    completedById?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignTaskUncheckedUpdateManyWithoutAssignmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    completedById?: NullableStringFieldUpdateOperationsInput | string | null
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use TeamCountOutputTypeDefaultArgs instead
     */
    export type TeamCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TeamCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PlacementCountOutputTypeDefaultArgs instead
     */
    export type PlacementCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PlacementCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CampaignCountOutputTypeDefaultArgs instead
     */
    export type CampaignCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CampaignCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CampaignAssignmentCountOutputTypeDefaultArgs instead
     */
    export type CampaignAssignmentCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CampaignAssignmentCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TeamDefaultArgs instead
     */
    export type TeamArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TeamDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EmployeeProfileDefaultArgs instead
     */
    export type EmployeeProfileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EmployeeProfileDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DailyEntryDefaultArgs instead
     */
    export type DailyEntryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DailyEntryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PlacementDefaultArgs instead
     */
    export type PlacementArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PlacementDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MonthlyBillingDefaultArgs instead
     */
    export type MonthlyBillingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MonthlyBillingDefaultArgs<ExtArgs>
    /**
     * @deprecated Use IncentiveDefaultArgs instead
     */
    export type IncentiveArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = IncentiveDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RefreshTokenDefaultArgs instead
     */
    export type RefreshTokenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RefreshTokenDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CampaignDefaultArgs instead
     */
    export type CampaignArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CampaignDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CampaignImageDefaultArgs instead
     */
    export type CampaignImageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CampaignImageDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CampaignTeamLeadDefaultArgs instead
     */
    export type CampaignTeamLeadArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CampaignTeamLeadDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CampaignAssignmentDefaultArgs instead
     */
    export type CampaignAssignmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CampaignAssignmentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CampaignTaskDefaultArgs instead
     */
    export type CampaignTaskArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CampaignTaskDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CampaignActivityDefaultArgs instead
     */
    export type CampaignActivityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CampaignActivityDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AuditLogDefaultArgs instead
     */
    export type AuditLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AuditLogDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}